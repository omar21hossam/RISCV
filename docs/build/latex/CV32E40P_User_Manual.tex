%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{booktabs}{sphinx}
\PassOptionsToPackage{colorrows}{sphinx}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage[,numfigreset=1,mathnumfig]{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{2}



\title{CV32E40P User Manual}
\date{Apr 01, 2024}
\release{}
\author{OpenHW Group}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxstepscope


\chapter{Changelog}
\label{\detokenize{preface:changelog}}\label{\detokenize{preface::doc}}
\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
Changelog was not built because \sphinxcode{\sphinxupquote{sphinx\_github\_changelog\_token}} parameter is missing in the documentation configuration.
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Find the project changelog \sphinxhref{https://cv32e40p-user-manual.readthedocs.io/en/stable/\#changelog}{here}.
\end{sphinxadmonition}

\sphinxstepscope


\chapter{Introduction}
\label{\detokenize{intro:introduction}}\label{\detokenize{intro::doc}}
\sphinxAtStartPar
CV32E40P is a 4\sphinxhyphen{}stage in\sphinxhyphen{}order 32\sphinxhyphen{}bit RISC\sphinxhyphen{}V
processor core. The ISA of CV32E40P
has been extended to support multiple additional instructions including
hardware loops, post\sphinxhyphen{}increment load and store instructions,
additional ALU instructions and SIMD instructions that are not part of the standard RISC\sphinxhyphen{}V
ISA. \hyperref[\detokenize{intro:blockdiagram}]{Figure \ref{\detokenize{intro:blockdiagram}}} shows a block diagram of the top level with the core and the FPU.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{CV32E40P_Block_Diagram}.png}
\caption{Block Diagram of CV32E40P RISC\sphinxhyphen{}V Core}\label{\detokenize{intro:blockdiagram}}\end{figure}


\section{License}
\label{\detokenize{intro:license}}
\sphinxAtStartPar
Copyright 2023 OpenHW Group.

\sphinxAtStartPar
Copyright 2018 ETH Zurich and University of Bologna.

\sphinxAtStartPar
Copyright and related rights are licensed under the Solderpad Hardware
License, Version 0.51 (the “License”); you may not use this file except
in compliance with the License. You may obtain a copy of the License at
\sphinxurl{http://solderpad.org/licenses/SHL-0.51}. Unless required by applicable
law or agreed to in writing, software, hardware and materials
distributed under this License is distributed on an “AS IS” BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.


\section{Bus Interfaces}
\label{\detokenize{intro:bus-interfaces}}
\sphinxAtStartPar
The Instruction Fetch and Load/Store data bus interfaces are compliant to the \sphinxstylestrong{OBI} (Open Bus Interface) protocol.
See \sphinxhref{https://raw.githubusercontent.com/openhwgroup/obi/188c87089975a59c56338949f5c187c1f8841332/OBI-v1.2.pdf}{OBI\sphinxhyphen{}v1.2.pdf} for details about the protocol.
Additional information can be found in the {\hyperref[\detokenize{instruction_fetch:instruction-fetch}]{\sphinxcrossref{\DUrole{std,std-ref}{Instruction Fetch}}}} and {\hyperref[\detokenize{load_store_unit:load-store-unit}]{\sphinxcrossref{\DUrole{std,std-ref}{Load\sphinxhyphen{}Store\sphinxhyphen{}Unit (LSU)}}}} chapters of this document.


\section{Standards Compliance}
\label{\detokenize{intro:standards-compliance}}
\sphinxAtStartPar
CV32E40P is a standards\sphinxhyphen{}compliant 32\sphinxhyphen{}bit RISC\sphinxhyphen{}V processor.
It follows these specifications:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMAFDQC/riscv-spec-20191213.pdf}{RISC\sphinxhyphen{}V Instruction Set Manual, Volume I: User\sphinxhyphen{}Level ISA, Document Version 20191213 (December 13, 2019)}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMFDQC-and-Priv-v1.11/riscv-privileged-20190608.pdf}{RISC\sphinxhyphen{}V Instruction Set Manual, Volume II: Privileged Architecture, document version 20190608\sphinxhyphen{}Base\sphinxhyphen{}Ratified (June 8, 2019)}. CV32E40P implements the Machine ISA version 1.11.

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/riscv/riscv-debug-spec/raw/release/riscv-debug-release.pdf}{RISC\sphinxhyphen{}V External Debug Support, draft version 0.13.2}

\end{itemize}

\sphinxAtStartPar
Many features in the RISC\sphinxhyphen{}V specification are optional, and CV32E40P can be parameterized to enable or disable some of them.

\sphinxAtStartPar
CV32E40P supports the following base integer instruction set.
\begin{itemize}
\item {} 
\sphinxAtStartPar
The RV32I Base Integer Instruction Set, version 2.1

\end{itemize}

\sphinxAtStartPar
In addition, the following standard instruction set extensions are available.


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{CV32E40P Standard Instruction Set Extensions}\label{\detokenize{intro:id2}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{55}{100}\X{12}{100}\X{33}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Standard Extension}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Version}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Configurability}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxstylestrong{C}: Standard Extension for Compressed Instructions
&
\sphinxAtStartPar
2.0
&
\sphinxAtStartPar
always enabled
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{M}: Standard Extension for Integer Multiplication and Division
&
\sphinxAtStartPar
2.0
&
\sphinxAtStartPar
always enabled
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{Zicntr}: Performance Counters
&
\sphinxAtStartPar
2.0
&
\sphinxAtStartPar
always enabled
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{Zicsr}: Control and Status Register Instructions
&
\sphinxAtStartPar
2.0
&
\sphinxAtStartPar
always enabled
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{Zifencei}: Instruction\sphinxhyphen{}Fetch Fence
&
\sphinxAtStartPar
2.0
&
\sphinxAtStartPar
always enabled
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{F}: Single\sphinxhyphen{}Precision Floating\sphinxhyphen{}Point using F registers
&
\sphinxAtStartPar
2.2
&
\sphinxAtStartPar
optionally enabled with the \sphinxcode{\sphinxupquote{FPU}} parameter
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{Zfinx}: Single\sphinxhyphen{}Precision Floating\sphinxhyphen{}Point using X registers
&
\sphinxAtStartPar
1.0
&
\sphinxAtStartPar
optionally enabled with the \sphinxcode{\sphinxupquote{ZFINX}} parameter (also requires the \sphinxcode{\sphinxupquote{FPU}} parameter)
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
The following custom instruction set extensions are available.


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{CV32E40P Custom Instruction Set Extensions}\label{\detokenize{intro:id3}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{40}{100}\X{12}{100}\X{48}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Custom Extension}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Version}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Configurability}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxstylestrong{Xcv}: CORE\sphinxhyphen{}V PULP ISA Extensions
&
\sphinxAtStartPar
1.0
&
\sphinxAtStartPar
optionally enabled with the \sphinxcode{\sphinxupquote{COREV\_PULP}} parameter
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{Xcvelw}: CORE\sphinxhyphen{}V PULP Cluster ISA Extension
&
\sphinxAtStartPar
1.0
&
\sphinxAtStartPar
optionally enabled with the \sphinxcode{\sphinxupquote{COREV\_CLUSTER}} parameter
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Most content of the RISC\sphinxhyphen{}V privileged specification is optional.
CV32E40P currently supports the following features according to the RISC\sphinxhyphen{}V Privileged Specification, version 1.11.
\begin{itemize}
\item {} 
\sphinxAtStartPar
M\sphinxhyphen{}Mode

\item {} 
\sphinxAtStartPar
All CSRs listed in {\hyperref[\detokenize{control_status_registers:cs-registers}]{\sphinxcrossref{\DUrole{std,std-ref}{Control and Status Registers}}}}

\item {} 
\sphinxAtStartPar
Hardware Performance Counters as described in {\hyperref[\detokenize{perf_counters:performance-counters}]{\sphinxcrossref{\DUrole{std,std-ref}{Performance Counters}}}} controlled by the \sphinxcode{\sphinxupquote{NUM\_MHPMCOUNTERS}} parameter

\item {} 
\sphinxAtStartPar
Trap handling supporting direct mode or vectored mode as described at {\hyperref[\detokenize{exceptions_interrupts:exceptions-interrupts}]{\sphinxcrossref{\DUrole{std,std-ref}{Exceptions and Interrupts}}}}

\end{itemize}


\section{Contents}
\label{\detokenize{intro:contents}}\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{integration:core-integration}]{\sphinxcrossref{\DUrole{std,std-ref}{Core Integration}}}} provides the instantiation template and gives descriptions of the design parameters as well as the input and output ports. It gives synthesis guidelines as well, especially with respect to the Floating\sphinxhyphen{}Point Unit.

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{fpu:fpu}]{\sphinxcrossref{\DUrole{std,std-ref}{Floating Point Unit (FPU)}}}} describes the Floating Point Unit (FPU).

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{verification:verification}]{\sphinxcrossref{\DUrole{std,std-ref}{Verification}}}} gives a brief overview of the verification methodology.

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{corev_hw_loop:hwloop-specs}]{\sphinxcrossref{\DUrole{std,std-ref}{CORE\sphinxhyphen{}V Hardware Loop feature}}}} describes the PULP Hardware Loop extension.

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{instruction_set_extensions:custom-isa-extensions}]{\sphinxcrossref{\DUrole{std,std-ref}{CORE\sphinxhyphen{}V Instruction Set Custom Extensions}}}} describes the custom instruction set extensions.

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{perf_counters:performance-counters}]{\sphinxcrossref{\DUrole{std,std-ref}{Performance Counters}}}} gives an overview of the performance monitors and event counters available in CV32E40P.

\item {} 
\sphinxAtStartPar
The control and status registers are explained in {\hyperref[\detokenize{control_status_registers:cs-registers}]{\sphinxcrossref{\DUrole{std,std-ref}{Control and Status Registers}}}}.

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{exceptions_interrupts:exceptions-interrupts}]{\sphinxcrossref{\DUrole{std,std-ref}{Exceptions and Interrupts}}}} deals with the infrastructure for handling exceptions and interrupts.

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{debug:debug-support}]{\sphinxcrossref{\DUrole{std,std-ref}{Debug \& Trigger}}}} gives a brief overview on the debug infrastructure.

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{pipeline:pipeline-details}]{\sphinxcrossref{\DUrole{std,std-ref}{Pipeline Details}}}} described the overal pipeline structure.

\item {} 
\sphinxAtStartPar
The instruction and data interfaces of CV32E40P are explained in {\hyperref[\detokenize{instruction_fetch:instruction-fetch}]{\sphinxcrossref{\DUrole{std,std-ref}{Instruction Fetch}}}} and {\hyperref[\detokenize{load_store_unit:load-store-unit}]{\sphinxcrossref{\DUrole{std,std-ref}{Load\sphinxhyphen{}Store\sphinxhyphen{}Unit (LSU)}}}}, respectively.

\item {} 
\sphinxAtStartPar
The register\sphinxhyphen{}file is described in {\hyperref[\detokenize{register_file:register-file}]{\sphinxcrossref{\DUrole{std,std-ref}{Register File}}}}.

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{sleep:sleep-unit}]{\sphinxcrossref{\DUrole{std,std-ref}{Sleep Unit}}}} describes the Sleep unit including the PULP Cluster extension.

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{core_versions:core-versions}]{\sphinxcrossref{\DUrole{std,std-ref}{Core Versions and RTL Freeze Rules}}}} describes the core versioning.

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{glossary:glossary}]{\sphinxcrossref{\DUrole{std,std-ref}{Glossary}}}} provides definitions of used terminology.

\end{itemize}


\section{History}
\label{\detokenize{intro:history}}
\sphinxAtStartPar
CV32E40P started its life as a fork of the OR10N CPU core based on the OpenRISC ISA. Then, under the name of RI5CY, it became a RISC\sphinxhyphen{}V core (2016),
and it has been maintained by the PULP platform \textless{}\sphinxurl{https://pulp-platform.org}\textgreater{} team until February 2020, when it has been contributed to OpenHW Group \sphinxurl{https://www.openhwgroup.org}.

\sphinxAtStartPar
As RI5CY has been used in several projects, a list of all the changes made by OpenHW Group since February 2020 follows:


\subsection{Memory\sphinxhyphen{}Protocol}
\label{\detokenize{intro:memory-protocol}}
\sphinxAtStartPar
The Instruction and Data memory interfaces are now compliant with the OBI protocol (see \sphinxhref{https://raw.githubusercontent.com/openhwgroup/obi/188c87089975a59c56338949f5c187c1f8841332/OBI-v1.2.pdf}{OBI\sphinxhyphen{}v1.2.pdf}).
Such memory interface is slightly different from the one used by RI5CY as: the grant signal can now be kept high by the bus even without the core raising a request; and the request signal does not depend anymore on the rvalid signal (no combinatorial dependency). The OBI is easier to be interfaced to the AMBA AXI and AHB protocols and improves timing as it removes rvalid\sphinxhyphen{}\textgreater{}req dependency. Also, the protocol forces the address stability. Thus, the core can not retract memory requests once issued, nor can it change the issued address (as was the case for the RI5CY instruction memory interface).


\subsection{RV32F Extensions}
\label{\detokenize{intro:rv32f-extensions}}
\sphinxAtStartPar
Previously, RI5CY could select with a parameter whether the FPU was instantiated inside the EX stage or via the APU interface. Now in CV32E40P, the FPU is not instantiated in the core EX stage anymore.
A new file called cv32e40p\_top.sv is instantiating the core together with the FPU and APU interface is not visible on I/Os.
This is this new top level which has been used for Verification and Implementation.


\subsection{RV32A Extensions, Security and Memory Protection}
\label{\detokenize{intro:rv32a-extensions-security-and-memory-protection}}
\sphinxAtStartPar
CV32E40P core does not support the RV32A (atomic) extensions, the U\sphinxhyphen{}mode, and the PMP anymore.
Most of the previous RTL descriptions of these features have been kept but not maintained. The RTL code has been partially kept to allow previous users of these features to develop their own by reusing previously developed RI5CY modules.


\subsection{CSR Address Re\sphinxhyphen{}Mapping}
\label{\detokenize{intro:csr-address-re-mapping}}
\sphinxAtStartPar
RI5CY used to have custom performance counters 32b wide (not compliant with RISC\sphinxhyphen{}V) in the CSR address space \{0x7A0, 0x7A1, 0x780\sphinxhyphen{}0x79F\}.
CV32E40P is now fully compliant with the RISC\sphinxhyphen{}V spec on performance counters side.
And the custom PULP HWLoop CSRs have been moved from the 0x7C* to RISC\sphinxhyphen{}V user custom read\sphinxhyphen{}only 0xCC0\sphinxhyphen{}0xCFF address space.


\subsection{Interrupts}
\label{\detokenize{intro:interrupts}}
\sphinxAtStartPar
RI5CY used to have a req plus a 5 bits ID interrupt interface, supporting up to 32 interrupt requests (only one active at a time), with the priority defined outside in an interrupt controller. CV32E40P is now compliant with the CLINT RISC\sphinxhyphen{}V spec, extended with 16 custom interrupts lines called fast, for a total of 19 interrupt lines. They can be all active simultaneously, and priority and per\sphinxhyphen{}request interrupt enable bit is controlled by the core CLINT definition.


\subsection{PULP HWLoop Spec}
\label{\detokenize{intro:pulp-hwloop-spec}}
\sphinxAtStartPar
RI5CY supported two nested HWLoops. Every loop had a minimum of two instructions. The start and end of the loop addresses
could be misaligned, and the instructions in the loop body could be of any kind. CV32E40P has a more restricted constraints for the HWLoop (see  {\hyperref[\detokenize{corev_hw_loop:hwloop-specs}]{\sphinxcrossref{\DUrole{std,std-ref}{CORE\sphinxhyphen{}V Hardware Loop feature}}}}).


\subsection{Compliancy, bug fixing, code clean\sphinxhyphen{}up, and documentation}
\label{\detokenize{intro:compliancy-bug-fixing-code-clean-up-and-documentation}}
\sphinxAtStartPar
The CV32E40P has been verified. It is fully compliant with RISC\sphinxhyphen{}V (RI5CY was partially compliant). Many bugs have been fixed, and the RTL code cleaned\sphinxhyphen{}up. The documentation has been formatted with reStructuredText and has been developed following at industrial quality level.


\section{References}
\label{\detokenize{intro:references}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxhref{https://ieeexplore.ieee.org/document/7864441}{Gautschi, Michael, et al. “Near\sphinxhyphen{}Threshold RISC\sphinxhyphen{}V Core With DSP Extensions for Scalable IoT Endpoint Devices.” in IEEE Transactions on Very Large Scale Integration (VLSI) Systems, vol. 25, no. 10, pp. 2700\sphinxhyphen{}2713, Oct. 2017}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://doi.org/10.1109/PATMOS.2017.8106976}{Schiavone, Pasquale Davide, et al. “Slow and steady wins the race? A comparison of ultra\sphinxhyphen{}low\sphinxhyphen{}power RISC\sphinxhyphen{}V cores for Internet\sphinxhyphen{}of\sphinxhyphen{}Things applications.” 27th International Symposium on Power and Timing Modeling, Optimization and Simulation (PATMOS 2017)}

\end{enumerate}


\section{Contributors}
\label{\detokenize{intro:contributors}}
\begin{DUlineblock}{0em}
\item[] Andreas Traber (\sphinxhref{mailto:atraber@iis.ee.ethz.ch}{atraber@iis.ee.ethz.ch})
\item[] Michael Gautschi (\sphinxhref{mailto:gautschi@iis.ee.ethz.ch}{gautschi@iis.ee.ethz.ch})
\item[] Pasquale Davide Schiavone (\sphinxhref{mailto:pschiavo@iis.ee.ethz.ch}{pschiavo@iis.ee.ethz.ch})
\end{DUlineblock}

\begin{DUlineblock}{0em}
\item[] Arjan Bink (\sphinxhref{mailto:arjan.bink@silabs.com}{arjan.bink@silabs.com})
\item[] Paul Zavalney (\sphinxhref{mailto:paul.zavalney@silabs.com}{paul.zavalney@silabs.com})
\end{DUlineblock}

\begin{DUlineblock}{0em}
\item[] Pascal Gouédo (\sphinxhref{mailto:pascal.gouedo@dolphin.fr}{pascal.gouedo@dolphin.fr})
\end{DUlineblock}

\begin{DUlineblock}{0em}
\item[] Micrel Lab and Multitherman Lab
\item[] University of Bologna, Italy
\end{DUlineblock}

\begin{DUlineblock}{0em}
\item[] Integrated Systems Lab
\item[] ETH Zürich, Switzerland
\end{DUlineblock}

\sphinxstepscope


\chapter{Core Integration}
\label{\detokenize{integration:core-integration}}\label{\detokenize{integration:id1}}\label{\detokenize{integration::doc}}
\sphinxAtStartPar
The main module is named \sphinxcode{\sphinxupquote{cv32e40p\_top}} and can be found in \sphinxcode{\sphinxupquote{cv32e40p\_top.sv}}.
Below, the instantiation template is given and the parameters and interfaces are described.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cv32e40p\_top}} instantiates former \sphinxcode{\sphinxupquote{cv32e40p\_core}} and a wrapped \sphinxcode{\sphinxupquote{fpnew\_top}}.
It is highly suggested to use \sphinxcode{\sphinxupquote{cv32e40p\_top}} in place of \sphinxcode{\sphinxupquote{cv32e40p\_core}} as
it allows to easily enable/disable FPU parameter with no interface change.
As mentioned in {\hyperref[\detokenize{core_versions:backward-compatibility}]{\sphinxcrossref{\DUrole{std,std-ref}{Non\sphinxhyphen{}backward compatibility}}}}, v2.0.0 \sphinxcode{\sphinxupquote{cv32e40p\_core}} has \sphinxstylestrong{slight}
modifications that makes it not backward compatible with v1.0.0 one in some cases.
It is worth mentioning that if the core in its v1 version was/is instantiated without parameters setting,
there is still backward compatibility as all parameters default value are set to v1 values.
\end{sphinxadmonition}


\section{Instantiation Template}
\label{\detokenize{integration:instantiation-template}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cv32e40p\PYGZus{}top}\PYG{+w}{ }\PYG{p}{\PYGZsh{}}\PYG{p}{(}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{FPU}\PYG{+w}{                      }\PYG{p}{(}\PYG{+w}{ }\PYG{l+m+mh}{0}\PYG{+w}{ }\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{FPU\PYGZus{}ADDMUL\PYGZus{}LAT}\PYG{+w}{           }\PYG{p}{(}\PYG{+w}{ }\PYG{l+m+mh}{0}\PYG{+w}{ }\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{FPU\PYGZus{}OTHERS\PYGZus{}LAT}\PYG{+w}{           }\PYG{p}{(}\PYG{+w}{ }\PYG{l+m+mh}{0}\PYG{+w}{ }\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{ZFINX}\PYG{+w}{                    }\PYG{p}{(}\PYG{+w}{ }\PYG{l+m+mh}{0}\PYG{+w}{ }\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{COREV\PYGZus{}PULP}\PYG{+w}{               }\PYG{p}{(}\PYG{+w}{ }\PYG{l+m+mh}{0}\PYG{+w}{ }\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{COREV\PYGZus{}CLUSTER}\PYG{+w}{            }\PYG{p}{(}\PYG{+w}{ }\PYG{l+m+mh}{0}\PYG{+w}{ }\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{NUM\PYGZus{}MHPMCOUNTERS}\PYG{+w}{         }\PYG{p}{(}\PYG{+w}{ }\PYG{l+m+mh}{1}\PYG{+w}{ }\PYG{p}{)}
\PYG{p}{)}\PYG{+w}{ }\PYG{n}{u\PYGZus{}core}\PYG{+w}{ }\PYG{p}{(}
\PYG{+w}{    }\PYG{c+c1}{// Clock and reset}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{rst\PYGZus{}ni}\PYG{+w}{                   }\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{clk\PYGZus{}i}\PYG{+w}{                    }\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{scan\PYGZus{}cg\PYGZus{}en\PYGZus{}i}\PYG{+w}{             }\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}

\PYG{+w}{    }\PYG{c+c1}{// Special control signals}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{fetch\PYGZus{}enable\PYGZus{}i}\PYG{+w}{           }\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{pulp\PYGZus{}clock\PYGZus{}en\PYGZus{}i}\PYG{+w}{          }\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{core\PYGZus{}sleep\PYGZus{}o}\PYG{+w}{             }\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}

\PYG{+w}{    }\PYG{c+c1}{// Configuration}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{boot\PYGZus{}addr\PYGZus{}i}\PYG{+w}{              }\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{mtvec\PYGZus{}addr\PYGZus{}i}\PYG{+w}{             }\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{dm\PYGZus{}halt\PYGZus{}addr\PYGZus{}i}\PYG{+w}{           }\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{dm\PYGZus{}exception\PYGZus{}addr\PYGZus{}i}\PYG{+w}{      }\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{hart\PYGZus{}id\PYGZus{}i}\PYG{+w}{                }\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}

\PYG{+w}{    }\PYG{c+c1}{// Instruction memory interface}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{instr\PYGZus{}addr\PYGZus{}o}\PYG{+w}{             }\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{instr\PYGZus{}req\PYGZus{}o}\PYG{+w}{              }\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{instr\PYGZus{}gnt\PYGZus{}i}\PYG{+w}{              }\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{instr\PYGZus{}rvalid\PYGZus{}i}\PYG{+w}{           }\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{instr\PYGZus{}rdata\PYGZus{}i}\PYG{+w}{            }\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}

\PYG{+w}{    }\PYG{c+c1}{// Data memory interface}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{data\PYGZus{}addr\PYGZus{}o}\PYG{+w}{              }\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{data\PYGZus{}req\PYGZus{}o}\PYG{+w}{               }\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{data\PYGZus{}gnt\PYGZus{}i}\PYG{+w}{               }\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{data\PYGZus{}we\PYGZus{}o}\PYG{+w}{                }\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{data\PYGZus{}be\PYGZus{}o}\PYG{+w}{                }\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{data\PYGZus{}wdata\PYGZus{}o}\PYG{+w}{             }\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{data\PYGZus{}rvalid\PYGZus{}i}\PYG{+w}{            }\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{data\PYGZus{}rdata\PYGZus{}i}\PYG{+w}{             }\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}

\PYG{+w}{     }\PYG{c+c1}{// Interrupt interface}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{irq\PYGZus{}i}\PYG{+w}{                    }\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{irq\PYGZus{}ack\PYGZus{}o}\PYG{+w}{                }\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{irq\PYGZus{}id\PYGZus{}o}\PYG{+w}{                 }\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}

\PYG{+w}{    }\PYG{c+c1}{// Debug interface}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{debug\PYGZus{}req\PYGZus{}i}\PYG{+w}{              }\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{debug\PYGZus{}havereset\PYGZus{}o}\PYG{+w}{        }\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{debug\PYGZus{}running\PYGZus{}o}\PYG{+w}{          }\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{debug\PYGZus{}halted\PYGZus{}o}\PYG{+w}{           }\PYG{p}{(}\PYG{p}{)}
\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Parameters}
\label{\detokenize{integration:parameters}}

\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Parameters}\label{\detokenize{integration:id2}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{25}{100}\X{15}{100}\X{11}{100}\X{49}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Type/Range}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FPU}}
&
\sphinxAtStartPar
bit
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
Enable Floating Point Unit (FPU) support, see {\hyperref[\detokenize{fpu:fpu}]{\sphinxcrossref{\DUrole{std,std-ref}{Floating Point Unit (FPU)}}}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FPU\_ADDMUL\_LAT}}
&
\sphinxAtStartPar
int
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
Number of pipeline registers for Floating\sphinxhyphen{}Point
addition and multiplication instructions, see {\hyperref[\detokenize{fpu:fpu}]{\sphinxcrossref{\DUrole{std,std-ref}{Floating Point Unit (FPU)}}}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FPU\_OTHERS\_LAT}}
&
\sphinxAtStartPar
int
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
Number of pipeline registers for Floating\sphinxhyphen{}Point
comparison, conversion and classify instructions, see {\hyperref[\detokenize{fpu:fpu}]{\sphinxcrossref{\DUrole{std,std-ref}{Floating Point Unit (FPU)}}}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ZFINX}}
&
\sphinxAtStartPar
bit
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
Enable Floating Point instructions to use the General Purpose
register file instead of requiring a dedicated Floating Point
register file, see {\hyperref[\detokenize{fpu:fpu}]{\sphinxcrossref{\DUrole{std,std-ref}{Floating Point Unit (FPU)}}}}. Only allowed to be set to 1
if \sphinxcode{\sphinxupquote{FPU}} = 1
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{COREV\_PULP}}
&
\sphinxAtStartPar
bit
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
Enable all of the custom PULP ISA extensions (except \sphinxstylestrong{cv.elw})
(see {\hyperref[\detokenize{instruction_set_extensions:custom-isa-extensions}]{\sphinxcrossref{\DUrole{std,std-ref}{CORE\sphinxhyphen{}V Instruction Set Custom Extensions}}}}) and all custom CSRs
(see {\hyperref[\detokenize{control_status_registers:cs-registers}]{\sphinxcrossref{\DUrole{std,std-ref}{Control and Status Registers}}}}).

\sphinxAtStartPar
Examples of PULP ISA
extensions are post\sphinxhyphen{}incrementing load and stores
(see {\hyperref[\detokenize{instruction_set_extensions:corev-load-store}]{\sphinxcrossref{\DUrole{std,std-ref}{Post\sphinxhyphen{}Increment Load \& Store Instructions and Register\sphinxhyphen{}Register Load \& Store Instructions}}}}) and hardware loops
(see {\hyperref[\detokenize{instruction_set_extensions:corev-hardware-loop}]{\sphinxcrossref{\DUrole{std,std-ref}{Hardware Loops}}}}).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{COREV\_CLUSTER}}
&
\sphinxAtStartPar
bit
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
Enable PULP Cluster support (\sphinxstylestrong{cv.elw}), see {\hyperref[\detokenize{sleep:pulp-cluster}]{\sphinxcrossref{\DUrole{std,std-ref}{PULP Cluster Extension}}}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{NUM\_MHPMCOUNTERS}}
&
\sphinxAtStartPar
int (0..29)
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
Number of MHPMCOUNTER performance counters, see
{\hyperref[\detokenize{perf_counters:performance-counters}]{\sphinxcrossref{\DUrole{std,std-ref}{Performance Counters}}}}
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\section{Interfaces}
\label{\detokenize{integration:interfaces}}

\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Interfaces}\label{\detokenize{integration:id3}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{25}{100}\X{10}{100}\X{7}{100}\X{58}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Signal}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Width}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Dir}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rst\_ni}}
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
in
&
\sphinxAtStartPar
Active\sphinxhyphen{}low asynchronous reset
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{clk\_i}}
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
in
&
\sphinxAtStartPar
Clock signal
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{scan\_cg\_en\_i}}
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
in
&
\sphinxAtStartPar
Scan clock gate enable. Design for test
(DfT) related signal. Can be used during
scan testing operation to force
instantiated clock gate(s) to be enabled.
This signal should be 0 during normal /
functional operation.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fetch\_enable\_i}}
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
in
&
\sphinxAtStartPar
Enable the instruction fetch of CV32E40P.
The first instruction fetch after reset
de\sphinxhyphen{}assertion will not happen as long as
this signal is 0. \sphinxcode{\sphinxupquote{fetch\_enable\_i}} needs
to be set to 1 for at least one cycle
while not in reset to enable fetching.
Once fetching has been enabled the value
\sphinxcode{\sphinxupquote{fetch\_enable\_i}} is ignored.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{core\_sleep\_o}}
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
out
&
\sphinxAtStartPar
Core is sleeping, see {\hyperref[\detokenize{sleep:sleep-unit}]{\sphinxcrossref{\DUrole{std,std-ref}{Sleep Unit}}}}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pulp\_clock\_en\_i}}
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
in
&
\sphinxAtStartPar
PULP clock enable (only used when
\sphinxcode{\sphinxupquote{COREV\_CLUSTER}} = 1, tie to 0 otherwise),
see {\hyperref[\detokenize{sleep:sleep-unit}]{\sphinxcrossref{\DUrole{std,std-ref}{Sleep Unit}}}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{boot\_addr\_i}}
&
\sphinxAtStartPar
32
&
\sphinxAtStartPar
in
&
\sphinxAtStartPar
Boot address. First program counter after
reset = \sphinxcode{\sphinxupquote{boot\_addr\_i}}. Must be half\sphinxhyphen{}word
aligned. Do not change after enabling core
via \sphinxcode{\sphinxupquote{fetch\_enable\_i}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mtvec\_addr\_i}}
&
\sphinxAtStartPar
32
&
\sphinxAtStartPar
in
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mtvec}} address. Initial value for the
address part of {\hyperref[\detokenize{control_status_registers:csr-mtvec}]{\sphinxcrossref{\DUrole{std,std-ref}{Machine Trap\sphinxhyphen{}Vector Base Address (mtvec)}}}}.
Do not change after enabling core
via \sphinxcode{\sphinxupquote{fetch\_enable\_i}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dm\_halt\_addr\_i}}
&
\sphinxAtStartPar
32
&
\sphinxAtStartPar
in
&
\sphinxAtStartPar
Address to jump to when entering Debug
Mode, see {\hyperref[\detokenize{debug:debug-support}]{\sphinxcrossref{\DUrole{std,std-ref}{Debug \& Trigger}}}}. Must be
word\sphinxhyphen{}aligned. Do not change after enabling
core via \sphinxcode{\sphinxupquote{fetch\_enable\_i}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dm\_exception\_addr\_i}}
&
\sphinxAtStartPar
32
&
\sphinxAtStartPar
in
&
\sphinxAtStartPar
Address to jump to when an exception
occurs when executing code during Debug
Mode, see {\hyperref[\detokenize{debug:debug-support}]{\sphinxcrossref{\DUrole{std,std-ref}{Debug \& Trigger}}}}. Must be
word\sphinxhyphen{}aligned. Do not change after enabling
core via \sphinxcode{\sphinxupquote{fetch\_enable\_i}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hart\_id\_i}}
&
\sphinxAtStartPar
32
&
\sphinxAtStartPar
in
&
\sphinxAtStartPar
Hart ID, usually static, can be read from
{\hyperref[\detokenize{control_status_registers:csr-mhartid}]{\sphinxcrossref{\DUrole{std,std-ref}{Hardware Thread ID (mhartid)}}}} and {\hyperref[\detokenize{control_status_registers:csr-uhartid}]{\sphinxcrossref{\DUrole{std,std-ref}{User Hardware Thread ID (uhartid)}}}}
CSRs
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{instr\_*}}
&\sphinxstartmulticolumn{3}%
\begin{varwidth}[t]{\sphinxcolwidth{3}{4}}
\sphinxAtStartPar
Instruction fetch interface, see {\hyperref[\detokenize{instruction_fetch:instruction-fetch}]{\sphinxcrossref{\DUrole{std,std-ref}{Instruction Fetch}}}}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{data\_*}}
&\sphinxstartmulticolumn{3}%
\begin{varwidth}[t]{\sphinxcolwidth{3}{4}}
\sphinxAtStartPar
Load\sphinxhyphen{}store unit interface, see {\hyperref[\detokenize{load_store_unit:load-store-unit}]{\sphinxcrossref{\DUrole{std,std-ref}{Load\sphinxhyphen{}Store\sphinxhyphen{}Unit (LSU)}}}}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{irq\_*}}
&\sphinxstartmulticolumn{3}%
\begin{varwidth}[t]{\sphinxcolwidth{3}{4}}
\sphinxAtStartPar
Interrupt inputs, see {\hyperref[\detokenize{exceptions_interrupts:exceptions-interrupts}]{\sphinxcrossref{\DUrole{std,std-ref}{Exceptions and Interrupts}}}}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{debug\_*}}
&\sphinxstartmulticolumn{3}%
\begin{varwidth}[t]{\sphinxcolwidth{3}{4}}
\sphinxAtStartPar
Debug interface, see {\hyperref[\detokenize{debug:debug-support}]{\sphinxcrossref{\DUrole{std,std-ref}{Debug \& Trigger}}}}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\section{Clock Gating Cell}
\label{\detokenize{integration:clock-gating-cell}}\label{\detokenize{integration:id4}}
\sphinxAtStartPar
CV32E40P requires clock gating cells.
These cells are usually specific to the selected target technology and thus not provided as part of the RTL design.
A simulation\sphinxhyphen{}only version of the clock gating cell is provided in \sphinxcode{\sphinxupquote{cv32e40p\_sim\_clock\_gate.sv}}. This file contains
a module called \sphinxcode{\sphinxupquote{cv32e40p\_clock\_gate}} that has the following ports:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{clk\_i}}: Clock Input

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{en\_i}}: Clock Enable Input

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{scan\_cg\_en\_i}}: Scan Clock Gate Enable Input (activates the clock even though \sphinxcode{\sphinxupquote{en\_i}} is not set)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{clk\_o}}: Gated Clock Output

\end{itemize}

\sphinxAtStartPar
Inside CV32E40P, clock gating cells are used in both \sphinxcode{\sphinxupquote{cv32e40p\_sleep\_unit.sv}} and \sphinxcode{\sphinxupquote{cv32e40p\_top.sv}}.

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{cv32e40p\_sim\_clock\_gate.sv}} file is not intended for synthesis. For ASIC synthesis and FPGA synthesis the manifest
should be adapted to use a customer specific file that implements the \sphinxcode{\sphinxupquote{cv32e40p\_clock\_gate}} module using design primitives
that are appropriate for the intended synthesis target technology.


\section{Synthesis guidelines}
\label{\detokenize{integration:synthesis-guidelines}}\label{\detokenize{integration:id5}}
\sphinxAtStartPar
The CV32E40P core is fully synthesizable.
It has been designed mainly for ASIC designs, but FPGA synthesis is supported as well.

\sphinxAtStartPar
The top level module is called cv32e40p\_top and includes both the core and the FPU.
All the core files are in \sphinxcode{\sphinxupquote{rtl}} and \sphinxcode{\sphinxupquote{rtl/include}} folders (all synthesizable)
while all the FPU files are in \sphinxcode{\sphinxupquote{rtl/vendor/pulp\_platform\_common\_cells}}, \sphinxcode{\sphinxupquote{rtl/vendor/pulp\_platform\_fpnew}} and \sphinxcode{\sphinxupquote{rtl/vendor/pulp\_platform\_fpu\_div\_sqrt}}.
.. while all the FPU files are in \sphinxcode{\sphinxupquote{rtl/vendor/pulp\_platform\_common\_cells}}, \sphinxcode{\sphinxupquote{rtl/vendor/pulp\_platform\_fpnew}} and \sphinxcode{\sphinxupquote{rtl/vendor/opene906}}.
cv32e40p\_fpu\_manifest.flist is listing all the required files.

\sphinxAtStartPar
The user must provide a clock\sphinxhyphen{}gating module that instantiates the functionally equivalent clock\sphinxhyphen{}gating cell of the target technology.
This file must have the same interface and module name as the one provided for simulation\sphinxhyphen{}only purposes at \sphinxcode{\sphinxupquote{bhv/cv32e40p\_sim\_clock\_gate.sv}} (see {\hyperref[\detokenize{integration:clock-gating-cell}]{\sphinxcrossref{\DUrole{std,std-ref}{Clock Gating Cell}}}}).

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{constraints/cv32e40p\_core.sdc}} file provides an example of synthesis constraints.


\subsection{ASIC Synthesis}
\label{\detokenize{integration:asic-synthesis}}
\sphinxAtStartPar
ASIC synthesis is supported for CV32E40P. The whole design is completely
synchronous and uses positive\sphinxhyphen{}edge triggered flip\sphinxhyphen{}flops. The
core occupies an area of about XX kGE.
With the FPU, the area increases to about XX kGE (XX kGE
FPU, XX kGE additional register file). A technology specific implementation
of a clock gating cell as described in {\hyperref[\detokenize{integration:clock-gating-cell}]{\sphinxcrossref{\DUrole{std,std-ref}{Clock Gating Cell}}}} needs to
be provided.


\subsection{FPGA Synthesis}
\label{\detokenize{integration:fpga-synthesis}}
\sphinxAtStartPar
FPGA synthesis is only supported for CV32E40P.
The user needs to provide a technology specific implementation of a clock gating cell as described
in {\hyperref[\detokenize{integration:clock-gating-cell}]{\sphinxcrossref{\DUrole{std,std-ref}{Clock Gating Cell}}}}.


\subsection{Synthesizing with the FPU}
\label{\detokenize{integration:synthesizing-with-the-fpu}}\label{\detokenize{integration:synthesis-with-fpu}}
\sphinxAtStartPar
By default the pipeline of the FPU is purely combinatorial (FPU\_*\_LAT = 0). In this case FPU instructions latency is the same than simple ALU operations (except FP multicycle DIV/SQRT ones).
But as FPU operations are much more complex than ALU ones, maximum achievable frequency is much lower than ALU one when FPU is enabled.
If this can be fine for low frequency systems, it is possible to indicate how many pipeline registers are instantiated in the FPU to reach higher target frequency.
This is done with FPU\_*\_LAT CV32E40P parameters setting to perfectly fit target frequency.
It should be noted that any additional pipeline register is impacting FPU instructions latency and could cause performances degradation depending of applications using Floating\sphinxhyphen{}Point operations.
Those pipeline registers are all added at the end of the FPU pipeline with all operators before them. Optimal frequency is only achievable using automatic retiming commands in implementation tools.
This can be achieved with the following command for Synopsys Design Compiler:
“set\_optimize\_registers true \sphinxhyphen{}designs {[}get\_object\_name {[}get\_designs “*cv32e40p\_fp\_wrapper*”{]}{]}”.

\sphinxstepscope


\chapter{Floating Point Unit (FPU)}
\label{\detokenize{fpu:floating-point-unit-fpu}}\label{\detokenize{fpu:fpu}}\label{\detokenize{fpu::doc}}
\sphinxAtStartPar
The RV32F ISA extension for floating\sphinxhyphen{}point support in the form of IEEE\sphinxhyphen{}754 single
precision can be enabled by setting the parameter \sphinxstylestrong{FPU} of the \sphinxcode{\sphinxupquote{cv32e40p\_top}} top level module
to 1. This will extend the CV32E40P decoder accordingly and will instantiate the FPU.
The FPU repository used by the CV32E40P is available at \sphinxhref{https://github.com/openhwgroup/cvfpu/tree/3116391bf66660f806b45e212b9949c528b4e270}{https://github.com/openhwgroup/cvfpu} and
its documentation can be found \sphinxhref{https://github.com/openhwgroup/cvfpu/blob/3116391bf66660f806b45e212b9949c528b4e270/docs/README.md}{here}.
CVFPU v0.8.1 release has been copied in CV32E40P repository inside rtl/vendor (used for verification and implementation) so all core and FPU RTL files should be taken from CV32E40P repository.

\sphinxAtStartPar
cv32e40p\_fpu\_manifest file is listing all necessary files for both the Core and CVFPU.


\section{CVFPU parameters}
\label{\detokenize{fpu:cvfpu-parameters}}
\sphinxAtStartPar
As CVFPU is an highly configurable IP, here is the list of its parameters and their actual value used when CVFPU is intantiated through a wrapper in \sphinxcode{\sphinxupquote{cv32e40p\_top}} module.


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{CVFPU Features parameter}\label{\detokenize{fpu:cvfpu-features-parameter}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{17}{100}\X{15}{100}\X{17}{100}\X{51}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Type/Range}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Value}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Width}}
&
\sphinxAtStartPar
int
&
\sphinxAtStartPar
32
&
\sphinxAtStartPar
\sphinxstylestrong{Datapath Width}

\sphinxAtStartPar
Specifies the width of the input and output data ports and
of the datapath.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{EnableVectors}}
&
\sphinxAtStartPar
logic
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
\sphinxstylestrong{Vectorial Hardware Generation}

\sphinxAtStartPar
Controls the generation of packed\sphinxhyphen{}SIMD computation units.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{EnableNanBox}}
&
\sphinxAtStartPar
logic
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
\sphinxstylestrong{NaN\sphinxhyphen{}Boxing Check Control}

\sphinxAtStartPar
Controls whether input value NaN\sphinxhyphen{}boxing is enforced.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FpFmtMask}}
&
\sphinxAtStartPar
fmt\_logic\_t
&
\sphinxAtStartPar
\{1, 0, 0, 0, 0\}
&
\sphinxAtStartPar
\sphinxstylestrong{Enabled Floating\sphinxhyphen{}Point Formats}

\sphinxAtStartPar
Enables respectively:

\sphinxAtStartPar
IEEE Single\sphinxhyphen{}Precision format

\sphinxAtStartPar
IEEE Double\sphinxhyphen{}Precision format

\sphinxAtStartPar
IEEE Half\sphinxhyphen{}Precision format

\sphinxAtStartPar
Custom Byte\sphinxhyphen{}Precision format

\sphinxAtStartPar
Custom Alternate Half\sphinxhyphen{}Precision format
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{IntFmtMask}}
&
\sphinxAtStartPar
ifmt\_logic\_t
&
\sphinxAtStartPar
\{0, 0, 1, 0\}
&
\sphinxAtStartPar
\sphinxstylestrong{Enabled Integer Formats}

\sphinxAtStartPar
Enables respectively:

\sphinxAtStartPar
Byte format

\sphinxAtStartPar
Half\sphinxhyphen{}Word format

\sphinxAtStartPar
Word format

\sphinxAtStartPar
Double\sphinxhyphen{}Word format
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{CVFPU Implementation parameter}\label{\detokenize{fpu:cvfpu-implementation-parameter}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{13}{100}\X{21}{100}\X{30}{100}\X{36}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Type/Range}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Value}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PipeRegs}}
&
\sphinxAtStartPar
opgrp\_fmt\_unsigned\_t
&
\sphinxAtStartPar
\{

\sphinxAtStartPar
\{\sphinxcode{\sphinxupquote{FPU\_ADDMUL\_LAT}}, 0, 0, 0, 0\},

\sphinxAtStartPar
\{default: 1\},

\sphinxAtStartPar
\{default: \sphinxcode{\sphinxupquote{FPU\_OTHERS\_LAT}}\},

\sphinxAtStartPar
\{default: \sphinxcode{\sphinxupquote{FPU\_OTHERS\_LAT}}\}

\sphinxAtStartPar
\}
&
\sphinxAtStartPar
\sphinxstylestrong{Number of Pipelining Stages}

\sphinxAtStartPar
This parameter sets a number of pipeline stages to be inserted into the
computational units per operation group, per FP format. As such,
latencies for different operations and different formats can be freely
configured.

\sphinxAtStartPar
Respectively:

\sphinxAtStartPar
ADDition/MULtiplication operation group

\sphinxAtStartPar
DIVision/SQuare RooT operation group

\sphinxAtStartPar
NON COMPuting operation group

\sphinxAtStartPar
CONVersion operation group

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FPU\_ADDMUL\_LAT}} and \sphinxcode{\sphinxupquote{FPU\_OTHERS\_LAT}} are \sphinxcode{\sphinxupquote{cv32e40p\_top}} parameters.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{UnitTypes}}
&
\sphinxAtStartPar
opgrp\_fmt\_unit\_types\_t
&
\sphinxAtStartPar
\{

\sphinxAtStartPar
\{default: MERGED\},

\sphinxAtStartPar
\{default: MERGED\},

\sphinxAtStartPar
\{default: PARALLEL\},

\sphinxAtStartPar
\{default: MERGED\}

\sphinxAtStartPar
\}
&
\sphinxAtStartPar
\sphinxstylestrong{HW Unit Implementation}

\sphinxAtStartPar
This parameter allows to control resources by either removing operation
units for certain formats and operations,
or merging multiple formats into one.

\sphinxAtStartPar
Respectively:

\sphinxAtStartPar
ADDition/MULtiplication operation group

\sphinxAtStartPar
DIVision/SQuare RooT operation group

\sphinxAtStartPar
NON COMPuting operation group

\sphinxAtStartPar
CONVersion operation group
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PipeConfig}}
&
\sphinxAtStartPar
pipe\_config\_t
&
\sphinxAtStartPar
AFTER
&
\sphinxAtStartPar
\sphinxstylestrong{Pipeline Register Placement}

\sphinxAtStartPar
This parameter controls where pipeling registers (number defined by
\sphinxcode{\sphinxupquote{PipeRegs}}) are placed in each operational unit.

\sphinxAtStartPar
AFTER means they are all placed at the output of each operational unit.

\sphinxAtStartPar
See {\hyperref[\detokenize{integration:synthesis-with-fpu}]{\sphinxcrossref{\DUrole{std,std-ref}{Synthesizing with the FPU}}}} advices to get best synthesis results.
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Other CVFPU parameters}\label{\detokenize{fpu:other-cvfpu-parameters}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{20}{100}\X{15}{100}\X{10}{100}\X{55}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Type/Range}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Value}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{TagType}}
&&
\sphinxAtStartPar
logic
&
\sphinxAtStartPar
The SystemVerilog data type of the operation tag input and output ports.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{TrueSIMDClass}}
&
\sphinxAtStartPar
int
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
Vectorial mode classify operation RISC\sphinxhyphen{}V compliancy.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{EnableSIMDMask}}
&
\sphinxAtStartPar
int
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
Inactive vectorial lanes floating\sphinxhyphen{}point status flags masking.
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\section{FP Register File}
\label{\detokenize{fpu:fp-register-file}}
\sphinxAtStartPar
By default a dedicated register file consisting of 32
floating\sphinxhyphen{}point registers, \sphinxcode{\sphinxupquote{f0}}\sphinxhyphen{}\sphinxcode{\sphinxupquote{f31}}, is instantiated. This default behavior
can be overruled by setting the parameter \sphinxstylestrong{ZFINX} of the \sphinxcode{\sphinxupquote{cv32e40p\_top}} top level
module to 1, in which case the dedicated register file is
not included and the general purpose register file is used instead to
host the floating\sphinxhyphen{}point operands.

\sphinxAtStartPar
The latency of the individual instructions are explained in {\hyperref[\detokenize{pipeline:instructions-latency-table}]{\sphinxcrossref{\DUrole{std,std-ref}{Cycle counts per instruction type}}}} table.

\sphinxAtStartPar
To allow FPU unit to be put in sleep mode at the same time the core is doing so, a clock gating cell is instantiated in \sphinxcode{\sphinxupquote{cv32e40p\_top}} top level module as well
with its enable signal being inverted \sphinxcode{\sphinxupquote{core\_sleep\_o}} core output.


\section{FP CSR}
\label{\detokenize{fpu:fp-csr}}
\sphinxAtStartPar
When using floating\sphinxhyphen{}point extensions the standard specifies a
floating\sphinxhyphen{}point status and control register ({\hyperref[\detokenize{control_status_registers:csr-fcsr}]{\sphinxcrossref{\DUrole{std,std-ref}{Floating\sphinxhyphen{}point control and status register (fcsr)}}}}) which contains the
exceptions that occurred since it was last reset and the rounding mode.
{\hyperref[\detokenize{control_status_registers:csr-fflags}]{\sphinxcrossref{\DUrole{std,std-ref}{Floating\sphinxhyphen{}point accrued exceptions (fflags)}}}} and {\hyperref[\detokenize{control_status_registers:csr-frm}]{\sphinxcrossref{\DUrole{std,std-ref}{Floating\sphinxhyphen{}point dynamic rounding mode (frm)}}}} can be accessed directly or via {\hyperref[\detokenize{control_status_registers:csr-fcsr}]{\sphinxcrossref{\DUrole{std,std-ref}{Floating\sphinxhyphen{}point control and status register (fcsr)}}}} which is mapped to
those two registers.


\section{Reminder for programmers}
\label{\detokenize{fpu:reminder-for-programmers}}
\sphinxAtStartPar
As mentioned in RISC\sphinxhyphen{}V Privileged Architecture specification, \sphinxcode{\sphinxupquote{mstatus}}.FS should be set to Initial to be able to use FP instructions.
If \sphinxcode{\sphinxupquote{mstatus}}.FS = Off (reset value), any instruction that attempts to read or write the Floating\sphinxhyphen{}Point state (F registers or F CSRs) will cause an illegal instruction exception.

\sphinxAtStartPar
Upon interrupt or context switch events, \sphinxcode{\sphinxupquote{mstatus}}.SD should be read to see if Floating\sphinxhyphen{}Point state has been altered.
If following executed program (interrupt routine or whatsover) is going to use FP instructions and only if \sphinxcode{\sphinxupquote{mstatus}}.SD = 1 (means FS = Dirty),
then the whole FP state (F registers and F CSRs) should be saved in memory and program should set \sphinxcode{\sphinxupquote{mstatus}}.FS to Clean.
When returning to interrupted or main program, if \sphinxcode{\sphinxupquote{mstatus}}.FS = Clean then the whole FP state should be restored from memory.

\sphinxstepscope


\chapter{Verification}
\label{\detokenize{verification:verification}}\label{\detokenize{verification:id1}}\label{\detokenize{verification::doc}}
\sphinxAtStartPar
The verification environment (testbenches, testcases, etc.) for the CV32E40P
core can be found at  \sphinxhref{https://github.com/openhwgroup/core-v-verif}{core\sphinxhyphen{}v\sphinxhyphen{}verif}.
It is recommended to start by reviewing the
\sphinxhref{https://docs.openhwgroup.org/projects/core-v-verif/en/latest}{CORE\sphinxhyphen{}V Verification Strategy}.


\section{v1.0.0 verification}
\label{\detokenize{verification:v1-0-0-verification}}
\sphinxAtStartPar
In early 2021 the CV32E40P achieved Functional RTL Freeze (released with cv32e40p\_v1.0.0 version), meaning that is has been fully verified as per its
\sphinxhref{https://github.com/openhwgroup/core-v-verif/tree/cv32e40p/dev/cv32e40p/docs/VerifPlans/README.md}{Verification Plan}.
Final functional, code and test coverage reports can be found \sphinxhref{https://github.com/openhwgroup/core-v-verif/blob/master/docs/Reports/cv32e40p/index.html}{here}.

\sphinxAtStartPar
The unofficial start date for the CV32E40P verification effort is 2020\sphinxhyphen{}02\sphinxhyphen{}27,
which is the date the core\sphinxhyphen{}v\sphinxhyphen{}verif environment “went live”.  Between then and
RTL Freeze, a total of 47 RTL issues and 38 User Manual issues were identified
and resolved %
\begin{footnote}[1]\sphinxAtStartFootnote
It is a testament on the quality of the work done by the PULP platform team
that it took a team of professonal verification engineers more than 9 months
to find all these issues.
%
\end{footnote}.

\sphinxAtStartPar
A breakdown of the RTL issues is as follows:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{How RTL Issues Were Found in v1.0.0}\label{\detokenize{verification:how-rtl-issues-were-found-in-v1-0-0}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{27}{100}\X{9}{100}\X{64}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{“Found By”}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Count}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Note}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
Simulation
&
\sphinxAtStartPar
18
&
\sphinxAtStartPar
See classification below
\\
\sphinxhline
\sphinxAtStartPar
Inspection
&
\sphinxAtStartPar
13
&
\sphinxAtStartPar
Human review of the RTL
\\
\sphinxhline
\sphinxAtStartPar
Formal Verification
&
\sphinxAtStartPar
13
&
\sphinxAtStartPar
This includes both Designer and Verifier use of FV
\\
\sphinxhline
\sphinxAtStartPar
Lint
&
\sphinxAtStartPar
2
&\\
\sphinxhline
\sphinxAtStartPar
Unknown
&
\sphinxAtStartPar
1
&\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
A classification of the simulation issues by method used to identify them is informative:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Breakdown of Issues found by Simulation in v1.0.0}\label{\detokenize{verification:breakdown-of-issues-found-by-simulation-in-v1-0-0}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{27}{100}\X{9}{100}\X{64}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Simulation Method}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Count}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Note}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
Directed, self\sphinxhyphen{}checking test
&
\sphinxAtStartPar
10
&
\sphinxAtStartPar
Many test supplied by Design team and a couple from the Open Source Community at large
\\
\sphinxhline
\sphinxAtStartPar
Step \& Compare
&
\sphinxAtStartPar
6
&
\sphinxAtStartPar
Issues directly attributed to S\&C against ISS
\\
\sphinxhline
\sphinxAtStartPar
Constrained\sphinxhyphen{}Random
&
\sphinxAtStartPar
2
&
\sphinxAtStartPar
Test generated by corev\sphinxhyphen{}dv (extension of riscv\sphinxhyphen{}dv)
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
A classification of the issues themselves:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Issue Classification in v1.0.0}\label{\detokenize{verification:issue-classification-in-v1-0-0}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{27}{100}\X{9}{100}\X{64}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Issue Type}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Count}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Note}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
RTL Functional
&
\sphinxAtStartPar
40
&
\sphinxAtStartPar
A bug!
\\
\sphinxhline
\sphinxAtStartPar
RTL coding style
&
\sphinxAtStartPar
4
&
\sphinxAtStartPar
Linter issues, removing TODOs, removing \textasciigrave{}ifdefs, etc.
\\
\sphinxhline
\sphinxAtStartPar
Non\sphinxhyphen{}RTL functional
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
Issue related to behavioral tracer (not part of the core)
\\
\sphinxhline
\sphinxAtStartPar
Unreproducible
&
\sphinxAtStartPar
1
&\\
\sphinxhline
\sphinxAtStartPar
Invalid
&
\sphinxAtStartPar
1
&\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Additional details are available as part of the \sphinxhref{https://github.com/openhwgroup/programs/tree/master/milestones/CV32E40P/RTL\_Freeze\_v1.0.0}{CV32E40P v1.0.0 Report}.


\section{v2.0.0 verification}
\label{\detokenize{verification:v2-0-0-verification}}
\sphinxAtStartPar
The table below lists the 9 configurations with \sphinxcode{\sphinxupquote{cv32e40p\_top}} parameters values verified in the scope of CV32E40Pv2 project using both Formal\sphinxhyphen{}based and Simulation\sphinxhyphen{}based methodologies.


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Verified configurations}\label{\detokenize{verification:verified-configurations}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{TTTTTTTTTT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Top Parameters}
&\sphinxstartmulticolumn{9}%
\begin{varwidth}[t]{\sphinxcolwidth{9}{10}}
\sphinxstyletheadfamily \sphinxAtStartPar
\sphinxstylestrong{Verified Configurations}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
COREV\_PULP
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
1
\\
\sphinxhline
\sphinxAtStartPar
COREV\_CLUSTER
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
1
\\
\sphinxhline
\sphinxAtStartPar
FPU
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
1
\\
\sphinxhline
\sphinxAtStartPar
ZFINX
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
1
\\
\sphinxhline
\sphinxAtStartPar
FPU\_ADDMUL\_LAT
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
2
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
2
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
2
\\
\sphinxhline
\sphinxAtStartPar
FPU\_OTHERS\_LAT
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
2
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
2
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
2
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
A total of resp. 30 and xx RTL issues were identified by resp. Formal Verification and Simulation methodologies, all have been resolved.

\sphinxAtStartPar
A breakdown of the RTL issues is as follows:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{How RTL Issues Were Found in v2.0.0}\label{\detokenize{verification:how-rtl-issues-were-found-in-v2-0-0}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{27}{100}\X{9}{100}\X{64}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{“Found By”}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Count}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Note}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
Formal Verification
&
\sphinxAtStartPar
30
&
\sphinxAtStartPar
All related to features enabled by \sphinxcode{\sphinxupquote{COREV\_PULP}} or \sphinxcode{\sphinxupquote{FPU}}.
\\
\sphinxhline
\sphinxAtStartPar
Simulation
&&\\
\sphinxhline
\sphinxAtStartPar
Lint
&&\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
A classification of the Formal Verification issues by type and their description are listed in the two following tables:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Breakdown of Issues found by Formal Verification in v2.0.0}\label{\detokenize{verification:breakdown-of-issues-found-by-formal-verification-in-v2-0-0}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{27}{100}\X{9}{100}\X{64}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Type}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Count}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Note}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
User Manual
&
\sphinxAtStartPar
12
&
\sphinxAtStartPar
Instructions description leading to mis\sphinxhyphen{}interpretation
\\
\sphinxhline
\sphinxAtStartPar
RTL bugs
&
\sphinxAtStartPar
18
&
\sphinxAtStartPar
See classification below
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Formal Verification Issues Classification in v2.0.0}\label{\detokenize{verification:formal-verification-issues-classification-in-v2-0-0}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{27}{100}\X{9}{100}\X{64}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Issue Type}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Count}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Note}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
Illegal instructions exception
&
\sphinxAtStartPar
5
&
\sphinxAtStartPar
F and XPULP instructions corner cases or CSR accesses not flagged as Illegal
instructions exception.
\\
\sphinxhline
\sphinxAtStartPar
Multi\sphinxhyphen{}cycle F instructions
&
\sphinxAtStartPar
8
&
\sphinxAtStartPar
FDIV, FSQRT or respective F instructions (when FPU\_ADDMUL\_LAT or FPU\_OTHERS\_LAT = 2)
are executed in the background and the pipeline can continue to execute other
instructions as long as there is no Read\sphinxhyphen{}After\sphinxhyphen{}Write or Write\sphinxhyphen{}After\sphinxhyphen{}Write dependency.
When the multi\sphinxhyphen{}cycle F instructions are finally writing back their result in the
Register File, this register update can corrupt on\sphinxhyphen{}going instructions behaviour or
result. This is the case for Misaligned Loads, Post\sphinxhyphen{}Incremented Load/Stores, MULH,
JALR or cv.add*NR/cv.sub*NR.
\\
\sphinxhline
\sphinxAtStartPar
F instructions result or flags
&
\sphinxAtStartPar
5
&
\sphinxAtStartPar
F result or flags computations is incorrect with respect to IEEE 754\sphinxhyphen{}2008 standard.
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
A classification of the simulation issues by method used to identify them is informative:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Breakdown of Issues found by Simulation in v2.0.0}\label{\detokenize{verification:breakdown-of-issues-found-by-simulation-in-v2-0-0}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{27}{100}\X{9}{100}\X{64}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Simulation Method}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Count}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Note}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
Directed, self\sphinxhyphen{}checking test
&&
\sphinxAtStartPar
Many test supplied by Design team and a couple from the Open Source Community at large
\\
\sphinxhline
\sphinxAtStartPar
RVFI/RVVI
&&
\sphinxAtStartPar
Issues directly attributed to comparison against Reference Model
\\
\sphinxhline
\sphinxAtStartPar
Constrained\sphinxhyphen{}Random
&&
\sphinxAtStartPar
Test generated by corev\sphinxhyphen{}dv (extension of riscv\sphinxhyphen{}dv)
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
A classification of the Simulation issues themselves:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Simulation Issue Classification in v2.0.0}\label{\detokenize{verification:simulation-issue-classification-in-v2-0-0}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{27}{100}\X{9}{100}\X{64}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Issue Type}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Count}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Note}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
RTL Functional bug
&&\\
\sphinxhline&&\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\subsection{Formal verification}
\label{\detokenize{verification:formal-verification}}
\sphinxAtStartPar
To accelerate the verification of more than 300 Xpulp instructions, Formal Verification methodology has been used with Siemens EDA Onespin tools and its RISC\sphinxhyphen{}V ISA Processor Verification app.

\sphinxAtStartPar
The Xpulp instructions pseudo\sphinxhyphen{}code description using Sail language have been added to the RISC\sphinxhyphen{}V ISA app to successfully formally verify all the CV32E40P instructions, including the previously verified standard IMC together with the new F, Zfinx and Xpulp extensions and all additional custom CSRs.

\sphinxAtStartPar
Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZob{}
  \PYGZdq{}name\PYGZdq{}: \PYGZdq{}CV.SDOTUP.B\PYGZdq{},
  \PYGZdq{}disassembly\PYGZdq{}: \PYGZdq{}cv.sdotup.b \PYGZob{}rd\PYGZcb{},\PYGZob{}rs1\PYGZcb{},\PYGZob{}rs2\PYGZcb{}\PYGZdq{},
  \PYGZdq{}decoding\PYGZdq{}: \PYGZdq{}1001100 rs2 rs1 001 rd/rs3 1111011\PYGZdq{},
  \PYGZdq{}restrictions\PYGZdq{}: \PYGZdq{}\PYGZdq{},
  \PYGZdq{}execution\PYGZdq{}: \PYGZdq{}X(rd) = X(rs3) + EXTZ(mul(X(rs1)[7..0],X(rs2)[7..0])) +
                                 EXTZ(mul(X(rs1)[15..8],X(rs2)[15..8])) +
                                 EXTZ(mul(X(rs1)[23..16],X(rs2)[23..16])) +
                                 EXTZ(mul(X(rs1)[31..24],X(rs2)[31..24]))\PYGZdq{}
\PYGZcb{},
\end{sphinxVerbatim}

\sphinxAtStartPar
Those SAIL instructions description are then used to automatically generate more than 430 assertions and 29 CSRs descriptions.
Those assertions have been applied on the 9 different configurations listed in {\hyperref[\detokenize{verification:verified-configurations}]{\sphinxcrossref{\DUrole{std,std-ref}{Verified configurations}}}} table.

\sphinxAtStartPar
RTL code coverage is generated using Siemens EDA Onespin Quantify tool which uses RTL mutation to check assertions quality and can produce standard UCDB database that can be merged with simulation one afterwards.

\sphinxAtStartPar
WIP…


\subsection{Simulation verification}
\label{\detokenize{verification:simulation-verification}}
\sphinxAtStartPar
core\sphinxhyphen{}v\sphinxhyphen{}verif verification environment for v1.0.0 was using a \sphinxstyleemphasis{step\&compare} methodology with an instruction set simulator (ISS) from Imperas Software as the reference model.
This strategy was successful, but inefficient because the \sphinxstyleemphasis{step\&compare} logic in the testbench must compensate for the cycle\sphinxhyphen{}time effects of events that are asynchronous to the instruction stream such as interrupts, debug resets plus bus errors and random delays on instruction fetch and load/store memory buses.
For verification of v2.0.0 release of the CV32E40P core, the step\sphinxhyphen{}and\sphinxhyphen{}compare and the ISS have been replaced by a true reference model (RM) called ImperasDV. In addition, the Imperas Reference Model has been extended to support the v2 Xpulp instructions specification.

\sphinxAtStartPar
Another innovation for v2.0.0 was the adoption of a standardized tracer interface to the DUT and RM, based on the open\sphinxhyphen{}source RISC\sphinxhyphen{}V Verification Interface (RVVI). The use of well documented, standardized interfaces greatly simplifies the integration of the DUT with the RM.

\sphinxAtStartPar
Additionaly to V1 Verification plans, \sphinxhref{https://github.com/openhwgroup/core-v-verif/tree/cv32e40p/dev/cv32e40p/docs/VerifPlans/README.md}{Verification Plan} contains a \sphinxhref{https://github.com/openhwgroup/core-v-verif/blob/cv32e40p/dev/cv32e40p/docs/VerifPlans/README.md\#cv32e40p-v2-verification-plans}{new section} related to F and XPULP verification.

\sphinxAtStartPar
WIP…


\subsection{Reports}
\label{\detokenize{verification:reports}}
\sphinxAtStartPar
WIP…


\section{Tracer}
\label{\detokenize{verification:tracer}}
\sphinxAtStartPar
The module \sphinxcode{\sphinxupquote{cv32e40p\_rvfi\_trace}} can be used to create a log of the executed instructions.
It is a behavioral, non\sphinxhyphen{}synthesizable, module instantiated in the example testbench that is provided for
the \sphinxcode{\sphinxupquote{cv32e40p\_top}}. It can be enabled during simulation by defining \sphinxstylestrong{CV32E40P\_RVFI\_TRACE\_EXECUTION}.


\subsection{Output file}
\label{\detokenize{verification:output-file}}
\sphinxAtStartPar
All traced instructions are written to a log file.
The log file is named \sphinxcode{\sphinxupquote{trace\_core\_\textless{}HARTID\textgreater{}.log}}, with \sphinxcode{\sphinxupquote{\textless{}HARTID\textgreater{}}} being the 32 digit hart ID of the core being traced.


\subsection{Trace output format}
\label{\detokenize{verification:trace-output-format}}
\sphinxAtStartPar
The trace output is in tab\sphinxhyphen{}separated columns.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Time}: The current simulation time.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Cycle}: The number of cycles since the last reset.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{PC}: The program counter

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Instr}: The executed instruction (base 16).
32 bit wide instructions (8 hex digits) are uncompressed instructions, 16 bit wide instructions (4 hex digits) are compressed instructions.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Decoded instruction}: The decoded (disassembled) instruction in a format equal to what objdump produces when calling it like \sphinxcode{\sphinxupquote{objdump \sphinxhyphen{}Mnumeric \sphinxhyphen{}Mno\sphinxhyphen{}aliases \sphinxhyphen{}D}}.
\sphinxhyphen{} Unsigned numbers are given in hex (prefixed with \sphinxcode{\sphinxupquote{0x}}), signed numbers are given as decimal numbers.
\sphinxhyphen{} Numeric register names are used (e.g. \sphinxcode{\sphinxupquote{x1}}).
\sphinxhyphen{} Symbolic CSR names are used.
\sphinxhyphen{} Jump/branch targets are given as absolute address if possible (PC + immediate).

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Register and memory contents}: For all accessed registers, the value before and after the instruction execution is given. Writes to registers are indicated as \sphinxcode{\sphinxupquote{registername=value}}, reads as \sphinxcode{\sphinxupquote{registername:value}}. For memory accesses, the physical address (PA), the loaded and stored data are given.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Time Cycle PC       Instr    Decoded instruction Register and memory contents
 130    61 00000150 4481     c.li    x9,0        x9=0x00000000
 132    62 00000152 00008437 lui     x8,0x8      x8=0x00008000
 134    63 00000156 fff40413 addi    x8,x8,\PYGZhy{}1    x8=0x00007fff  x8:0x00008000
 136    64 0000015a 8c65     c.and   x8,x9       x8=0x00000000  x8:0x00007fff  x9:0x00000000
 142    67 0000015c c622     c.swsp  x8,12(x2)   x2:0x00002000  x8:0x00000000 PA:0x0000200c
\end{sphinxVerbatim}

\sphinxstepscope


\chapter{CORE\sphinxhyphen{}V Hardware Loop feature}
\label{\detokenize{corev_hw_loop:core-v-hardware-loop-feature}}\label{\detokenize{corev_hw_loop:hwloop-specs}}\label{\detokenize{corev_hw_loop::doc}}
\sphinxAtStartPar
To increase the efficiency of small loops, CV32E40P supports hardware
loops (HWLoop). They can be enabled by setting the \sphinxcode{\sphinxupquote{COREV\_PULP}} parameter.
Hardware loops make executing a piece of code
multiple times possible, without the overhead of branches penalty or updating a counter.
Hardware loops involve zero stall cycles for jumping to the first
instruction of a loop.

\sphinxAtStartPar
A hardware loop is defined by its start address (pointing to the first
instruction in the loop), its end address (pointing to the instruction
just after the last one executed by the loop) and a counter that is
decremented every time the last instruction of the loop body is executed.

\sphinxAtStartPar
CV32E40P contains two hardware loop register sets to support nested hardware loops,
each of them can store these three values in separate flip flops which are
mapped in the CSR address space.
Loop number 0 has higher priority than loop number 1 in a nested loop
configuration, meaning that loop 0 represents the inner loop and loop 1 is the outer loop.


\section{Hardware Loop constraints}
\label{\detokenize{corev_hw_loop:hardware-loop-constraints}}
\sphinxAtStartPar
Following constraints must be respected by any toolchain compiler or by hand\sphinxhyphen{}written assembly code.
\sphinxcode{\sphinxupquote{Violation of these constraints will not generate any hardware exception}} and behaviour is undefined.

\sphinxAtStartPar
In order to catch \sphinxstylestrong{as early as possible} those software exceptions when executing a program either
on a verification Reference Model or on a virtual platform Instruction Set Simulator, \sphinxcode{\sphinxupquote{those model/simulation platforms
should generate an error}} with a meaningfull message related to Hardware Loops constraints violation.
Those constraint checks could be done only for each instruction in the hardware loop body, meaning when (lpstartX \textless{}= PC \textless{}= lpendX \sphinxhyphen{} 4) and (lpcountX \textgreater{} 0).

\sphinxAtStartPar
The HWLoop constraints are:
\begin{itemize}
\item {} 
\sphinxAtStartPar
HWLoop start, end and setup instructions addresses must be 32\sphinxhyphen{}bit aligned (short or long commands).

\item {} 
\sphinxAtStartPar
Start and End addresses of an HWLoop body must be 32\sphinxhyphen{}bit aligned.

\item {} 
\sphinxAtStartPar
End Address must be strictly greater than Start Address.

\item {} 
\sphinxAtStartPar
HWLoop \#0 (resp. \#1) start and end addresses \sphinxstylestrong{must not be modified} if HWLoop \#0 (resp. \#1) count is different than 0.

\item {} 
\sphinxAtStartPar
End address of an HWLoop must point to the instruction just after the last one of the HWLoop body.

\item {} 
\sphinxAtStartPar
HWLoop body must contain at least 3 instructions.

\item {} 
\sphinxAtStartPar
When both loops are nested, the End address of the outermost HWLoop (must be \#1) must be at least 2
instructions further than the End address of the innermost HWLoop (must be \#0),
i.e. HWLoop{[}1{]}.endaddress \textgreater{}= HWLoop{[}0{]}.endaddress + 8.

\item {} 
\sphinxAtStartPar
HWLoop must always be entered from its start location (no branch/jump to a location inside a HWLoop body).

\item {} 
\sphinxAtStartPar
No HWLoop \#0 (resp. \#1) CSR should be modified inside the HWLoop \#0 (resp. \#1) body.

\item {} 
\sphinxAtStartPar
No Compressed instructions (RVC) allowed in the HWLoop body.

\item {} 
\sphinxAtStartPar
No jump or branch instructions allowed in the HWLoop body.

\item {} 
\sphinxAtStartPar
No memory ordering instructions (fence, fence.i) allowed in the HWLoop body.

\item {} 
\sphinxAtStartPar
No privileged instructions (mret, dret, wfi) allowed in the HWLoop body, except for ebreak and ecall.

\end{itemize}

\sphinxAtStartPar
The rationale of NOT generating any hardware exception when violating any of those constraints is that it would add resources
(32\sphinxhyphen{}bit adders and substractors needed for the third and fourth rules) which are costly in area and power consumption.
These additional (and costly) resources would be present just to catch situations that should never happen.
This in an architectural choice in order to keep CV32E40P area and power consumption to its lowest level.

\sphinxAtStartPar
The rationale of putting the end\sphinxhyphen{}of\sphinxhyphen{}loop label to the first instruction after the last one of the loop body
is that it greatly simplifies compiler optimization (relative to basic blocks management).

\sphinxAtStartPar
In order to use hardware loops, the compiler needs to setup the loops beforehand with cv.start/i, cv.end/i, cv.count/i or cv.setup/i instructions.
The compiler will use HWLoop automatically whenever possible without the need of assembly.

\sphinxAtStartPar
For debugging, interrupts and context switches, the hardware loop registers are mapped into the CSR custom read\sphinxhyphen{}only address space.
To read them csrr instructions should be used and to write them register flavour of hardware loop instructions should be used.
Using csrw instructions to write hardware loop registers will generate an illegal instruction exception.
The CSR HWLoop registers are described in the {\hyperref[\detokenize{control_status_registers:cs-registers}]{\sphinxcrossref{\DUrole{std,std-ref}{Control and Status Registers}}}} section.

\sphinxAtStartPar
Below an assembly code example of a nested HWLoop that computes a matrix addition.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{asm}\PYG{+w}{ }\PYG{k}{volatile}\PYG{+w}{ }\PYG{p}{(}
\PYG{+w}{    }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{add \PYGZpc{}[i],x0, x0;}\PYG{l+s}{\PYGZdq{}}
\PYG{+w}{    }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{add \PYGZpc{}[j],x0, x0;}\PYG{l+s}{\PYGZdq{}}
\PYG{+w}{    }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.balign 4;}\PYG{l+s}{\PYGZdq{}}
\PYG{+w}{    }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{cv.starti 1, start1;}\PYG{l+s}{\PYGZdq{}}
\PYG{+w}{    }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{cv.endi   1, end1;}\PYG{l+s}{\PYGZdq{}}
\PYG{+w}{    }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{cv.count  1, \PYGZpc{}[N];}\PYG{l+s}{\PYGZdq{}}
\PYG{+w}{    }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{any instructions here}\PYG{l+s}{\PYGZdq{}}
\PYG{+w}{    }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.balign 4;}\PYG{l+s}{\PYGZdq{}}
\PYG{+w}{    }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{cv.starti 0, start0;}\PYG{l+s}{\PYGZdq{}}
\PYG{+w}{    }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{cv.endi   0, end0;}\PYG{l+s}{\PYGZdq{}}
\PYG{+w}{    }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{any instructions here}\PYG{l+s}{\PYGZdq{}}
\PYG{+w}{    }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.balign 4;}\PYG{l+s}{\PYGZdq{}}
\PYG{+w}{    }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.option norvc;}\PYG{l+s}{\PYGZdq{}}
\PYG{+w}{    }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{start1:;}\PYG{l+s}{\PYGZdq{}}
\PYG{+w}{    }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{    cv.count 0, \PYGZpc{}[N];}\PYG{l+s}{\PYGZdq{}}
\PYG{+w}{    }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{    start0:;}\PYG{l+s}{\PYGZdq{}}
\PYG{+w}{    }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{        addi \PYGZpc{}[i], \PYGZpc{}[i], 1;}\PYG{l+s}{\PYGZdq{}}
\PYG{+w}{    }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{        addi \PYGZpc{}[i], \PYGZpc{}[i], 1;}\PYG{l+s}{\PYGZdq{}}
\PYG{+w}{    }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{        addi \PYGZpc{}[i], \PYGZpc{}[i], 1;}\PYG{l+s}{\PYGZdq{}}
\PYG{+w}{    }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{    end0:;}\PYG{l+s}{\PYGZdq{}}
\PYG{+w}{    }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{    addi \PYGZpc{}[j], \PYGZpc{}[j], 2;}\PYG{l+s}{\PYGZdq{}}
\PYG{+w}{    }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{    addi \PYGZpc{}[j], \PYGZpc{}[j], 2;}\PYG{l+s}{\PYGZdq{}}
\PYG{+w}{    }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{end1:;}\PYG{l+s}{\PYGZdq{}}
\PYG{+w}{    }\PYG{o}{:}\PYG{+w}{ }\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{+r}\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{+r}\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{j}\PYG{p}{)}
\PYG{+w}{    }\PYG{o}{:}\PYG{+w}{ }\PYG{p}{[}\PYG{n}{N}\PYG{p}{]}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}
\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
As HWLoop feature is enabled as soon as lpcountX \textgreater{} 0, lpstartX and lpendX \sphinxstylestrong{must} be programmed \sphinxstylestrong{before} lpcountX to avoid unexpected behavior.
For HWLoop where body contains up to 30 instructions, it is always better to use cv.setup* instructions which are updating all 3 HWLoop CSRs in the same cycle.

\sphinxAtStartPar
At the beginning of the HWLoop, the registers \%{[}i{]} and \%{[}j{]} are 0.
The innermost loop, from start0 to (end0 \sphinxhyphen{} 4), adds to \%{[}i{]} three times 1 and
it is executed 10x10 times. Whereas the outermost loop, from start1 to (end1 \sphinxhyphen{} 4),
executes 10 times the innermost loop and adds two times 2 to the register \%{[}j{]}.
At the end of the loop, the register \%{[}i{]} contains 300 and the register \%{[}j{]} contains 40.


\section{Hardware loops impact on application, exceptions handlers and debugger}
\label{\detokenize{corev_hw_loop:hardware-loops-impact-on-application-exceptions-handlers-and-debugger}}\label{\detokenize{corev_hw_loop:hwloop-exceptions-handlers}}

\subsection{Application and ebreak/ecall exception handlers}
\label{\detokenize{corev_hw_loop:application-and-ebreak-ecall-exception-handlers}}
\sphinxAtStartPar
When an ebreak or an ecall instruction is used in an application, special care should be given for those instruction handlers in case they are placed as the last instruction of an HWLoop.
Those handlers should manage MEPC and lpcountX CSRs updates because an hw loop early\sphinxhyphen{}exit could happen if not done.

\sphinxAtStartPar
At the end of the handlers after restoring the context/CSRs, a piece of smart code should be added with following highest to lowest order of priority:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
if MEPC = lpend0 \sphinxhyphen{} 4 and lpcount0 \textgreater{} 1 then MEPC should be set to lpstart0 and lpcount0 should be decremented by 1,

\item {} 
\sphinxAtStartPar
else if MEPC = lpend0 \sphinxhyphen{} 4 and lpcount0 = 1 then MEPC should be incremented by 4 and lpcount0 should be decremented by 1,

\item {} 
\sphinxAtStartPar
else if MEPC = lpend1 \sphinxhyphen{} 4 and lpcount1 \textgreater{} 1 then MEPC should be set to lpstart1 and lpcount1 should be decremented by 1,

\item {} 
\sphinxAtStartPar
else if MEPC = lpend1 \sphinxhyphen{} 4 and lpcount1 = 1 then MEPC should be incremented by 4 and lpcount1 should be decremented by 1,

\item {} 
\sphinxAtStartPar
else if (lpstart0 \textless{}= MEPC \textless{} lpend0 \sphinxhyphen{} 4) or (lpstart1 \textless{}= MEPC \textless{} lpend1 \sphinxhyphen{} 4) then MEPC should be incremented by 4,

\item {} 
\sphinxAtStartPar
else if instruction at MEPC location is either ecall or ebreak then MEPC should be incremented by 4,

\item {} 
\sphinxAtStartPar
else if instruction at MEPC location location is c.ebreak then MEPC should be incremented by 2.

\end{enumerate}

\sphinxAtStartPar
The 2 last cases are the standard ones when ebreak/ecall are not inside an HWLopp.


\subsection{Interrupt handlers}
\label{\detokenize{corev_hw_loop:interrupt-handlers}}
\sphinxAtStartPar
When an interrupt is happening on the last HWLoop instruction, its execution is cancelled, its address is saved in MEPC and its execution will be resumed when returning from interrupt handler.
There is nothing special to be done in those interrupt handlers with respect to MEPC and lpcountX updates, they will be correctly managed by design when executing this last HWLoop instruction after interrupt handler execution.

\sphinxAtStartPar
Moreover since hardware loop could be used in interrupt routine, the registers have to be saved (resp. restored) at the beginning (resp. end) of the interrupt routine together with the general purpose registers.


\subsection{Illegal instruction exception handler}
\label{\detokenize{corev_hw_loop:illegal-instruction-exception-handler}}
\sphinxAtStartPar
Depending if an application is going to resume or not after Illegal instruction exception handler, same MEPC/HWLoops CSRs management than ebreak/ecall could be necessary.


\subsection{Debugger}
\label{\detokenize{corev_hw_loop:debugger}}
\sphinxAtStartPar
If ebreak is used to enter in Debug Mode ({\hyperref[\detokenize{debug:ebreak-scenario-2}]{\sphinxcrossref{\DUrole{std,std-ref}{Scenario 2 : Enter Debug Mode}}}}) and put at the last instruction location of an HWLoop (not very likely to happen), same management than above should be done but on DPC rather than on MEPC.

\sphinxAtStartPar
When ebreak instruction is used as Software Breakpoint by a debugger when in debug mode and is placed at the last instruction location of an HWLoop in instruction memory, no special management is foreseen.
When executing the Software Breakpoint/ebreak instruction, control is given back to the debugger which will manage the different cases.
For instance in Single\sphinxhyphen{}Step case, original instruction is put back in instruction memory, a Single\sphinxhyphen{}Step command is executed on this last instruction (with desgin updating PC and lpcountX to correct values) and Software Breakpoint/ebreak is put back by the debugger in memory.

\sphinxAtStartPar
When ecall instruction is used by a debugger to execute System Calls and is placed at the last instruction location of an HWLoop in instruction memory, debugger ecall handler in debug rom should do the same than described above for application case.

\sphinxstepscope


\chapter{CORE\sphinxhyphen{}V Instruction Set Custom Extensions}
\label{\detokenize{instruction_set_extensions:core-v-instruction-set-custom-extensions}}\label{\detokenize{instruction_set_extensions:custom-isa-extensions}}\label{\detokenize{instruction_set_extensions::doc}}
\sphinxAtStartPar
CV32E40P supports the following CORE\sphinxhyphen{}V ISA X Custom Extensions, which can be enabled by setting \sphinxcode{\sphinxupquote{COREV\_PULP}} == 1.
\begin{itemize}
\item {} 
\sphinxAtStartPar
Post\sphinxhyphen{}Increment load and stores, see {\hyperref[\detokenize{instruction_set_extensions:corev-load-store}]{\sphinxcrossref{\DUrole{std,std-ref}{Post\sphinxhyphen{}Increment Load \& Store Instructions and Register\sphinxhyphen{}Register Load \& Store Instructions}}}}, invoked in the tool chain with \sphinxcode{\sphinxupquote{\sphinxhyphen{}march=rv32i*\_xcvmem}}.

\item {} 
\sphinxAtStartPar
Hardware Loop extension, see {\hyperref[\detokenize{instruction_set_extensions:corev-hardware-loop}]{\sphinxcrossref{\DUrole{std,std-ref}{Hardware Loops}}}}, invoked in the tool chain with \sphinxcode{\sphinxupquote{\sphinxhyphen{}march=rv32i*\_xcvhwlp}}.

\item {} 
\sphinxAtStartPar
ALU extensions, see {\hyperref[\detokenize{instruction_set_extensions:corev-alu}]{\sphinxcrossref{\DUrole{std,std-ref}{ALU}}}}, which are divided into three sub\sphinxhyphen{}extensions:
\begin{itemize}
\item {} 
\sphinxAtStartPar
bit manipulation instructions, invoked in the tool chain with \sphinxcode{\sphinxupquote{\sphinxhyphen{}march=rv32i*\_xcvbitmanip}};

\item {} 
\sphinxAtStartPar
miscellaneous ALU instructions, invoked in the tool chain with \sphinxcode{\sphinxupquote{\sphinxhyphen{}march=rv32i*\_xcvalu}}; and

\item {} 
\sphinxAtStartPar
immediate branch instructions, invoked in the tool chain with \sphinxcode{\sphinxupquote{\sphinxhyphen{}march=rv32i*\_xcvbi}}.

\end{itemize}

\item {} 
\sphinxAtStartPar
Multiply\sphinxhyphen{}Accumulate extensions, see {\hyperref[\detokenize{instruction_set_extensions:corev-multiply-accumulate}]{\sphinxcrossref{\DUrole{std,std-ref}{Multiply\sphinxhyphen{}Accumulate}}}}, invoked in the tool chain with \sphinxcode{\sphinxupquote{\sphinxhyphen{}march=rv32i*\_xcvmac}}.

\item {} 
\sphinxAtStartPar
Single Instruction Multiple Data (aka SIMD) extensions, see {\hyperref[\detokenize{instruction_set_extensions:corev-simd}]{\sphinxcrossref{\DUrole{std,std-ref}{SIMD}}}}, invoked in the tool chain with \sphinxcode{\sphinxupquote{\sphinxhyphen{}march=rv32i*\_xcvsimd}}.

\end{itemize}

\sphinxAtStartPar
Additionally the event load instruction (\sphinxstylestrong{cv.elw}) is supported by setting \sphinxcode{\sphinxupquote{COREV\_CLUSTER}} == 1, see {\hyperref[\detokenize{instruction_set_extensions:corev-event-load}]{\sphinxcrossref{\DUrole{std,std-ref}{Event Load Instruction}}}}.
This is a separate ISA extension, invoked in the tool chain with \sphinxcode{\sphinxupquote{\sphinxhyphen{}march=rv32i*\_xcvelw}}.

\sphinxAtStartPar
If not specified, all the operands are signed and immediate values are sign\sphinxhyphen{}extended.

\sphinxAtStartPar
To use such instructions, you need to compile your SW with the CORE\sphinxhyphen{}V GCC or Clang/LLVM compiler.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Clang/LLVM assembler will be supported by 30 June 2023, with builtin function support by 31 December 2023.
\end{sphinxadmonition}


\section{Pseudo\sphinxhyphen{}instructions}
\label{\detokenize{instruction_set_extensions:pseudo-instructions}}\label{\detokenize{instruction_set_extensions:id1}}
\sphinxAtStartPar
This specification also includes documentation of some CORE\sphinxhyphen{}V pseudo\sphinxhyphen{}instructions. Pseudo\sphinxhyphen{}instructions are implemented in the assembler
that are similar to a base instruction but provides control information to the assembler as opposed to generating its base instruction.
This makes it easier to program as we gain clarity on the intention of the programmer.
\begin{itemize}
\item {} 
\sphinxAtStartPar
16\sphinxhyphen{}Bit x 16\sphinxhyphen{}Bit Multiplication pseudo\sphinxhyphen{}instructions, see {\hyperref[\detokenize{instruction_set_extensions:corev-16-bit-multiply-pseudo-instructions}]{\sphinxcrossref{\DUrole{std,std-ref}{16\sphinxhyphen{}Bit x 16\sphinxhyphen{}Bit Multiplication pseudo\sphinxhyphen{}instructions}}}}.

\end{itemize}


\section{Post\sphinxhyphen{}Increment Load \& Store Instructions and Register\sphinxhyphen{}Register Load \& Store Instructions}
\label{\detokenize{instruction_set_extensions:post-increment-load-store-instructions-and-register-register-load-store-instructions}}\label{\detokenize{instruction_set_extensions:corev-load-store}}
\sphinxAtStartPar
Post\sphinxhyphen{}Increment load and store instructions perform a load, or a
store, respectively, while at the same time incrementing the address
that was used for the memory access. Since it is a post\sphinxhyphen{}incrementing
scheme, the base address is used for the access and the modified address
is written back to the register\sphinxhyphen{}file. There are versions of those
instructions that use immediates and those that use registers as
offsets. The base address always comes from a register.

\sphinxAtStartPar
The custom post\sphinxhyphen{}increment load \& store instructions and register\sphinxhyphen{}register
load \& store instructions are only supported if \sphinxcode{\sphinxupquote{COREV\_PULP}} == 1.


\subsection{Load operations}
\label{\detokenize{instruction_set_extensions:load-operations}}
\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
When same register is used as address and destination (rD == rs1) for post\sphinxhyphen{}incremented loads,
loaded data has highest priority over incremented address when writing to this same register.
\end{sphinxadmonition}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Load operations}\label{\detokenize{instruction_set_extensions:id2}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{30}{100}\X{70}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mnemonic}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{2}}
\sphinxAtStartPar
\sphinxstylestrong{Register\sphinxhyphen{}Immediate Loads with Post\sphinxhyphen{}Increment}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.lb rD, (rs1), Imm}
&
\sphinxAtStartPar
rD = Sext(Mem8(rs1))

\sphinxAtStartPar
rs1 += Sext(Imm{[}11:0{]})
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.lbu rD, (rs1), Imm}
&
\sphinxAtStartPar
rD = Zext(Mem8(rs1))

\sphinxAtStartPar
rs1 += Sext(Imm{[}11:0{]})
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.lh rD, (rs1), Imm}
&
\sphinxAtStartPar
rD = Sext(Mem16(rs1))

\sphinxAtStartPar
rs1 += Sext(Imm{[}11:0{]})
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.lhu rD, (rs1), Imm}
&
\sphinxAtStartPar
rD = Zext(Mem16(rs1))

\sphinxAtStartPar
rs1 += Sext(Imm{[}11:0{]})
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.lw rD, (rs1), Imm}
&
\sphinxAtStartPar
rD = Mem32(rs1)

\sphinxAtStartPar
rs1 += Sext(Imm{[}11:0{]})
\\
\sphinxhline\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{2}}
\sphinxAtStartPar
\sphinxstylestrong{Register\sphinxhyphen{}Register Loads with Post\sphinxhyphen{}Increment}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.lb rD, (rs1), rs2}
&
\sphinxAtStartPar
rD = Sext(Mem8(rs1))

\sphinxAtStartPar
rs1 += rs2
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.lbu rD, (rs1), rs2}
&
\sphinxAtStartPar
rD = Zext(Mem8(rs1))

\sphinxAtStartPar
rs1 += rs2
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.lh rD, (rs1), rs2}
&
\sphinxAtStartPar
rD = Sext(Mem16(rs1))

\sphinxAtStartPar
rs1 += rs2
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.lhu rD, (rs1), rs2}
&
\sphinxAtStartPar
rD = Zext(Mem16(rs1))

\sphinxAtStartPar
rs1 += rs2
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.lw rD, (rs1), rs2}
&
\sphinxAtStartPar
rD = Mem32(rs1)

\sphinxAtStartPar
rs1 += rs2
\\
\sphinxhline\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{2}}
\sphinxAtStartPar
\sphinxstylestrong{Register\sphinxhyphen{}Register Loads}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.lb rD, rs2(rs1)}
&
\sphinxAtStartPar
rD = Sext(Mem8(rs1 + rs2))
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.lbu rD, rs2(rs1)}
&
\sphinxAtStartPar
rD = Zext(Mem8(rs1 + rs2))
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.lh rD, rs2(rs1)}
&
\sphinxAtStartPar
rD = Sext(Mem16(rs1 + rs2))
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.lhu rD, rs2(rs1)}
&
\sphinxAtStartPar
rD = Zext(Mem16(rs1 + rs2))
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.lw rD, rs2(rs1)}
&
\sphinxAtStartPar
rD = Mem32(rs1 + rs2)
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\subsection{Store operations}
\label{\detokenize{instruction_set_extensions:store-operations}}

\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Store operations}\label{\detokenize{instruction_set_extensions:id3}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{30}{100}\X{70}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mnemonic}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{2}}
\sphinxAtStartPar
\sphinxstylestrong{Register\sphinxhyphen{}Immediate Stores with Post\sphinxhyphen{}Increment}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.sb rs2, (rs1), Imm}
&
\sphinxAtStartPar
Mem8(rs1) = rs2

\sphinxAtStartPar
rs1 += Sext(Imm{[}11:0{]})
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.sh rs2, (rs1), Imm}
&
\sphinxAtStartPar
Mem16(rs1) = rs2

\sphinxAtStartPar
rs1 += Sext(Imm{[}11:0{]})
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.sw rs2, (rs1), Imm}
&
\sphinxAtStartPar
Mem32(rs1) = rs2

\sphinxAtStartPar
rs1 += Sext(Imm{[}11:0{]})
\\
\sphinxhline\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{2}}
\sphinxAtStartPar
\sphinxstylestrong{Register\sphinxhyphen{}Register Stores with Post\sphinxhyphen{}Increment}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.sb rs2, (rs1), rs3}
&
\sphinxAtStartPar
Mem8(rs1) = rs2

\sphinxAtStartPar
rs1 += rs3
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.sh rs2, (rs1), rs3}
&
\sphinxAtStartPar
Mem16(rs1) = rs2

\sphinxAtStartPar
rs1 += rs3
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.sw rs2, (rs1), rs3}
&
\sphinxAtStartPar
Mem32(rs1) = rs2

\sphinxAtStartPar
rs1 += rs3
\\
\sphinxhline\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{2}}
\sphinxAtStartPar
\sphinxstylestrong{Register\sphinxhyphen{}Register Stores}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.sb rs2, rs3(rs1)}
&
\sphinxAtStartPar
Mem8(rs1 + rs3) = rs2
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.sh rs2 rs3(rs1)}
&
\sphinxAtStartPar
Mem16(rs1 + rs3) = rs2
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.sw rs2, rs3(rs1)}
&
\sphinxAtStartPar
Mem32(rs1 + rs3) = rs2
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\subsection{Encoding}
\label{\detokenize{instruction_set_extensions:encoding}}

\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Post\sphinxhyphen{}Increment Register\sphinxhyphen{}Immediate Load operations encoding}\label{\detokenize{instruction_set_extensions:post-increment-register-immediate-load-operations-encoding}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{25}{100}\X{10}{100}\X{10}{100}\X{15}{100}\X{15}{100}\X{25}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
31    :    20
&\sphinxstyletheadfamily 
\sphinxAtStartPar
19 : 15
&\sphinxstyletheadfamily 
\sphinxAtStartPar
14   :  12
&\sphinxstyletheadfamily 
\sphinxAtStartPar
11 : 7
&\sphinxstyletheadfamily 
\sphinxAtStartPar
6    :   0
&\sphinxstyletheadfamily \\
\sphinxhline\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{imm{[}11:0{]}}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rs1}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{funct3}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rD}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{opcode}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mnemonic}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
offset
&
\sphinxAtStartPar
base
&
\sphinxAtStartPar
000
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
000 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.lb rD, (rs1), Imm}
\\
\sphinxhline
\sphinxAtStartPar
offset
&
\sphinxAtStartPar
base
&
\sphinxAtStartPar
100
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
000 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.lbu rD, (rs1), Imm}
\\
\sphinxhline
\sphinxAtStartPar
offset
&
\sphinxAtStartPar
base
&
\sphinxAtStartPar
001
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
000 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.lh rD, (rs1), Imm}
\\
\sphinxhline
\sphinxAtStartPar
offset
&
\sphinxAtStartPar
base
&
\sphinxAtStartPar
101
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
000 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.lhu rD, (rs1), Imm}
\\
\sphinxhline
\sphinxAtStartPar
offset
&
\sphinxAtStartPar
base
&
\sphinxAtStartPar
010
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
000 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.lw rD, (rs1), Imm}
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Post\sphinxhyphen{}Increment Register\sphinxhyphen{}Register Load operations encoding}\label{\detokenize{instruction_set_extensions:post-increment-register-register-load-operations-encoding}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{15}{100}\X{10}{100}\X{10}{100}\X{10}{100}\X{15}{100}\X{15}{100}\X{25}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
31  :   25
&\sphinxstyletheadfamily 
\sphinxAtStartPar
24  : 20
&\sphinxstyletheadfamily 
\sphinxAtStartPar
19 : 15
&\sphinxstyletheadfamily 
\sphinxAtStartPar
14   :  12
&\sphinxstyletheadfamily 
\sphinxAtStartPar
11 : 7
&\sphinxstyletheadfamily 
\sphinxAtStartPar
6   :    0
&\sphinxstyletheadfamily \\
\sphinxhline\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{funct7}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rs2}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rs1}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{funct3}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rD}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{opcode}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mnemonic}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
000 0000
&
\sphinxAtStartPar
offset
&
\sphinxAtStartPar
base
&
\sphinxAtStartPar
011
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.lb rD, (rs1), rs2}
\\
\sphinxhline
\sphinxAtStartPar
000 1000
&
\sphinxAtStartPar
offset
&
\sphinxAtStartPar
base
&
\sphinxAtStartPar
011
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.lbu rD, (rs1), rs2}
\\
\sphinxhline
\sphinxAtStartPar
000 0001
&
\sphinxAtStartPar
offset
&
\sphinxAtStartPar
base
&
\sphinxAtStartPar
011
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.lh rD, (rs1), rs2}
\\
\sphinxhline
\sphinxAtStartPar
000 1001
&
\sphinxAtStartPar
offset
&
\sphinxAtStartPar
base
&
\sphinxAtStartPar
011
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.lhu rD, (rs1), rs2}
\\
\sphinxhline
\sphinxAtStartPar
000 0010
&
\sphinxAtStartPar
offset
&
\sphinxAtStartPar
base
&
\sphinxAtStartPar
011
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.lw rD, (rs1), rs2}
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Register\sphinxhyphen{}Register Load operations encoding}\label{\detokenize{instruction_set_extensions:register-register-load-operations-encoding}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{15}{100}\X{10}{100}\X{10}{100}\X{10}{100}\X{15}{100}\X{15}{100}\X{25}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
31  :   25
&\sphinxstyletheadfamily 
\sphinxAtStartPar
24  : 20
&\sphinxstyletheadfamily 
\sphinxAtStartPar
19 : 15
&\sphinxstyletheadfamily 
\sphinxAtStartPar
14   :  12
&\sphinxstyletheadfamily 
\sphinxAtStartPar
11 : 7
&\sphinxstyletheadfamily 
\sphinxAtStartPar
6   :    0
&\sphinxstyletheadfamily \\
\sphinxhline\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{funct7}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rs2}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rs1}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{funct3}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rD}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{opcode}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mnemonic}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
000 0100
&
\sphinxAtStartPar
offset
&
\sphinxAtStartPar
base
&
\sphinxAtStartPar
011
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.lb rD, rs2(rs1)}
\\
\sphinxhline
\sphinxAtStartPar
000 1100
&
\sphinxAtStartPar
offset
&
\sphinxAtStartPar
base
&
\sphinxAtStartPar
011
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.lbu rD, rs2(rs1)}
\\
\sphinxhline
\sphinxAtStartPar
000 0101
&
\sphinxAtStartPar
offset
&
\sphinxAtStartPar
base
&
\sphinxAtStartPar
011
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.lh rD, rs2(rs1)}
\\
\sphinxhline
\sphinxAtStartPar
000 1101
&
\sphinxAtStartPar
offset
&
\sphinxAtStartPar
base
&
\sphinxAtStartPar
011
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.lhu rD, rs2(rs1)}
\\
\sphinxhline
\sphinxAtStartPar
000 0110
&
\sphinxAtStartPar
offset
&
\sphinxAtStartPar
base
&
\sphinxAtStartPar
011
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.lw rD, rs2(rs1)}
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Post\sphinxhyphen{}Increment Register\sphinxhyphen{}Immediate Store operations encoding}\label{\detokenize{instruction_set_extensions:post-increment-register-immediate-store-operations-encoding}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{15}{100}\X{10}{100}\X{10}{100}\X{10}{100}\X{15}{100}\X{15}{100}\X{25}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
31    :     25
&\sphinxstyletheadfamily 
\sphinxAtStartPar
24 : 20
&\sphinxstyletheadfamily 
\sphinxAtStartPar
19 : 15
&\sphinxstyletheadfamily 
\sphinxAtStartPar
14   :  12
&\sphinxstyletheadfamily 
\sphinxAtStartPar
11     :    7
&\sphinxstyletheadfamily 
\sphinxAtStartPar
6    :   0
&\sphinxstyletheadfamily \\
\sphinxhline\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{imm{[}11:5{]}}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rs2}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rs1}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{funct3}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{imm{[}4:0{]}}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{opcode}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mnemonic}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
offset{[}11:5{]}
&
\sphinxAtStartPar
src
&
\sphinxAtStartPar
base
&
\sphinxAtStartPar
000
&
\sphinxAtStartPar
offset{[}4:0{]}
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.sb rs2, (rs1), Imm}
\\
\sphinxhline
\sphinxAtStartPar
offset{[}11:5{]}
&
\sphinxAtStartPar
src
&
\sphinxAtStartPar
base
&
\sphinxAtStartPar
001
&
\sphinxAtStartPar
offset{[}4:0{]}
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.sh rs2, (rs1), Imm}
\\
\sphinxhline
\sphinxAtStartPar
offset{[}11:5{]}
&
\sphinxAtStartPar
src
&
\sphinxAtStartPar
base
&
\sphinxAtStartPar
010
&
\sphinxAtStartPar
offset{[}4:0{]}
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.sw rs2, (rs1), Imm}
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Post\sphinxhyphen{}Increment Register\sphinxhyphen{}Register Store operations encoding}\label{\detokenize{instruction_set_extensions:post-increment-register-register-store-operations-encoding}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{15}{100}\X{10}{100}\X{10}{100}\X{10}{100}\X{15}{100}\X{15}{100}\X{25}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
31  :   25
&\sphinxstyletheadfamily 
\sphinxAtStartPar
24  : 20
&\sphinxstyletheadfamily 
\sphinxAtStartPar
19 : 15
&\sphinxstyletheadfamily 
\sphinxAtStartPar
14   :  12
&\sphinxstyletheadfamily 
\sphinxAtStartPar
11 : 7
&\sphinxstyletheadfamily 
\sphinxAtStartPar
6    :   0
&\sphinxstyletheadfamily \\
\sphinxhline\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{funct7}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rs2}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rs1}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{funct3}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rs3}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{opcode}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mnemonic}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
001 0000
&
\sphinxAtStartPar
src
&
\sphinxAtStartPar
base
&
\sphinxAtStartPar
011
&
\sphinxAtStartPar
offset
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.sb rs2, (rs1), rs3}
\\
\sphinxhline
\sphinxAtStartPar
001 0001
&
\sphinxAtStartPar
src
&
\sphinxAtStartPar
base
&
\sphinxAtStartPar
011
&
\sphinxAtStartPar
offset
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.sh rs2, (rs1), rs3}
\\
\sphinxhline
\sphinxAtStartPar
001 0010
&
\sphinxAtStartPar
src
&
\sphinxAtStartPar
base
&
\sphinxAtStartPar
011
&
\sphinxAtStartPar
offse t
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.sw rs2, (rs1), rs3}
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Register\sphinxhyphen{}Register Store operations encoding}\label{\detokenize{instruction_set_extensions:register-register-store-operations-encoding}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{15}{100}\X{10}{100}\X{10}{100}\X{10}{100}\X{15}{100}\X{15}{100}\X{25}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
31  :   25
&\sphinxstyletheadfamily 
\sphinxAtStartPar
24 :  20
&\sphinxstyletheadfamily 
\sphinxAtStartPar
19 : 15
&\sphinxstyletheadfamily 
\sphinxAtStartPar
14   :  12
&\sphinxstyletheadfamily 
\sphinxAtStartPar
11  : 7
&\sphinxstyletheadfamily 
\sphinxAtStartPar
6    :   0
&\sphinxstyletheadfamily \\
\sphinxhline\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{funct7}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rs2}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rs1}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{funct3}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rs3}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{opcode}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mnemonic}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
001 0100
&
\sphinxAtStartPar
src
&
\sphinxAtStartPar
base
&
\sphinxAtStartPar
011
&
\sphinxAtStartPar
offset
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.sb rs2, rs3(rs1)}
\\
\sphinxhline
\sphinxAtStartPar
001 0101
&
\sphinxAtStartPar
src
&
\sphinxAtStartPar
base
&
\sphinxAtStartPar
011
&
\sphinxAtStartPar
offset
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.sh rs2, rs3(rs1)}
\\
\sphinxhline
\sphinxAtStartPar
001 0110
&
\sphinxAtStartPar
src
&
\sphinxAtStartPar
base
&
\sphinxAtStartPar
011
&
\sphinxAtStartPar
offset
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.sw rs2, rs3(rs1)}
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\section{Event Load Instruction}
\label{\detokenize{instruction_set_extensions:event-load-instruction}}\label{\detokenize{instruction_set_extensions:corev-event-load}}
\sphinxAtStartPar
The event load instruction \sphinxstylestrong{cv.elw} is only supported if the \sphinxcode{\sphinxupquote{COREV\_CLUSTER}} parameter is set to 1.
The event load performs a load word and can cause the CV32E40P to enter a sleep state as explained
in {\hyperref[\detokenize{sleep:pulp-cluster}]{\sphinxcrossref{\DUrole{std,std-ref}{PULP Cluster Extension}}}}.


\subsection{Event Load operation}
\label{\detokenize{instruction_set_extensions:event-load-operation}}

\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Event Load operation}\label{\detokenize{instruction_set_extensions:id4}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{30}{100}\X{70}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mnemonic}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{2}}
\sphinxAtStartPar
\sphinxstylestrong{Event Load}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.elw rD, Imm(rs1)}
&
\sphinxAtStartPar
rD = Mem32(Sext(Imm) + rs1)
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\subsection{Encoding}
\label{\detokenize{instruction_set_extensions:id5}}

\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Event Load operation encoding}\label{\detokenize{instruction_set_extensions:event-load-operation-encoding}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{25}{100}\X{10}{100}\X{10}{100}\X{15}{100}\X{15}{100}\X{25}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
31     :   20
&\sphinxstyletheadfamily 
\sphinxAtStartPar
19 : 15
&\sphinxstyletheadfamily 
\sphinxAtStartPar
14   :  12
&\sphinxstyletheadfamily 
\sphinxAtStartPar
11 : 7
&\sphinxstyletheadfamily 
\sphinxAtStartPar
6   :    0
&\sphinxstyletheadfamily \\
\sphinxhline\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{imm{[}11:0{]}}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rs1}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{funct3}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rD}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{opcode}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mnemonic}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
offset
&
\sphinxAtStartPar
base
&
\sphinxAtStartPar
011
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
000 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.elw rD, Imm(rs1)}
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\section{Hardware Loops}
\label{\detokenize{instruction_set_extensions:hardware-loops}}\label{\detokenize{instruction_set_extensions:corev-hardware-loop}}
\sphinxAtStartPar
The loop has to be setup before entering the loop body. For this purpose, there are two
methods, either the long commands that separately set start\sphinxhyphen{} and
end\sphinxhyphen{}addresses of the loop and the number of iterations, or the short
command that does all of this in a single instruction. The short command
has a limited range for the number of instructions contained in the loop
and the loop must start in the next instruction after the setup
instruction.

\sphinxAtStartPar
Due to start/end addresses constraint, the 2 LSBs are hardwired to 0.
When using cv.start and cv.end instructions, the 2 LSBs of rs1 are ignored.

\sphinxAtStartPar
Hardware loop instructions and related CSRs are only supported if \sphinxcode{\sphinxupquote{COREV\_PULP}} == 1.

\sphinxAtStartPar
Details about the hardware loop constraints are provided in {\hyperref[\detokenize{corev_hw_loop:hwloop-specs}]{\sphinxcrossref{\DUrole{std,std-ref}{CORE\sphinxhyphen{}V Hardware Loop feature}}}}.

\sphinxAtStartPar
In the following tables, the hardware loop instructions are reported.
In assembly, \sphinxstylestrong{L} is referred by 0 or 1.


\subsection{Hardware Loops operations}
\label{\detokenize{instruction_set_extensions:hardware-loops-operations}}

\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Long Hardware Loop Setup operations}\label{\detokenize{instruction_set_extensions:long-hardware-loop-setup-operations}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{30}{100}\X{70}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mnemonic}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxstylestrong{cv.starti L, uimmL}
&
\sphinxAtStartPar
lpstart{[}L{]} = PC + (uimmL \textless{}\textless{} 2)
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.start L, rs1}
&
\sphinxAtStartPar
lpstart{[}L{]} = rs1
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.endi L, uimmL}
&
\sphinxAtStartPar
lpend{[}L{]} = PC + (uimmL \textless{}\textless{} 2)
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.end L, rs1}
&
\sphinxAtStartPar
lpend{[}L{]} = rs1
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.counti L, uimmL}
&
\sphinxAtStartPar
lpcount{[}L{]} = uimmL
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.count L, rs1}
&
\sphinxAtStartPar
lpcount{[}L{]} = rs1
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Short Hardware Loop Setup operations}\label{\detokenize{instruction_set_extensions:short-hardware-loop-setup-operations}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{30}{100}\X{70}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mnemonic}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxstylestrong{cv.setupi L, uimmL, uimmS}
&
\sphinxAtStartPar
lpstart{[}L{]} = PC + 4

\sphinxAtStartPar
lpend{[}L{]} = PC + (uimmS \textless{}\textless{} 2)

\sphinxAtStartPar
lpcount{[}L{]} = uimmL
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.setup L, rs1, uimmL}
&
\sphinxAtStartPar
lpstart{[}L{]} = PC + 4

\sphinxAtStartPar
lpend{[}L{]} = PC + (uimmL \textless{}\textless{} 2)

\sphinxAtStartPar
lpcount{[}L{]} = rs1
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\subsection{Encoding}
\label{\detokenize{instruction_set_extensions:id6}}

\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Hardware Loops operations encoding}\label{\detokenize{instruction_set_extensions:hardware-loops-operations-encoding}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{17}{100}\X{15}{100}\X{10}{100}\X{10}{100}\X{5}{100}\X{15}{100}\X{28}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
31   :   20
&\sphinxstyletheadfamily 
\sphinxAtStartPar
19 : 15
&\sphinxstyletheadfamily 
\sphinxAtStartPar
14   :  12
&\sphinxstyletheadfamily 
\sphinxAtStartPar
11   :   8
&\sphinxstyletheadfamily 
\sphinxAtStartPar
7
&\sphinxstyletheadfamily 
\sphinxAtStartPar
6   :    0
&\sphinxstyletheadfamily \\
\sphinxhline\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{uimmL{[}11:0{]}}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rs1}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{funct3}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{funct4}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{L}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{opcode}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mnemonic}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
uimmL{[}11:0{]}
&
\sphinxAtStartPar
00000
&
\sphinxAtStartPar
100
&
\sphinxAtStartPar
0000
&
\sphinxAtStartPar
L
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.starti L, uimmL}
\\
\sphinxhline
\sphinxAtStartPar
0000 0000 0000
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
100
&
\sphinxAtStartPar
0001
&
\sphinxAtStartPar
L
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.start L, rs1}
\\
\sphinxhline
\sphinxAtStartPar
uimmL{[}11:0{]}
&
\sphinxAtStartPar
00000
&
\sphinxAtStartPar
100
&
\sphinxAtStartPar
0010
&
\sphinxAtStartPar
L
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.endi L, uimmL}
\\
\sphinxhline
\sphinxAtStartPar
0000 0000 0000
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
100
&
\sphinxAtStartPar
0011
&
\sphinxAtStartPar
L
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.end L, rs1}
\\
\sphinxhline
\sphinxAtStartPar
uimmL{[}11:0{]}
&
\sphinxAtStartPar
00000
&
\sphinxAtStartPar
100
&
\sphinxAtStartPar
0100
&
\sphinxAtStartPar
L
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.counti L, uimmL}
\\
\sphinxhline
\sphinxAtStartPar
0000 0000 0000
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
100
&
\sphinxAtStartPar
0101
&
\sphinxAtStartPar
L
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.count L, rs1}
\\
\sphinxhline
\sphinxAtStartPar
uimmL{[}11:0{]}
&
\sphinxAtStartPar
uimmS{[}4:0{]}
&
\sphinxAtStartPar
100
&
\sphinxAtStartPar
0110
&
\sphinxAtStartPar
L
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.setupi L, uimmL, uimmS}
\\
\sphinxhline
\sphinxAtStartPar
uimmL{[}11:0{]}
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
100
&
\sphinxAtStartPar
0111
&
\sphinxAtStartPar
L
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.setup L, rs1, uimmL}
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\section{ALU}
\label{\detokenize{instruction_set_extensions:alu}}\label{\detokenize{instruction_set_extensions:corev-alu}}
\sphinxAtStartPar
CV32E40P supports advanced ALU operations that allow to perform multiple
instructions that are specified in the base instruction set in one
single instruction and thus increases efficiency of the core. For
example, those instructions include zero\sphinxhyphen{}/sign\sphinxhyphen{}extension instructions
for 8\sphinxhyphen{}bit and 16\sphinxhyphen{}bit operands, simple bit manipulation/counting
instructions and min/max/avg instructions. The ALU does also support
saturating, clipping and normalizing instructions which make fixed\sphinxhyphen{}point
arithmetic more efficient.

\sphinxAtStartPar
The custom ALU extensions are only supported if \sphinxcode{\sphinxupquote{COREV\_PULP}} == 1.

\sphinxAtStartPar
The custom extensions to the ALU are split into several subgroups that belong
together.
\begin{itemize}
\item {} 
\sphinxAtStartPar
Bit manipulation instructions are useful to work on single bits or
groups of bits within a word, see {\hyperref[\detokenize{instruction_set_extensions:corev-bit-manipulation}]{\sphinxcrossref{\DUrole{std,std-ref}{Bit Manipulation operations}}}}.

\item {} 
\sphinxAtStartPar
General ALU instructions try to fuse common used sequences into a
single instruction and thus increase the performance of small kernels
that use those sequence, see {\hyperref[\detokenize{instruction_set_extensions:corev-general-alu}]{\sphinxcrossref{\DUrole{std,std-ref}{General ALU operations}}}}.

\item {} 
\sphinxAtStartPar
Immediate branching instructions are useful to compare a register
with an immediate value before taking or not a branch, see see {\hyperref[\detokenize{instruction_set_extensions:corev-immediate-branching}]{\sphinxcrossref{\DUrole{std,std-ref}{Immediate Branching operations}}}}.

\end{itemize}

\sphinxAtStartPar
Extract, Insert, Clear and Set instructions have the following meaning:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Extract Is3+1 or rs2{[}9:5{]}+1 bits from position Is2 or rs2{[}4:0{]} {[}and sign extend it{]}

\item {} 
\sphinxAtStartPar
Insert Is3+1 or rs2{[}9:5{]}+1 bits at position Is2 or rs2{[}4:0{]}

\item {} 
\sphinxAtStartPar
Clear Is3+1 or rs2{[}9:5{]}+1 bits at position Is2 or rs2{[}4:0{]}

\item {} 
\sphinxAtStartPar
Set Is3+1 or rs2{[}9:5{]}+1 bits at position Is2 or rs2{[}4:0{]}

\end{itemize}


\subsection{Bit Reverse Instruction}
\label{\detokenize{instruction_set_extensions:bit-reverse-instruction}}
\sphinxAtStartPar
This section will describe the \sphinxtitleref{cv.bitrev} instruction from a bit manipulation
perspective without describing it’s application as part of an FFT. The bit
reverse instruction will reverse bits in groupings of 1, 2 or 3 bits. The
number of grouped bits is described by \sphinxstyleemphasis{Is3} as follows:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{0} \sphinxhyphen{} reverse single bits

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{1} \sphinxhyphen{} reverse groups of 2 bits

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{2} \sphinxhyphen{} reverse groups of 3 bits

\end{itemize}

\sphinxAtStartPar
The number of bits that are reversed can be controlled by \sphinxstyleemphasis{Is2}. This will
specify the number of bits that will be removed by a left shift prior to
the reverse operation resulting in the \sphinxstyleemphasis{32\sphinxhyphen{}Is2} least significant bits of
the input value being reversed and the \sphinxstyleemphasis{Is2} most significant bits of the
input value being thrown out.

\sphinxAtStartPar
What follows is a few examples.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
cv.bitrev x18, x20, 0, 4 (groups of 1 bit; radix\PYGZhy{}2)

in:    0xC64A5933 11000110010010100101100100110011
shift: 0x64A59330 01100100101001011001001100110000
out:   0x0CC9A526 00001100110010011010010100100110

Swap pattern:
A B C D E F G H . . . . . . . . . . . . . . . . . . . . . . . .
0 1 1 0 0 1 0 0 1 0 1 0 0 1 0 1 1 0 0 1 0 0 1 1 0 0 1 1 0 0 0 0
. . . . . . . . . . . . . . . . . . . . . . . . H G F E D C B A
0 0 0 0 1 1 0 0 1 1 0 0 1 0 0 1 1 0 1 0 0 1 0 1 0 0 1 0 0 1 1 0
\end{sphinxVerbatim}

\sphinxAtStartPar
In this example the input value is first shifted by 4 (\sphinxstyleemphasis{Is2}). Each individual
bit is reversed. For example, bits 31 and 0 are swapped, 30 and 1, etc.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
cv.bitrev x18, x20, 1, 4 (groups of 2 bits; radix\PYGZhy{}4)

in:    0xC64A5933 11000110010010100101100100110011
shift: 0x64A59330 01100100101001011001001100110000
out:   0x0CC65A19 00001100110001100101101000011001

Swap pattern:
A  B  C  D  E  F  G  H  I  J  K  L  M  N  O  P
01 10 01 00 10 10 01 01 10 01 00 11 00 11 00 00
P  O  N  M  L  K  J  I  H  G  F  E  D  C  B  A
00 00 11 00 11 00 01 10 01 01 10 10 00 01 10 01
\end{sphinxVerbatim}

\sphinxAtStartPar
In this example the input value is first shifted by 4 (\sphinxstyleemphasis{Is2}). Each group of
two bits are reversed. For example, bits 31 and 30 are swapped with 1 and 0
(retaining their position relative to each other), bits 29 and 28 are swapped
with 3 and 2, etc.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
cv.bitrev x18, x20, 2, 4 (groups of 3 bits; radix\PYGZhy{}8)

in:    0xC64A5933 11000110010010100101100100110011
shift: 0x64A59330 01100100101001011001001100110000
out:   0x216B244B 00100001011010110010010001001011

Swap pattern:
A   B   C   D   E   F   G   H   I   J
011 001 001 010 010 110 010 011 001 100 00
   J   I   H   G   F   E   D   C   B   A
00 100 001 011 010 110 010 010 001 001 011
\end{sphinxVerbatim}

\sphinxAtStartPar
In this last example the input value is first shifted by 4 (\sphinxstyleemphasis{Is2}). Each group
of three bits are reversed. For example, bits 31, 30 and 29 are swapped with
4, 3 and 2 (retaining their position relative to each other), bits 28, 27 and
26 are swapped with 7, 6 and 5, etc. Notice in this example that bits 0 and 1
are lost and the result is shifted right by two with bits 31 and 30 being tied
to zero. Also notice that when J (100) is swapped with A (011), the four most
significant bits are no longer zero as in the other cases. This may not be
desirable if the intention is to pack a specific number of grouped bits
aligned to the least significant bit and zero extended into the result. In
this case care should be taken to set \sphinxstyleemphasis{Is2} appropriately.


\subsection{Bit Manipulation operations}
\label{\detokenize{instruction_set_extensions:bit-manipulation-operations}}\label{\detokenize{instruction_set_extensions:corev-bit-manipulation}}

\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Bit Manipulation operations}\label{\detokenize{instruction_set_extensions:id7}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{30}{100}\X{70}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mnemonic}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxstylestrong{cv.extract rD, rs1, Is3, Is2}
&
\sphinxAtStartPar
rD = Sext(rs1{[}min(Is3+Is2,31):Is2{]})

\sphinxAtStartPar
Note: Sign extension is done over the MSB of the extracted part.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.extractu rD, rs1, Is3, Is2}
&
\sphinxAtStartPar
rD = Zext(rs1{[}min(Is3+Is2,31):Is2{]})
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.extractr rD, rs1, rs2}
&
\sphinxAtStartPar
rD = Sext(rs1{[}min(rs2{[}9:5{]}+rs2{[}4:0{]},31):rs2{[}4:0{]}{]})

\sphinxAtStartPar
Note: Sign extension is done over the MSB of the extracted part.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.extractur rD, rs1, rs2}
&
\sphinxAtStartPar
rD = Zext(rs1{[}min(rs2{[}9:5{]}+rs2{[}4:0{]},31):rs2{[}4:0{]}{]})
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.insert rD, rs1, Is3, Is2}
&
\sphinxAtStartPar
rD{[}min(Is3+Is2,31):Is2{]} = rs1{[}Is3\sphinxhyphen{}(max(Is3+Is2,31)\sphinxhyphen{}31):0{]}

\sphinxAtStartPar
The rest of the bits of rD are untouched and keep their previous value.

\sphinxAtStartPar
Is3 + Is2 must be \textless{} 32.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.insertr rD, rs1, rs2}
&
\sphinxAtStartPar
rD{[}min(rs2{[}9:5{]}+rs2{[}4:0{]},31):rs2{[}4:0{]}{]} =

\sphinxAtStartPar
rs1{[}rs2{[}9:5{]}\sphinxhyphen{}(max(rs2{[}9:5{]}+rs2{[}4:0{]},31)\sphinxhyphen{}31):0{]}

\sphinxAtStartPar
The rest of the bits of rD are untouched and keep their previous value.

\sphinxAtStartPar
Is3 + Is2 must be \textless{} 32.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.bclr rD, rs1, Is3, Is2}
&
\sphinxAtStartPar
rD{[}min(Is3+Is2,31):Is2{]} bits set to 0

\sphinxAtStartPar
The rest of the bits of rD are passed through from rs1 and are not modified.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.bclrr rD, rs1, rs2}
&
\sphinxAtStartPar
rD{[}min(rs2{[}9:5{]}+rs2{[}4:0{]},31):rs2{[}4:0{]}{]} bits set to 0

\sphinxAtStartPar
The rest of the bits of rD are passed through from rs1 and are not modified.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.bset rD, rs1, Is3, Is2}
&
\sphinxAtStartPar
rD{[}min(Is3+Is2,31):Is2{]} bits set to 1

\sphinxAtStartPar
The rest of the bits of rD are passed through from rs1 and are not modified.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.bsetr rD, rs1, rs2}
&
\sphinxAtStartPar
rD{[}min(rs2{[}9:5{]}+rs2{[}4:0{]},31):rs2{[}4:0{]}{]} bits set to 1

\sphinxAtStartPar
The rest of the bits of rD are passed through from rs1 and are not modified.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.ff1 rD, rs1}
&
\sphinxAtStartPar
rD = bit position of the first bit set in rs1, starting from LSB.

\sphinxAtStartPar
If bit 0 is set, rD will be 0. If only bit 31 is set, rD will be 31.

\sphinxAtStartPar
If rs1 is 0, rD will be 32.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.fl1 rD, rs1}
&
\sphinxAtStartPar
rD = bit position of the last bit set in rs1, starting from MSB.

\sphinxAtStartPar
If bit 31 is set, rD will be 31. If only bit 0 is set, rD will be 0.

\sphinxAtStartPar
If rs1 is 0, rD will be 32.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.clb rD, rs1}
&
\sphinxAtStartPar
rD = count leading bits of rs1

\sphinxAtStartPar
Number of consecutive 1’s or 0’s starting from MSB.

\sphinxAtStartPar
If rs1 is 0, rD will be 0. If rs1 is different than 0, returns (number \sphinxhyphen{} 1).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.cnt rD, rs1}
&
\sphinxAtStartPar
rD = Population count of rs1

\sphinxAtStartPar
Number of bits set in rs1.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.ror rD, rs1, rs2}
&
\sphinxAtStartPar
rD = RotateRight(rs1, rs2)
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.bitrev rD, rs1, Is3, Is2}
&
\sphinxAtStartPar
Given an input rs1 it returns a bit reversed representation assuming

\sphinxAtStartPar
FFT on 2\textasciicircum{}Is2 points in Radix 2\textasciicircum{}(Is3+1).

\sphinxAtStartPar
Is3 can be either 0 (radix\sphinxhyphen{}2), 1 (radix\sphinxhyphen{}4) or 2 (radix\sphinxhyphen{}8).

\sphinxAtStartPar
Note:  When Is3 = 3, instruction has the same bahavior as if it was 0 (radix\sphinxhyphen{}2).
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\subsection{Bit Manipulation Encoding}
\label{\detokenize{instruction_set_extensions:bit-manipulation-encoding}}

\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Immediate Bit Manipulation operations encoding}\label{\detokenize{instruction_set_extensions:immediate-bit-manipulation-operations-encoding}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{5}{100}\X{14}{100}\X{13}{100}\X{5}{100}\X{8}{100}\X{6}{100}\X{16}{100}\X{33}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
31: 30
&\sphinxstyletheadfamily 
\sphinxAtStartPar
29       :        25
&\sphinxstyletheadfamily 
\sphinxAtStartPar
24    :    20
&\sphinxstyletheadfamily 
\sphinxAtStartPar
19 : 15
&\sphinxstyletheadfamily 
\sphinxAtStartPar
14   :  12
&\sphinxstyletheadfamily 
\sphinxAtStartPar
11 : 7
&\sphinxstyletheadfamily 
\sphinxAtStartPar
6    :   0
&\sphinxstyletheadfamily \\
\sphinxhline\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{f2}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Is3{[}4:0{]}}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Is2{[}4:0{]}}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rs1}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{funct3}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rD}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{opcode}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mnemonic}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
00
&
\sphinxAtStartPar
Luimm5{[}4:0{]}
&
\sphinxAtStartPar
Luimm5{[}4:0{]}
&
\sphinxAtStartPar
src
&
\sphinxAtStartPar
000
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
101 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.extract rD, rs1, Is3, Is2}
\\
\sphinxhline
\sphinxAtStartPar
01
&
\sphinxAtStartPar
Luimm5{[}4:0{]}
&
\sphinxAtStartPar
Luimm5{[}4:0{]}
&
\sphinxAtStartPar
src
&
\sphinxAtStartPar
000
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
101 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.extractu rD, rs1, Is3, Is2}
\\
\sphinxhline
\sphinxAtStartPar
10
&
\sphinxAtStartPar
Luimm5{[}4:0{]}
&
\sphinxAtStartPar
Luimm5{[}4:0{]}
&
\sphinxAtStartPar
src
&
\sphinxAtStartPar
000
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
101 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.insert rD, rs1, Is3, Is2}
\\
\sphinxhline
\sphinxAtStartPar
00
&
\sphinxAtStartPar
Luimm5{[}4:0{]}
&
\sphinxAtStartPar
Luimm5{[}4:0{]}
&
\sphinxAtStartPar
src
&
\sphinxAtStartPar
001
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
101 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.bclr rD, rs1, Is3, Is2}
\\
\sphinxhline
\sphinxAtStartPar
01
&
\sphinxAtStartPar
Luimm5{[}4:0{]}
&
\sphinxAtStartPar
Luimm5{[}4:0{]}
&
\sphinxAtStartPar
src
&
\sphinxAtStartPar
001
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
101 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.bset rD, rs1, Is3, Is2}
\\
\sphinxhline
\sphinxAtStartPar
11
&
\sphinxAtStartPar
000, Luimm2{[}1:0{]}
&
\sphinxAtStartPar
Luimm5{[}4:0{]}
&
\sphinxAtStartPar
src
&
\sphinxAtStartPar
001
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
101 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.bitrev rD, rs1, Is3, Is2}
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Register Bit Manipulation operations encoding}\label{\detokenize{instruction_set_extensions:register-bit-manipulation-operations-encoding}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{19}{100}\X{13}{100}\X{5}{100}\X{8}{100}\X{6}{100}\X{16}{100}\X{33}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
31   :  25
&\sphinxstyletheadfamily 
\sphinxAtStartPar
24 : 20
&\sphinxstyletheadfamily 
\sphinxAtStartPar
19 : 15
&\sphinxstyletheadfamily 
\sphinxAtStartPar
14   :  12
&\sphinxstyletheadfamily 
\sphinxAtStartPar
11 : 7
&\sphinxstyletheadfamily 
\sphinxAtStartPar
6   :    0
&\sphinxstyletheadfamily \\
\sphinxhline\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{funct7}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rs2}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rs1}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{funct3}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rD}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{opcode}
&\sphinxstyletheadfamily \\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
001 1000
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
011
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.extractr rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
001 1001
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
011
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.extractur rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
001 1010
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
011
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.insertr rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
001 1100
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
011
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.bclrr rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
001 1101
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
scr1
&
\sphinxAtStartPar
011
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.bsetr rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
010 0000
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
011
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.ror rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
010 0001
&
\sphinxAtStartPar
00000
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
011
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.ff1 rD, rs1}
\\
\sphinxhline
\sphinxAtStartPar
010 0010
&
\sphinxAtStartPar
00000
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
011
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.fl1 rD, rs1}
\\
\sphinxhline
\sphinxAtStartPar
010 0011
&
\sphinxAtStartPar
00000
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
011
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.clb rD, rs1}
\\
\sphinxhline
\sphinxAtStartPar
010 0100
&
\sphinxAtStartPar
00000
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
011
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cnt rD, rs1}
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\subsection{General ALU operations}
\label{\detokenize{instruction_set_extensions:general-alu-operations}}\label{\detokenize{instruction_set_extensions:corev-general-alu}}

\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{30}{100}\X{70}{100}}
\sphinxthelongtablecaptionisattop
\caption{General ALU operations\strut}\label{\detokenize{instruction_set_extensions:id8}}\\*[\sphinxlongtablecapskipadjust]
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mnemonic}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mnemonic}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
\sphinxstylestrong{cv.abs rD, rs1}
&
\sphinxAtStartPar
rD = rs1 \textless{} 0 ? \sphinxhyphen{}rs1 : rs1
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.sle rD, rs1, rs2}
&
\sphinxAtStartPar
rD = rs1 \textless{}= rs2 ? 1 : 0

\sphinxAtStartPar
Note: Comparison is signed.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.sleu rD, rs1, rs2}
&
\sphinxAtStartPar
rD = rs1 \textless{}= rs2 ? 1 : 0

\sphinxAtStartPar
Note: Comparison is unsigned.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.min rD, rs1, rs2}
&
\sphinxAtStartPar
rD = rs1 \textless{} rs2 ? rs1 : rs2

\sphinxAtStartPar
Note: Comparison is signed.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.minu rD, rs1, rs2}
&
\sphinxAtStartPar
rD = rs1 \textless{} rs2 ? rs1 : rs2

\sphinxAtStartPar
Note: Comparison is unsigned.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.max rD, rs1, rs2}
&
\sphinxAtStartPar
rD = rs1 \textless{} rs2 ? rs2 : rs1

\sphinxAtStartPar
Note: Comparison is signed.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.maxu rD, rs1, rs2}
&
\sphinxAtStartPar
rD = rs1 \textless{} rs2 ? rs2 : rs1

\sphinxAtStartPar
Note: Comparison is unsigned.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.exths rD, rs1}
&
\sphinxAtStartPar
rD = Sext(rs1{[}15:0{]})
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.exthz rD, rs1}
&
\sphinxAtStartPar
rD = Zext(rs1{[}15:0{]})
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.extbs rD, rs1}
&
\sphinxAtStartPar
rD = Sext(rs1{[}7:0{]})
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.extbz rD, rs1}
&
\sphinxAtStartPar
rD = Zext(rs1{[}7:0{]})
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.clip rD, rs1, Is2}
&
\sphinxAtStartPar
if rs1 \textless{}= \sphinxhyphen{}2\textasciicircum{}(Is2\sphinxhyphen{}1), rD = \sphinxhyphen{}2\textasciicircum{}(Is2\sphinxhyphen{}1),

\sphinxAtStartPar
else if rs1 \textgreater{}= 2\textasciicircum{}(Is2\sphinxhyphen{}1)\sphinxhyphen{}1, rD = 2\textasciicircum{}(Is2\sphinxhyphen{}1)\sphinxhyphen{}1,

\sphinxAtStartPar
else rD = rs1

\sphinxAtStartPar
Note: If Is2 is equal to 0,

\sphinxAtStartPar
\sphinxhyphen{}2\textasciicircum{}(Is2\sphinxhyphen{}1) is equivalent to \sphinxhyphen{}1 while (2\textasciicircum{}(Is2\sphinxhyphen{}1)\sphinxhyphen{}1) is equivalent to 0.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.clipu rD, rs1, Is2}
&
\sphinxAtStartPar
if rs1 \textless{}= 0, rD = 0,

\sphinxAtStartPar
else if rs1 \textgreater{}= 2\textasciicircum{}(Is2\sphinxhyphen{}1)\sphinxhyphen{}1, rD = 2\textasciicircum{}(Is2\sphinxhyphen{}1)\sphinxhyphen{}1,

\sphinxAtStartPar
else rD = rs1

\sphinxAtStartPar
Note: If Is2 is equal to 0, (2\textasciicircum{}(Is2\sphinxhyphen{}1)\sphinxhyphen{}1) is equivalent to 0.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.clipr rD, rs1, rs2}
&
\sphinxAtStartPar
if rs1 \textless{}= \sphinxhyphen{}(rs2+1), rD = \sphinxhyphen{}(rs2+1),

\sphinxAtStartPar
else if rs1 \textgreater{}=rs2, rD = rs2,

\sphinxAtStartPar
else rD = rs1

\sphinxAtStartPar
Note: rs2 is unsigned.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.clipur rD, rs1, rs2}
&
\sphinxAtStartPar
if rs1 \textless{}= 0, rD = 0,

\sphinxAtStartPar
else if rs1 \textgreater{}= rs2, rD = rs2,

\sphinxAtStartPar
else rD = rs1

\sphinxAtStartPar
Note: rs2 is unsigned.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.addN rD, rs1, rs2, Is3}
&
\sphinxAtStartPar
rD = (rs1 + rs2) \textgreater{}\textgreater{}\textgreater{} Is3

\sphinxAtStartPar
Note: Arithmetic shift right.

\sphinxAtStartPar
Setting Is3 to 1 replaces former cv.avg.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.adduN rD, rs1, rs2, Is3}
&
\sphinxAtStartPar
rD = (rs1 + rs2) \textgreater{}\textgreater{} Is3

\sphinxAtStartPar
Note: Logical shift right.

\sphinxAtStartPar
Setting Is3 to 1 replaces former cv.avgu.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.addRN rD, rs1, rs2, Is3}
&
\sphinxAtStartPar
rD = (rs1 + rs2 + 2\textasciicircum{}(Is3\sphinxhyphen{}1)) \textgreater{}\textgreater{}\textgreater{} Is3

\sphinxAtStartPar
Note: Arithmetic shift right.

\sphinxAtStartPar
If Is3 is equal to 0, 2\textasciicircum{}(Is3\sphinxhyphen{}1) is equivalent to 0.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.adduRN rD, rs1, rs2, Is3}
&
\sphinxAtStartPar
rD = (rs1 + rs2 + 2\textasciicircum{}(Is3\sphinxhyphen{}1))) \textgreater{}\textgreater{} Is3

\sphinxAtStartPar
Note: Logical shift right.

\sphinxAtStartPar
If Is3 is equal to 0, 2\textasciicircum{}(Is3\sphinxhyphen{}1) is equivalent to 0.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.subN rD, rs1, rs2, Is3}
&
\sphinxAtStartPar
rD = (rs1 \sphinxhyphen{} rs2) \textgreater{}\textgreater{}\textgreater{} Is3

\sphinxAtStartPar
Note: Arithmetic shift right.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.subuN rD, rs1, rs2, Is3}
&
\sphinxAtStartPar
rD = (rs1 \sphinxhyphen{} rs2) \textgreater{}\textgreater{} Is3

\sphinxAtStartPar
Note: Logical shift right.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.subRN rD, rs1, rs2, Is3}
&
\sphinxAtStartPar
rD = (rs1 \sphinxhyphen{} rs2 + 2\textasciicircum{}(Is3\sphinxhyphen{}1)) \textgreater{}\textgreater{}\textgreater{} Is3

\sphinxAtStartPar
Note: Arithmetic shift right.

\sphinxAtStartPar
If Is3 is equal to 0, 2\textasciicircum{}(Is3\sphinxhyphen{}1) is equivalent to 0.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.subuRN rD, rs1, rs2, Is3}
&
\sphinxAtStartPar
rD = (rs1 \sphinxhyphen{} rs2 + 2\textasciicircum{}(Is3\sphinxhyphen{}1))) \textgreater{}\textgreater{} Is3

\sphinxAtStartPar
Note: Logical shift right.

\sphinxAtStartPar
If Is3 is equal to 0, 2\textasciicircum{}(Is3\sphinxhyphen{}1) is equivalent to 0.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.addNr rD, rs1, rs2}
&
\sphinxAtStartPar
rD = (rD + rs1) \textgreater{}\textgreater{}\textgreater{} rs2{[}4:0{]}

\sphinxAtStartPar
Note: Arithmetic shift right.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.adduNr rD, rs1, rs2}
&
\sphinxAtStartPar
rD = (rD + rs1) \textgreater{}\textgreater{} rs2{[}4:0{]}

\sphinxAtStartPar
Note: Logical shift right.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.addRNr rD, rs1, rs2}
&
\sphinxAtStartPar
rD = (rD + rs1 + 2\textasciicircum{}(rs2{[}4:0{]}\sphinxhyphen{}1)) \textgreater{}\textgreater{}\textgreater{} rs2{[}4:0{]}

\sphinxAtStartPar
Note: Arithmetic shift right.

\sphinxAtStartPar
If rs2{[}4:0{]} is equal to 0, 2\textasciicircum{}(rs2{[}4:0{]}\sphinxhyphen{}1) is equivalent to 0.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.adduRNr rD, rs1, rs2}
&
\sphinxAtStartPar
rD = (rD + rs1 + 2\textasciicircum{}(rs2{[}4:0{]}\sphinxhyphen{}1))) \textgreater{}\textgreater{} rs2{[}4:0{]}

\sphinxAtStartPar
Note: Logical shift right.

\sphinxAtStartPar
If rs2{[}4:0{]} is equal to 0, 2\textasciicircum{}(rs2{[}4:0{]}\sphinxhyphen{}1) is equivalent to 0.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.subNr rD, rs1, rs2}
&
\sphinxAtStartPar
rD = (rD \sphinxhyphen{} rs1) \textgreater{}\textgreater{}\textgreater{} rs2{[}4:0{]}

\sphinxAtStartPar
Note: Arithmetic shift right.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.subuNr rD, rs1, rs2}
&
\sphinxAtStartPar
rD = (rD \sphinxhyphen{} rs1) \textgreater{}\textgreater{} rs2{[}4:0{]}

\sphinxAtStartPar
Note: Logical shift right.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.subRNr rD, rs1, rs2}
&
\sphinxAtStartPar
rD = (rD \sphinxhyphen{} rs1+ 2\textasciicircum{}(rs2{[}4:0{]}\sphinxhyphen{}1)) \textgreater{}\textgreater{}\textgreater{} rs2{[}4:0{]}

\sphinxAtStartPar
Note: Arithmetic shift right.

\sphinxAtStartPar
If rs2{[}4:0{]} is equal to 0, 2\textasciicircum{}(rs2{[}4:0{]}\sphinxhyphen{}1) is equivalent to 0.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.subuRNr rD, rs1, rs2}
&
\sphinxAtStartPar
rD = (rD \sphinxhyphen{} rs1+ 2\textasciicircum{}(rs2{[}4:0{]}\sphinxhyphen{}1))) \textgreater{}\textgreater{} rs2{[}4:0{]}

\sphinxAtStartPar
Note: Logical shift right.

\sphinxAtStartPar
If rs2{[}4:0{]} is equal to 0, 2\textasciicircum{}(rs2{[}4:0{]}\sphinxhyphen{}1) is equivalent to 0.
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}


\subsection{General ALU Encoding}
\label{\detokenize{instruction_set_extensions:general-alu-encoding}}

\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{General ALU operations encoding}\label{\detokenize{instruction_set_extensions:general-alu-operations-encoding}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{21}{100}\X{13}{100}\X{9}{100}\X{9}{100}\X{9}{100}\X{11}{100}\X{28}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
31   :  25
&\sphinxstyletheadfamily 
\sphinxAtStartPar
24 : 20
&\sphinxstyletheadfamily 
\sphinxAtStartPar
19 : 15
&\sphinxstyletheadfamily 
\sphinxAtStartPar
14   :  12
&\sphinxstyletheadfamily 
\sphinxAtStartPar
11 : 7
&\sphinxstyletheadfamily 
\sphinxAtStartPar
6  :     0
&\sphinxstyletheadfamily \\
\sphinxhline\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{funct7}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rs2}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rs1}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{funct3}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rD}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{opcode}
&\sphinxstyletheadfamily \\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
010 1000
&
\sphinxAtStartPar
00000
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
011
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.abs rD, rs1}
\\
\sphinxhline
\sphinxAtStartPar
010 1001
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
011
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.sle rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
010 1010
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
011
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.sleu rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
011
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.min rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
010 1100
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
011
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.minu rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
010 1101
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
011
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.max rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
010 1110
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
011
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.maxu rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
011 0000
&
\sphinxAtStartPar
00000
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
011
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.exths rD, rs1}
\\
\sphinxhline
\sphinxAtStartPar
011 0001
&
\sphinxAtStartPar
00000
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
011
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.exthz rD, rs1}
\\
\sphinxhline
\sphinxAtStartPar
011 0010
&
\sphinxAtStartPar
00000
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
011
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.extbs rD, rs1}
\\
\sphinxhline
\sphinxAtStartPar
011 0011
&
\sphinxAtStartPar
00000
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
011
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.extbz rD, rs1}
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{General ALU operations encoding}\label{\detokenize{instruction_set_extensions:id9}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{21}{100}\X{13}{100}\X{9}{100}\X{9}{100}\X{9}{100}\X{11}{100}\X{28}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
31  :   25
&\sphinxstyletheadfamily 
\sphinxAtStartPar
24   :     20
&\sphinxstyletheadfamily 
\sphinxAtStartPar
19 : 15
&\sphinxstyletheadfamily 
\sphinxAtStartPar
14   :  12
&\sphinxstyletheadfamily 
\sphinxAtStartPar
11 : 7
&\sphinxstyletheadfamily 
\sphinxAtStartPar
6   :    0
&\sphinxstyletheadfamily \\
\sphinxhline\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{funct7}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Is2{[}4:0{]}}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rs1}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{funct3}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rD}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{opcode}
&\sphinxstyletheadfamily \\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
011 1000
&
\sphinxAtStartPar
Luimm5{[}4:0{]}
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
011
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.clip rD, rs1, Is2}
\\
\sphinxhline
\sphinxAtStartPar
011 1001
&
\sphinxAtStartPar
Luimm5{[}4:0{]}
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
011
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.clipu rD, rs1, Is2}
\\
\sphinxhline
\sphinxAtStartPar
011 1010
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
011
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.clipr rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
011 1011
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
011
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.clipur rD, rs1, rs2}
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{General ALU operations encoding}\label{\detokenize{instruction_set_extensions:id10}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{5}{100}\X{16}{100}\X{13}{100}\X{9}{100}\X{9}{100}\X{9}{100}\X{11}{100}\X{28}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
31: 30
&\sphinxstyletheadfamily 
\sphinxAtStartPar
29    :    25
&\sphinxstyletheadfamily 
\sphinxAtStartPar
24 : 20
&\sphinxstyletheadfamily 
\sphinxAtStartPar
19 : 15
&\sphinxstyletheadfamily 
\sphinxAtStartPar
14   :  12
&\sphinxstyletheadfamily 
\sphinxAtStartPar
11 : 7
&\sphinxstyletheadfamily 
\sphinxAtStartPar
6   :    0
&\sphinxstyletheadfamily \\
\sphinxhline\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{f2}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Is3{[}4:0{]}}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rs2}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rs1}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{funct3}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rD}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{opcode}
&\sphinxstyletheadfamily \\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
00
&
\sphinxAtStartPar
Luimm5{[}4:0{]}
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
010
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
101 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.addN rD, rs1, rs2, Is3}
\\
\sphinxhline
\sphinxAtStartPar
01
&
\sphinxAtStartPar
Luimm5{[}4:0{]}
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
010
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
101 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.adduN rD, rs1, rs2, Is3}
\\
\sphinxhline
\sphinxAtStartPar
10
&
\sphinxAtStartPar
Luimm5{[}4:0{]}
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
010
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
101 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.addRN rD, rs1, rs2, Is3}
\\
\sphinxhline
\sphinxAtStartPar
11
&
\sphinxAtStartPar
Luimm5{[}4:0{]}
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
010
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
101 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.adduRN rD, rs1, rs2, Is3}
\\
\sphinxhline
\sphinxAtStartPar
00
&
\sphinxAtStartPar
Luimm5{[}4:0{]}
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
011
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
101 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.subN rD, rs1, rs2, Is3}
\\
\sphinxhline
\sphinxAtStartPar
01
&
\sphinxAtStartPar
Luimm5{[}4:0{]}
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
011
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
101 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.subuN rD, rs1, rs2, Is3}
\\
\sphinxhline
\sphinxAtStartPar
10
&
\sphinxAtStartPar
Luimm5{[}4:0{]}
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
011
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
101 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.subRN rD, rs1, rs2, Is3}
\\
\sphinxhline
\sphinxAtStartPar
11
&
\sphinxAtStartPar
Luimm5{[}4:0{]}
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
011
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
101 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.subuRN rD, rs1, rs2, Is3}
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{General ALU operations encoding}\label{\detokenize{instruction_set_extensions:id11}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{21}{100}\X{13}{100}\X{9}{100}\X{9}{100}\X{9}{100}\X{11}{100}\X{28}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
31  :   25
&\sphinxstyletheadfamily 
\sphinxAtStartPar
24    :   20
&\sphinxstyletheadfamily 
\sphinxAtStartPar
19 : 15
&\sphinxstyletheadfamily 
\sphinxAtStartPar
14   :  12
&\sphinxstyletheadfamily 
\sphinxAtStartPar
11 : 7
&\sphinxstyletheadfamily 
\sphinxAtStartPar
6   :    0
&\sphinxstyletheadfamily \\
\sphinxhline\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{funct7}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Is3{[}4:0{]}}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rs1}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{funct3}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rD}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{opcode}
&\sphinxstyletheadfamily \\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
100 0000
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
011
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.addNr rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
100 0001
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
011
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.adduNr rD, rs1, rs}
\\
\sphinxhline
\sphinxAtStartPar
100 0010
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
011
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.addRNr rD, rs1, rs}
\\
\sphinxhline
\sphinxAtStartPar
100 0011
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
011
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.adduRNr rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
100 0100
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
011
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.subNr rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
100 0101
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
011
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.subuNr rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
100 0110
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
011
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.subRNr rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
100 0111
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
011
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.subuRNr rD, rs1, rs2}
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\subsection{Immediate Branching operations}
\label{\detokenize{instruction_set_extensions:immediate-branching-operations}}\label{\detokenize{instruction_set_extensions:corev-immediate-branching}}

\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Immediate Branching operations}\label{\detokenize{instruction_set_extensions:id12}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{30}{100}\X{70}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mnemonic}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxstylestrong{cv.beqimm rs1, Imm5, Imm12}
&
\sphinxAtStartPar
Branch to PC + (Imm12 \textless{}\textless{} 1) if rs1 is equal to Imm5.

\sphinxAtStartPar
Note: Imm5 is signed.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.bneimm rs1, Imm5, Imm12}
&
\sphinxAtStartPar
Branch to PC + (Imm12 \textless{}\textless{} 1) if rs1 is not equal to Imm5.

\sphinxAtStartPar
Note: Imm5 is signed.
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\subsection{Immediate Branching Encoding}
\label{\detokenize{instruction_set_extensions:immediate-branching-encoding}}

\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Immediate Branching encoding}\label{\detokenize{instruction_set_extensions:id13}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{13}{100}\X{14}{100}\X{8}{100}\X{6}{100}\X{8}{100}\X{12}{100}\X{12}{100}\X{11}{100}\X{16}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
31
&\sphinxstyletheadfamily 
\sphinxAtStartPar
30     :     25
&\sphinxstyletheadfamily 
\sphinxAtStartPar
24  : 20
&\sphinxstyletheadfamily 
\sphinxAtStartPar
19  : 15
&\sphinxstyletheadfamily 
\sphinxAtStartPar
14   :  12
&\sphinxstyletheadfamily 
\sphinxAtStartPar
11   :    8
&\sphinxstyletheadfamily 
\sphinxAtStartPar
7
&\sphinxstyletheadfamily 
\sphinxAtStartPar
6   :    0
&\sphinxstyletheadfamily \\
\sphinxhline\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Imm12{[}12{]}}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Imm12{[}10:5{]}}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Imm5}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rs1}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{funct3}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Imm12}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Imm12}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{opcode}
&\sphinxstyletheadfamily \\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
Imm12{[}12{]}
&
\sphinxAtStartPar
Imm12{[}10:5{]}
&
\sphinxAtStartPar
Imm5
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
110
&
\sphinxAtStartPar
Imm12{[}4:1{]}
&
\sphinxAtStartPar
Imm12{[}11{]}
&
\sphinxAtStartPar
000 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.beqimm rs1, Imm5, Imm12}
\\
\sphinxhline
\sphinxAtStartPar
Imm12{[}12{]}
&
\sphinxAtStartPar
Imm12{[}10:5{]}
&
\sphinxAtStartPar
Imm5
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
111
&
\sphinxAtStartPar
Imm12{[}4:1{]}
&
\sphinxAtStartPar
Imm12{[}11{]}
&
\sphinxAtStartPar
000 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.bneimm rs1, Imm5, Imm12}
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\section{Multiply\sphinxhyphen{}Accumulate}
\label{\detokenize{instruction_set_extensions:multiply-accumulate}}\label{\detokenize{instruction_set_extensions:corev-multiply-accumulate}}
\sphinxAtStartPar
CV32E40P supports custom extensions for multiply\sphinxhyphen{}accumulate and half\sphinxhyphen{}word multiplications with
an optional post\sphinxhyphen{}multiplication shift.

\sphinxAtStartPar
The custom multiply\sphinxhyphen{}accumulate extensions are only supported if \sphinxcode{\sphinxupquote{COREV\_PULP}} == 1.


\subsection{16\sphinxhyphen{}Bit x 16\sphinxhyphen{}Bit Multiplication operations}
\label{\detokenize{instruction_set_extensions:bit-x-16-bit-multiplication-operations}}

\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{16\sphinxhyphen{}Bit Multiplication operations}\label{\detokenize{instruction_set_extensions:bit-multiplication-operations}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{30}{100}\X{70}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mnemonic}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxstylestrong{cv.muluN rD, rs1, rs2, Is3}
&
\sphinxAtStartPar
rD{[}31:0{]} = (Zext(rs1{[}15:0{]}) * Zext(rs2{[}15:0{]})) \textgreater{}\textgreater{} Is3

\sphinxAtStartPar
Note: Logical shift right.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.mulhhuN rD, rs1, rs2, Is3}
&
\sphinxAtStartPar
rD{[}31:0{]} = (Zext(rs1{[}31:16{]}) * Zext(rs2{[}31:16{]})) \textgreater{}\textgreater{} Is3

\sphinxAtStartPar
Note: Logical shift right.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.mulsN rD, rs1, rs2, Is3}
&
\sphinxAtStartPar
rD{[}31:0{]} = (Sext(rs1{[}15:0{]}) * Sext(rs2{[}15:0{]})) \textgreater{}\textgreater{}\textgreater{} Is3

\sphinxAtStartPar
Note: Arithmetic shift right.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.mulhhsN rD, rs1, rs2, Is3}
&
\sphinxAtStartPar
rD{[}31:0{]} = (Sext(rs1{[}31:16{]}) * Sext(rs2{[}31:16{]})) \textgreater{}\textgreater{}\textgreater{} Is3

\sphinxAtStartPar
Note: Arithmetic shift right.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.muluRN rD, rs1, rs2, Is3}
&
\sphinxAtStartPar
rD{[}31:0{]} = (Zext(rs1{[}15:0{]}) * Zext(rs2{[}15:0{]}) + 2\textasciicircum{}(Is3\sphinxhyphen{}1)) \textgreater{}\textgreater{} Is3

\sphinxAtStartPar
Note: Logical shift right.

\sphinxAtStartPar
If Is3 is equal to 0, 2\textasciicircum{}(Is3\sphinxhyphen{}1) is equivalent to 0.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.mulhhuRN rD, rs1, rs2, Is3}
&
\sphinxAtStartPar
rD{[}31:0{]} = (Zext(rs1{[}31:16{]}) * Zext(rs2{[}31:16{]}) + 2\textasciicircum{}(Is3\sphinxhyphen{}1)) \textgreater{}\textgreater{} Is3

\sphinxAtStartPar
Note: Logical shift right.

\sphinxAtStartPar
If Is3 is equal to 0, 2\textasciicircum{}(Is3\sphinxhyphen{}1) is equivalent to 0.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.mulsRN rD, rs1, rs2, Is3}
&
\sphinxAtStartPar
rD{[}31:0{]} = (Sext(rs1{[}15:0{]}) * Sext(rs2{[}15:0{]}) + 2\textasciicircum{}(Is3\sphinxhyphen{}1)) \textgreater{}\textgreater{}\textgreater{} Is3

\sphinxAtStartPar
Note: Arithmetic shift right.

\sphinxAtStartPar
If Is3 is equal to 0, 2\textasciicircum{}(Is3\sphinxhyphen{}1) is equivalent to 0.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.mulhhsRN rD, rs1, rs2, Is3}
&
\sphinxAtStartPar
rD{[}31:0{]} = (Sext(rs1{[}31:16{]}) * Sext(rs2{[}31:16{]}) + 2\textasciicircum{}(Is3\sphinxhyphen{}1)) \textgreater{}\textgreater{}\textgreater{} Is3

\sphinxAtStartPar
Note: Arithmetic shift right.

\sphinxAtStartPar
If Is3 is equal to 0, 2\textasciicircum{}(Is3\sphinxhyphen{}1) is equivalent to 0.
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\subsection{16\sphinxhyphen{}Bit x 16\sphinxhyphen{}Bit Multiplication pseudo\sphinxhyphen{}instructions}
\label{\detokenize{instruction_set_extensions:bit-x-16-bit-multiplication-pseudo-instructions}}\label{\detokenize{instruction_set_extensions:corev-16-bit-multiply-pseudo-instructions}}

\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{16\sphinxhyphen{}Bit Multiplication pseudo\sphinxhyphen{}instructions}\label{\detokenize{instruction_set_extensions:bit-multiplication-pseudo-instructions}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{23}{100}\X{27}{100}\X{50}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mnemonic}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Base Instruction}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxstylestrong{cv.mulu rD, rs1, rs2}
&
\sphinxAtStartPar
\sphinxstylestrong{cv.muluN rD, rs1, rs2, 0}
&
\sphinxAtStartPar
rD{[}31:0{]} = (Zext(rs1{[}15:0{]}) * Zext(rs2{[}15:0{]})) \textgreater{}\textgreater{} 0

\sphinxAtStartPar
Note: Logical shift right.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.mulhhu rD, rs1, rs2}
&
\sphinxAtStartPar
\sphinxstylestrong{cv.mulhhuN rD, rs1, rs2, 0}
&
\sphinxAtStartPar
rD{[}31:0{]} = (Zext(rs1{[}31:16{]}) * Zext(rs2{[}31:16{]})) \textgreater{}\textgreater{} 0

\sphinxAtStartPar
Note: Logical shift right.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.muls rD, rs1, rs2}
&
\sphinxAtStartPar
\sphinxstylestrong{cv.mulsN rD, rs1, rs2, 0}
&
\sphinxAtStartPar
rD{[}31:0{]} = (Sext(rs1{[}15:0{]}) * Sext(rs2{[}15:0{]})) \textgreater{}\textgreater{} 0

\sphinxAtStartPar
Note: Arithmetic shift right.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.mulhhs rD, rs1, rs2}
&
\sphinxAtStartPar
\sphinxstylestrong{cv.mulhhsN rD, rs1, rs2, 0}
&
\sphinxAtStartPar
rD{[}31:0{]} = (Sext(rs1{[}31:16{]}) * Sext(rs2{[}31:16{]})) \textgreater{}\textgreater{} 0

\sphinxAtStartPar
Note: Arithmetic shift right.
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\subsection{16\sphinxhyphen{}Bit x 16\sphinxhyphen{}Bit Multiply\sphinxhyphen{}Accumulate operations}
\label{\detokenize{instruction_set_extensions:bit-x-16-bit-multiply-accumulate-operations}}

\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{16\sphinxhyphen{}Bit Multiply\sphinxhyphen{}Accumulate operations}\label{\detokenize{instruction_set_extensions:bit-multiply-accumulate-operations}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{30}{100}\X{70}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mnemonic}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxstylestrong{cv.macuN rD, rs1, rs2, Is3}
&
\sphinxAtStartPar
rD{[}31:0{]} = (Zext(rs1{[}15:0{]}) * Zext(rs2{[}15:0{]}) + rD) \textgreater{}\textgreater{} Is3

\sphinxAtStartPar
Note: Logical shift right.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.machhuN rD, rs1, rs2, Is3}
&
\sphinxAtStartPar
rD{[}31:0{]} = (Zext(rs1{[}31:16{]}) * Zext(rs2{[}31:16{]}) + rD) \textgreater{}\textgreater{} Is3

\sphinxAtStartPar
Note: Logical shift right.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.macsN rD, rs1, rs2, Is3}
&
\sphinxAtStartPar
rD{[}31:0{]} = (Sext(rs1{[}15:0{]}) * Sext(rs2{[}15:0{]}) + rD) \textgreater{}\textgreater{}\textgreater{} Is3

\sphinxAtStartPar
Note: Arithmetic shift right.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.machhsN rD, rs1, rs2, Is3}
&
\sphinxAtStartPar
rD{[}31:0{]} = (Sext(rs1{[}31:16{]}) * Sext(rs2{[}31:16{]}) + rD) \textgreater{}\textgreater{}\textgreater{} Is3

\sphinxAtStartPar
Note: Arithmetic shift right.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.macuRN rD, rs1, rs2, Is3}
&
\sphinxAtStartPar
rD{[}31:0{]} = (Zext(rs1{[}15:0{]}) * Zext(rs2{[}15:0{]}) + rD + 2\textasciicircum{}(Is3\sphinxhyphen{}1)) \textgreater{}\textgreater{} Is3

\sphinxAtStartPar
Note: Logical shift right.

\sphinxAtStartPar
If Is3 is equal to 0, 2\textasciicircum{}(Is3\sphinxhyphen{}1) is equivalent to 0.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.machhuRN rD, rs1, rs2, Is3}
&
\sphinxAtStartPar
rD{[}31:0{]} = (Zext(rs1{[}31:16{]}) * Zext(rs2{[}31:16{]}) + rD + 2\textasciicircum{}(Is3\sphinxhyphen{}1)) \textgreater{}\textgreater{} Is3

\sphinxAtStartPar
Note: Logical shift right.

\sphinxAtStartPar
If Is3 is equal to 0, 2\textasciicircum{}(Is3\sphinxhyphen{}1) is equivalent to 0.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.macsRN rD, rs1, rs2, Is3}
&
\sphinxAtStartPar
rD{[}31:0{]} = (Sext(rs1{[}15:0{]}) * Sext(rs2{[}15:0{]}) + rD + 2\textasciicircum{}(Is3\sphinxhyphen{}1)) \textgreater{}\textgreater{}\textgreater{} Is3

\sphinxAtStartPar
Note: Arithmetic shift right.

\sphinxAtStartPar
If Is3 is equal to 0, 2\textasciicircum{}(Is3\sphinxhyphen{}1) is equivalent to 0.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.machhsRN rD, rs1, rs2, Is3}
&
\sphinxAtStartPar
rD{[}31:0{]} = (Sext(rs1{[}31:16{]}) * Sext(rs2{[}31:16{]}) + rD + 2\textasciicircum{}(Is3\sphinxhyphen{}1)) \textgreater{}\textgreater{}\textgreater{} Is3

\sphinxAtStartPar
Note: Arithmetic shift right.

\sphinxAtStartPar
If Is3 is equal to 0, 2\textasciicircum{}(Is3\sphinxhyphen{}1) is equivalent to 0.
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\subsection{32\sphinxhyphen{}Bit x 32\sphinxhyphen{}Bit Multiply\sphinxhyphen{}Accumulate operations}
\label{\detokenize{instruction_set_extensions:bit-x-32-bit-multiply-accumulate-operations}}

\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{32\sphinxhyphen{}Bit Multiply\sphinxhyphen{}Accumulate operations}\label{\detokenize{instruction_set_extensions:id14}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{30}{100}\X{70}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mnemonic}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxstylestrong{cv.mac rD, rs1, rs2}
&
\sphinxAtStartPar
rD = rD + rs1 * rs2
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.msu rD, rs1, rs2}
&
\sphinxAtStartPar
rD = rD \sphinxhyphen{} rs1 * rs2
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\subsection{Encoding}
\label{\detokenize{instruction_set_extensions:id15}}

\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{16\sphinxhyphen{}Bit Multiplication operations}\label{\detokenize{instruction_set_extensions:id16}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{5}{98}\X{16}{98}\X{6}{98}\X{6}{98}\X{9}{98}\X{6}{98}\X{11}{98}\X{39}{98}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
31: 30
&\sphinxstyletheadfamily 
\sphinxAtStartPar
29    :    25
&\sphinxstyletheadfamily 
\sphinxAtStartPar
24 : 20
&\sphinxstyletheadfamily 
\sphinxAtStartPar
19 : 15
&\sphinxstyletheadfamily 
\sphinxAtStartPar
14   :  12
&\sphinxstyletheadfamily 
\sphinxAtStartPar
11 : 7
&\sphinxstyletheadfamily 
\sphinxAtStartPar
6   :    0
&\sphinxstyletheadfamily \\
\sphinxhline\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{f2}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Is3{[}4:0{]}}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rs2}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rs1}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{funct3}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rD}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{opcode}
&\sphinxstyletheadfamily \\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
00
&
\sphinxAtStartPar
Luimm5{[}4:0{]}
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
101
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
101 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.muluN rD, rs1, rs2, Is3}
\\
\sphinxhline
\sphinxAtStartPar
01
&
\sphinxAtStartPar
Luimm5{[}4:0{]}
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
101
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
101 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.mulhhuN rD, rs1, rs2, Is3}
\\
\sphinxhline
\sphinxAtStartPar
00
&
\sphinxAtStartPar
Luimm5{[}4:0{]}
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
100
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
101 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.mulsN rD, rs1, rs2, Is3}
\\
\sphinxhline
\sphinxAtStartPar
01
&
\sphinxAtStartPar
Luimm5{[}4:0{]}
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
100
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
101 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.mulhhsN rD, rs1, rs2, Is3}
\\
\sphinxhline
\sphinxAtStartPar
10
&
\sphinxAtStartPar
Luimm5{[}4:0{]}
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
101
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
101 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.muluRN rD, rs1, rs2, Is3}
\\
\sphinxhline
\sphinxAtStartPar
11
&
\sphinxAtStartPar
Luimm5{[}4:0{]}
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
101
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
101 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.mulhhuRN rD, rs1, rs2, Is3}
\\
\sphinxhline
\sphinxAtStartPar
10
&
\sphinxAtStartPar
Luimm5{[}4:0{]}
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
100
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
101 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.mulsRN rD, rs1, rs2, Is3}
\\
\sphinxhline
\sphinxAtStartPar
11
&
\sphinxAtStartPar
Luimm5{[}4:0{]}
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
100
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
101 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.mulhhsRN rD, rs1, rs2, Is3}
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{16\sphinxhyphen{}Bit Multiply\sphinxhyphen{}Accumulate operations}\label{\detokenize{instruction_set_extensions:id17}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{5}{98}\X{16}{98}\X{6}{98}\X{6}{98}\X{9}{98}\X{6}{98}\X{11}{98}\X{39}{98}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
31: 30
&\sphinxstyletheadfamily 
\sphinxAtStartPar
29    :    25
&\sphinxstyletheadfamily 
\sphinxAtStartPar
24 : 20
&\sphinxstyletheadfamily 
\sphinxAtStartPar
19 : 15
&\sphinxstyletheadfamily 
\sphinxAtStartPar
14   :  12
&\sphinxstyletheadfamily 
\sphinxAtStartPar
11 : 7
&\sphinxstyletheadfamily 
\sphinxAtStartPar
6   :    0
&\sphinxstyletheadfamily \\
\sphinxhline\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{f2}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Is3{[}4:0{]}}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rs2}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rs1}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{funct3}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rD}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{opcode}
&\sphinxstyletheadfamily \\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
00
&
\sphinxAtStartPar
Luimm5{[}4:0{]}
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
111
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
101 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.macuN rD, rs1, rs2, Is3}
\\
\sphinxhline
\sphinxAtStartPar
01
&
\sphinxAtStartPar
Luimm5{[}4:0{]}
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
111
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
101 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.machhuN rD, rs1, rs2, Is3}
\\
\sphinxhline
\sphinxAtStartPar
00
&
\sphinxAtStartPar
Luimm5{[}4:0{]}
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
110
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
101 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.macsN rD, rs1, rs2, Is3}
\\
\sphinxhline
\sphinxAtStartPar
01
&
\sphinxAtStartPar
Luimm5{[}4:0{]}
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
110
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
101 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.machhsN rD, rs1, rs2, Is3}
\\
\sphinxhline
\sphinxAtStartPar
10
&
\sphinxAtStartPar
Luimm5{[}4:0{]}
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
111
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
101 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.macuRN rD, rs1, rs2, Is3}
\\
\sphinxhline
\sphinxAtStartPar
11
&
\sphinxAtStartPar
Luimm5{[}4:0{]}
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
111
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
101 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.machhuRN rD, rs1, rs2, Is3}
\\
\sphinxhline
\sphinxAtStartPar
10
&
\sphinxAtStartPar
Luimm5{[}4:0{]}
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
110
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
101 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.macsRN rD, rs1, rs2, Is3}
\\
\sphinxhline
\sphinxAtStartPar
11
&
\sphinxAtStartPar
Luimm5{[}4:0{]}
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
110
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
101 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.machhsRN rD, rs1, rs2, Is3}
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{32\sphinxhyphen{}Bit Multiply\sphinxhyphen{}Accumulate operations}\label{\detokenize{instruction_set_extensions:id18}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{21}{98}\X{6}{98}\X{6}{98}\X{9}{98}\X{6}{98}\X{11}{98}\X{39}{98}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
31   :  25
&\sphinxstyletheadfamily 
\sphinxAtStartPar
24 : 20
&\sphinxstyletheadfamily 
\sphinxAtStartPar
19 : 15
&\sphinxstyletheadfamily 
\sphinxAtStartPar
14   :  12
&\sphinxstyletheadfamily 
\sphinxAtStartPar
11 : 7
&\sphinxstyletheadfamily 
\sphinxAtStartPar
6   :    0
&\sphinxstyletheadfamily \\
\sphinxhline\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{funct7}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rs2}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rs1}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{funct3}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rD}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{opcode}
&\sphinxstyletheadfamily \\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
100 1000
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
011
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.mac rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
100 1001
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
011
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
010 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.msu rD, rs1, rs2}
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\section{SIMD}
\label{\detokenize{instruction_set_extensions:simd}}\label{\detokenize{instruction_set_extensions:corev-simd}}
\sphinxAtStartPar
The SIMD instructions perform operations on multiple sub\sphinxhyphen{}word elements at the same time. This is done by segmenting
the data path into smaller parts when 8\sphinxhyphen{} or 16\sphinxhyphen{}bit operations should be performed.

\sphinxAtStartPar
The custom SIMD extensions are only supported if \sphinxcode{\sphinxupquote{COREV\_PULP}} == 1.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
See the comments at the start of {\hyperref[\detokenize{instruction_set_extensions:custom-isa-extensions}]{\sphinxcrossref{\DUrole{std,std-ref}{CORE\sphinxhyphen{}V Instruction Set Custom Extensions}}}} on availability of the compiler tool chains.
Support for SIMD will be primarily through assembly code and builtin functions, with no auto\sphinxhyphen{}vectorization and limited other optimization.
Simple auto\sphinxhyphen{}vectorization (add, sub…) and optimization will be evaluated once a stable GCC toolchain is available.
\end{sphinxadmonition}

\sphinxAtStartPar
SIMD instructions are available in two flavors:
\begin{itemize}
\item {} 
\sphinxAtStartPar
8\sphinxhyphen{}Bit, to perform four operations on the 4 bytes inside a 32\sphinxhyphen{}bit word
at the same time (.b)

\item {} 
\sphinxAtStartPar
16\sphinxhyphen{}Bit, to perform two operations on the 2 half\sphinxhyphen{}words inside a 32\sphinxhyphen{}bit
word at the same time (.h)

\end{itemize}

\sphinxAtStartPar
All the operations are rounded to the specified bidwidth as for the original
RISC\sphinxhyphen{}V arithmetic operations. This is described by the “and” operation with a
MASK. No overflow or carry\sphinxhyphen{}out flags are generated as for the 32\sphinxhyphen{}bit operations.

\sphinxAtStartPar
Additionally, there are three modes that influence the second operand:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Normal mode, vector\sphinxhyphen{}vector operation. Both operands, from rs1 and
rs2, are treated as vectors of bytes or half\sphinxhyphen{}words.

\sphinxAtStartPar
e.g. cv.add.h x3,x2,x1 performs:
\begin{quote}

\sphinxAtStartPar
x3{[}31:16{]} = x2{[}31:16{]} + x1{[}31:16{]}

\sphinxAtStartPar
x3{[}15: 0{]} = x2{[}15: 0{]} + x1{[}15: 0{]}
\end{quote}

\item {} 
\sphinxAtStartPar
Scalar replication mode (.sc), vector\sphinxhyphen{}scalar operation. Operand 1 is
treated as a vector, while operand 2 is treated as a scalar and
replicated two or four times to form a complete vector. The LSP is
used for this purpose.

\sphinxAtStartPar
e.g. cv.add.sc.h x3,x2,x1 performs:
\begin{quote}

\sphinxAtStartPar
x3{[}31:16{]} = x2{[}31:16{]} + x1{[}15: 0{]}

\sphinxAtStartPar
x3{[}15: 0{]} = x2{[}15: 0{]} + x1{[}15: 0{]}
\end{quote}

\item {} 
\sphinxAtStartPar
Immediate scalar replication mode (.sci), vector\sphinxhyphen{}scalar operation.
Operand 1 is treated as vector, while operand 2 is treated as a
scalar and comes from a 6\sphinxhyphen{}bit immediate.

\sphinxAtStartPar
The immediate is either sign\sphinxhyphen{} or zero\sphinxhyphen{}extended depending on the operation.
If not specified, the immediate is sign\sphinxhyphen{}extended with the exception
of all cv.shuffle* where it is always unsigned.

\sphinxAtStartPar
e.g. cv.add.sci.h x3,x2,\sphinxhyphen{}22 performs:
\begin{quote}

\sphinxAtStartPar
x3{[}31:16{]} = x2{[}31:16{]} + 0xFFEA

\sphinxAtStartPar
x3{[}15: 0{]} = x2{[}15: 0{]} + 0xFFEA
\end{quote}

\end{enumerate}

\sphinxAtStartPar
And finally for all the SIMD Bit Manipulation instructions, Imm6 is zero\sphinxhyphen{}extended.

\sphinxAtStartPar
In the following tables, the index i ranges from 0 to 1 for 16\sphinxhyphen{}Bit operations and from 0 to 3 for 8\sphinxhyphen{}Bit operations:
\begin{itemize}
\item {} 
\sphinxAtStartPar
The index 0 is 15:0  for 16\sphinxhyphen{}Bit operations or 7:0 for 8\sphinxhyphen{}Bit operations.

\item {} 
\sphinxAtStartPar
The index 1 is 31:16 for 16\sphinxhyphen{}Bit operations or 15:8 for 8\sphinxhyphen{}Bit operations.

\item {} 
\sphinxAtStartPar
The index 2 is 23:16 for 8\sphinxhyphen{}Bit operations.

\item {} 
\sphinxAtStartPar
The index 3 is 31:24 for 8\sphinxhyphen{}Bit operations.

\end{itemize}

\sphinxAtStartPar
And I5, I4, I3, I2, I1 and I0 respectively represent bits 5, 4, 3, 2, 1 and 0 of the immediate value.


\subsection{SIMD ALU operations}
\label{\detokenize{instruction_set_extensions:simd-alu-operations}}

\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{SIMD ALU operations}\label{\detokenize{instruction_set_extensions:id19}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{50}{100}\X{50}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mnemonic}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxstylestrong{cv.add{[}.sc,.sci{]}\{.h,.b\} rD, rs1, {[}rs2, Imm6{]}}
&
\sphinxAtStartPar
rD{[}i{]} = (rs1{[}i{]} + op2{[}i{]}) \& \{0xFFFF, 0xFF\}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.sub{[}.sc,.sci{]}\{.h,.b\} rD, rs1, {[}rs2, Imm6{]}}
&
\sphinxAtStartPar
rD{[}i{]} = (rs1{[}i{]} \sphinxhyphen{} op2{[}i{]}) \& \{0xFFFF, 0xFF\}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.avg{[}.sc,.sci{]}\{.h,.b\} rD, rs1, {[}rs2, Imm6{]}}
&
\sphinxAtStartPar
rD{[}i{]} = ((rs1{[}i{]} + op2{[}i{]}) \& \{0xFFFF, 0xFF\}) \textgreater{}\textgreater{} 1

\sphinxAtStartPar
Note: Arithmetic right shift.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.avgu{[}.sc,.sci{]}\{.h,.b\} rD, rs1, {[}rs2, Imm6{]}}
&
\sphinxAtStartPar
rD{[}i{]} = ((rs1{[}i{]} + op2{[}i{]}) \& \{0xFFFF, 0xFF\}) \textgreater{}\textgreater{} 1

\sphinxAtStartPar
Note: Immediate is zero\sphinxhyphen{}extended, shift is logical.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.min{[}.sc,.sci{]}\{.h,.b\} rD, rs1, {[}rs2, Imm6{]}}
&
\sphinxAtStartPar
rD{[}i{]} = rs1{[}i{]} \textless{} op2{[}i{]} ? rs1{[}i{]} : op2{[}i{]}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.minu{[}.sc,.sci{]}\{.h,.b\} rD, rs1, {[}rs2, Imm6{]}}
&
\sphinxAtStartPar
rD{[}i{]} = rs1{[}i{]} \textless{} op2{[}i{]} ? rs1{[}i{]} : op2{[}i{]}

\sphinxAtStartPar
Note: Immediate is zero\sphinxhyphen{}extended, comparison is unsigned.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.max{[}.sc,.sci{]}\{.h,.b\} rD, rs1, {[}rs2, Imm6{]}}
&
\sphinxAtStartPar
rD{[}i{]} = rs1{[}i{]} \textgreater{} op2{[}i{]} ? rs1{[}i{]} : op2{[}i{]}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.maxu{[}.sc,.sci{]}\{.h,.b\} rD, rs1, {[}rs2, Imm6{]}}
&
\sphinxAtStartPar
rD{[}i{]} = rs1{[}i{]} \textgreater{} op2{[}i{]} ? rs1{[}i{]} : op2{[}i{]}

\sphinxAtStartPar
Note: Immediate is zero\sphinxhyphen{}extended, comparison is unsigned.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.srl{[}.sc,.sci{]}\{.h,.b\} rD, rs1, {[}rs2, Imm6{]}}
&
\sphinxAtStartPar
rD{[}i{]} = rs1{[}i{]} \textgreater{}\textgreater{} op2{[}i{]}

\sphinxAtStartPar
Note: Immediate is zero\sphinxhyphen{}extended, shift is logical.

\sphinxAtStartPar
Only Imm6{[}3:0{]} and rs2{[}3:0{]} are used for .h instruction and
Imm6{[}2:0{]} and rs2{[}2:0{]} for .b instruction.

\sphinxAtStartPar
Other bits are not used and must be set to 0.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.sra{[}.sc,.sci{]}\{.h,.b\} rD, rs1, {[}rs2, Imm6{]}}
&
\sphinxAtStartPar
rD{[}i{]} = rs1{[}i{]} \textgreater{}\textgreater{}\textgreater{} op2{[}i{]}

\sphinxAtStartPar
Note: Immediate is zero\sphinxhyphen{}extended, shift is arithmetic.

\sphinxAtStartPar
Only Imm6{[}3:0{]} and rs2{[}3:0{]} are used for .h instruction and
Imm6{[}2:0{]} and rs2{[}2:0{]} for .b instruction.

\sphinxAtStartPar
Other bits are not used and must be set to 0.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.sll{[}.sc,.sci{]}\{.h,.b\} rD, rs1, {[}rs2, Imm6{]}}
&
\sphinxAtStartPar
rD{[}i{]} = rs1{[}i{]} \textless{}\textless{} op2{[}i{]}

\sphinxAtStartPar
Note: Immediate is zero\sphinxhyphen{}extended, shift is logical.

\sphinxAtStartPar
Only Imm6{[}3:0{]} and rs2{[}3:0{]} are used for .h instruction and
Imm6{[}2:0{]} and rs2{[}2:0{]} for .b instruction.

\sphinxAtStartPar
Other bits are not used and must be set to 0.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.or{[}.sc,.sci{]}\{.h,.b\} rD, rs1, {[}rs2, Imm6{]}}
&
\sphinxAtStartPar
rD{[}i{]} = rs1{[}i{]} | op2{[}i{]}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.xor{[}.sc,.sci{]}\{.h,.b\} rD, rs1, {[}rs2, Imm6{]}}
&
\sphinxAtStartPar
rD{[}i{]} = rs1{[}i{]} \textasciicircum{} op2{[}i{]}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.and{[}.sc,.sci{]}\{.h,.b\} rD, rs1, {[}rs2, Imm6{]}}
&
\sphinxAtStartPar
rD{[}i{]} = rs1{[}i{]} \& op2{[}i{]}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.abs\{.h,.b\} rD, rs1}
&
\sphinxAtStartPar
rD{[}i{]} = rs1{[}i{]} \textless{} 0 ? \sphinxhyphen{}rs1{[}i{]} : rs1{[}i{]}
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\subsubsection{SIMD Bit Manipulation operations}
\label{\detokenize{instruction_set_extensions:simd-bit-manipulation-operations}}

\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{SIMD Bit Manipulation operations}\label{\detokenize{instruction_set_extensions:id20}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{50}{100}\X{50}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mnemonic}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxstylestrong{cv.extract.h rD, rs1, Imm6}
&
\sphinxAtStartPar
rD = Sext(rs1{[}I0*16+15:I0*16{]})
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.extract.b rD, rs1, Imm6}
&
\sphinxAtStartPar
rD = Sext(rs1{[}(I1:I0)*8+7:(I1:I0)*8{]})
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.extractu.h rD, rs1, Imm6}
&
\sphinxAtStartPar
rD = Zext(rs1{[}I0*16+15:I0*16{]})
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.extractu.b rD, rs1, Imm6}
&
\sphinxAtStartPar
rD = Zext(rs1{[}(I1:I0)*8+7:(I1:I0)*8{]})
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.insert.h rD, rs1, Imm6}
&
\sphinxAtStartPar
rD{[}I0*16+15:I0*16{]} = rs1{[}15:0{]}

\sphinxAtStartPar
Note: The rest of the bits of rD are untouched and keep their previous value.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.insert.b rD, rs1, Imm6}
&
\sphinxAtStartPar
rD{[}(I1:I0)*8+7:(I1:I0)*8{]} = rs1{[}7:0{]}

\sphinxAtStartPar
Note: The rest of the bits of rD are untouched and keep their previous value.
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\subsubsection{SIMD Dot Product operations}
\label{\detokenize{instruction_set_extensions:simd-dot-product-operations}}

\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{SIMD Dot Product operations}\label{\detokenize{instruction_set_extensions:id21}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{50}{100}\X{50}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mnemonic}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxstylestrong{cv.dotup{[}.sc,.sci{]}.h rD, rs1, {[}rs2, Imm6{]}}
&
\sphinxAtStartPar
rD = rs1{[}0{]} * op2{[}0{]} + rs1{[}1{]} * op2{[}1{]}

\sphinxAtStartPar
Note: All operands are unsigned.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.dotup{[}.sc,.sci{]}.b rD, rs1, {[}rs2, Imm6{]}}
&
\sphinxAtStartPar
rD = rs1{[}0{]} * op2{[}0{]} + rs1{[}1{]} * op2{[}1{]} +

\sphinxAtStartPar
rs1{[}2{]} * op2{[}2{]} + rs1{[}3{]} * op2{[}3{]}

\sphinxAtStartPar
Note: All operands are unsigned.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.dotusp{[}.sc,.sci{]}.h rD, rs1, {[}rs2, Imm6{]}}
&
\sphinxAtStartPar
rD = rs1{[}0{]} * op2{[}0{]} + rs1{[}1{]} * op2{[}1{]}

\sphinxAtStartPar
Note: rs1 is treated as unsigned, while op2 is treated as signed.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.dotusp{[}.sc,.sci{]}.b rD, rs1, {[}rs2, Imm6{]}}
&
\sphinxAtStartPar
rD = rs1{[}0{]} * op2{[}0{]} + rs1{[}1{]} * op2{[}1{]} +

\sphinxAtStartPar
rs1{[}2{]} * op2{[}2{]} + rs1{[}3{]} * op2{[}3{]}

\sphinxAtStartPar
Note: rs1 is treated as unsigned, while op2 is treated as signed.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.dotsp{[}.sc,.sci{]}.h rD, rs1, {[}rs2, Imm6{]}}
&
\sphinxAtStartPar
rD = rs1{[}0{]} * op2{[}0{]} + rs1{[}1{]} * op2{[}1{]}

\sphinxAtStartPar
Note: All operands are signed.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.dotsp{[}.sc,.sci{]}.b rD, rs1, {[}rs2, Imm6{]}}
&
\sphinxAtStartPar
rD = rs1{[}0{]} * op2{[}0{]} + rs1{[}1{]} * op2{[}1{]} +

\sphinxAtStartPar
rs1{[}2{]} * op2{[}2{]} + rs1{[}3{]} * op2{[}3{]}

\sphinxAtStartPar
Note: All operands are signed.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.sdotup{[}.sc,.sci{]}.h rD, rs1, {[}rs2, Imm6{]}}
&
\sphinxAtStartPar
rD = rD + rs1{[}0{]} * op2{[}0{]} + rs1{[}1{]} * op2{[}1{]}

\sphinxAtStartPar
Note: All operands are unsigned.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.sdotup{[}.sc,.sci{]}.b rD, rs1, {[}rs2, Imm6{]}}
&
\sphinxAtStartPar
rD = rD + rs1{[}0{]} * op2{[}0{]} + rs1{[}1{]} * op2{[}1{]} +

\sphinxAtStartPar
rs1{[}2{]} * op2{[}2{]} + rs1{[}3{]} * op2{[}3{]}

\sphinxAtStartPar
Note: All operands are unsigned.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.sdotusp{[}.sc,.sci{]}.h rD, rs1, {[}rs2, Imm6{]}}
&
\sphinxAtStartPar
rD = rD + rs1{[}0{]} * op2{[}0{]} + rs1{[}1{]} * op2{[}1{]}

\sphinxAtStartPar
Note: rs1 is treated as unsigned while op2 is treated as signed.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.sdotusp{[}.sc,.sci{]}.b rD, rs1, {[}rs2, Imm6{]}}
&
\sphinxAtStartPar
rD = rD + rs1{[}0{]} * op2{[}0{]} + rs1{[}1{]} * op2{[}1{]} +

\sphinxAtStartPar
rs1{[}2{]} * op2{[}2{]} + rs1{[}3{]} * op2{[}3{]}

\sphinxAtStartPar
Note: rs1 is treated as unsigned while op2 is treated as signed.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.sdotsp{[}.sc,.sci{]}.h rD, rs1, {[}rs2, Imm6{]}}
&
\sphinxAtStartPar
rD = rD + rs1{[}0{]} * op2{[}0{]} + rs1{[}1{]} * op2{[}1{]}

\sphinxAtStartPar
Note: All operands are signed.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.sdotsp{[}.sc,.sci{]}.b rD, rs1, {[}rs2, Imm6{]}}
&
\sphinxAtStartPar
rD = rD + rs1{[}0{]} * op2{[}0{]} + rs1{[}1{]} * op2{[}1{]} +

\sphinxAtStartPar
rs1{[}2{]} * op2{[}2{]} + rs1{[}3{]} * op2{[}3{]}

\sphinxAtStartPar
Note: All operands are signed.
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\subsubsection{SIMD Shuffle and Pack operations}
\label{\detokenize{instruction_set_extensions:simd-shuffle-and-pack-operations}}

\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{SIMD Shuffle and Pack operations}\label{\detokenize{instruction_set_extensions:id22}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{35}{100}\X{65}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mnemonic}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxstylestrong{cv.shuffle.h rD, rs1, rs2}
&
\sphinxAtStartPar
rD{[}31:16{]} = rs1{[}rs2{[}16{]}*16+15:rs2{[}16{]}*16{]}

\sphinxAtStartPar
rD{[}15:0{]} = rs1{[}rs2{[}0{]}*16+15:rs2{[}0{]}*16{]}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.shuffle.sci.h rD, rs1, Imm6}
&
\sphinxAtStartPar
rD{[}31:16{]} = rs1{[}I1*16+15:I1*16{]}

\sphinxAtStartPar
rD{[}15:0{]} = rs1{[}I0*16+15:I0*16{]}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.shuffle.b rD, rs1, rs2}
&
\sphinxAtStartPar
rD{[}31:24{]} = rs1{[}rs2{[}25:24{]}*8+7:rs2{[}25:24{]}*8{]}

\sphinxAtStartPar
rD{[}23:16{]} = rs1{[}rs2{[}17:16{]}*8+7:rs2{[}17:16{]}*8{]}

\sphinxAtStartPar
rD{[}15:8{]} = rs1{[}rs2{[}9:8{]}*8+7:rs2{[}9:8{]}*8{]}

\sphinxAtStartPar
rD{[}7:0{]} = rs1{[}rs2{[}1:0{]}*8+7:rs2{[}1:0{]}*8{]}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.shuffleI0.sci.b rD, rs1, Imm6}
&
\sphinxAtStartPar
rD{[}31:24{]} = rs1{[}7:0{]}

\sphinxAtStartPar
rD{[}23:16{]} = rs1{[}(I5:I4)*8+7: (I5:I4)*8{]}

\sphinxAtStartPar
rD{[}15:8{]} = rs1{[}(I3:I2)*8+7: (I3:I2)*8{]}

\sphinxAtStartPar
rD{[}7:0{]} = rs1{[}(I1:I0)*8+7:(I1:I0)*8{]}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.shuffleI1.sci.b rD, rs1, Imm6}
&
\sphinxAtStartPar
rD{[}31:24{]} = rs1{[}15:8{]}

\sphinxAtStartPar
rD{[}23:16{]} = rs1{[}(I5:I4)*8+7: (I5:I4)*8{]}

\sphinxAtStartPar
rD{[}15:8{]} = rs1{[}(I3:I2)*8+7: (I3:I2)*8{]}

\sphinxAtStartPar
rD{[}7:0{]} = rs1{[}(I1:I0)*8+7:(I1:I0)*8{]}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.shuffleI2.sci.b rD, rs1, Imm6}
&
\sphinxAtStartPar
rD{[}31:24{]} = rs1{[}23:16{]}

\sphinxAtStartPar
rD{[}23:16{]} = rs1{[}(I5:I4)*8+7: (I5:I4)*8{]}

\sphinxAtStartPar
rD{[}15:8{]} = rs1{[}(I3:I2)*8+7: (I3:I2)*8{]}

\sphinxAtStartPar
rD{[}7:0{]} = rs1{[}(I1:I0)*8+7:(I1:I0)*8{]}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.shuffleI3.sci.b rD, rs1, Imm6}
&
\sphinxAtStartPar
rD{[}31:24{]} = rs1{[}31:24{]}

\sphinxAtStartPar
rD{[}23:16{]} = rs1{[}(I5:I4)*8+7: (I5:I4)*8{]}

\sphinxAtStartPar
rD{[}15:8{]} = rs1{[}(I3:I2)*8+7: (I3:I2)*8{]}

\sphinxAtStartPar
rD{[}7:0{]} = rs1{[}(I1:I0)*8+7:(I1:I0)*8{]}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.shuffle2.h rD, rs1, rs2}
&
\sphinxAtStartPar
rD{[}31:16{]} = ((rs2{[}17{]} == 1) ? rs1 : rD){[}rs2{[}16{]}*16+15:rs2{[}16{]}*16{]}

\sphinxAtStartPar
rD{[}15:0{]} = ((rs2{[}1{]} == 1) ? rs1 : rD){[}rs2{[}0{]}*16+15:rs2{[}0{]}*16{]}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.shuffle2.b rD, rs1, rs2}
&
\sphinxAtStartPar
rD{[}31:24{]} = ((rs2{[}26{]} == 1) ? rs1 : rD){[}rs2{[}25:24{]}*8+7:rs2{[}25:24{]}*8{]}

\sphinxAtStartPar
rD{[}23:16{]} = ((rs2{[}18{]} == 1) ? rs1 : rD){[}rs2{[}17:16{]}*8+7:rs2{[}17:16{]}*8{]}

\sphinxAtStartPar
rD{[}15:8{]} = ((rs2{[}10{]} == 1) ? rs1 : rD){[}rs2{[}9:8{]}*8+7:rs2{[}9:8{]}*8{]}

\sphinxAtStartPar
rD{[}7:0{]} = ((rs2{[}2{]} == 1) ? rs1 : rD){[}rs2{[}1:0{]}*8+7:rs2{[}1:0{]}*8{]}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.pack rD, rs1, rs2}
&
\sphinxAtStartPar
rD{[}31:16{]} = rs1{[}15:0{]}

\sphinxAtStartPar
rD{[}15:0{]} = rs2{[}15:0{]}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.pack.h rD, rs1, rs2}
&
\sphinxAtStartPar
rD{[}31:16{]} = rs1{[}31:16{]}

\sphinxAtStartPar
rD{[}15:0{]} = rs2{[}31:16{]}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.packhi.b rD, rs1, rs2}
&
\sphinxAtStartPar
rD{[}31:24{]} = rs1{[}7:0{]}

\sphinxAtStartPar
rD{[}23:16{]} = rs2{[}7:0{]}

\sphinxAtStartPar
Note: The rest of the bits of rD are untouched and keep their previous value.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.packlo.b rD, rs1, rs2}
&
\sphinxAtStartPar
rD{[}15:8{]} = rs1{[}7:0{]}

\sphinxAtStartPar
rD{[}7:0{]} = rs2{[}7:0{]}

\sphinxAtStartPar
Note: The rest of the bits of rD are untouched and keep their previous value.
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\subsubsection{SIMD ALU Encoding}
\label{\detokenize{instruction_set_extensions:simd-alu-encoding}}

\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{11}{100}\X{4}{100}\X{4}{100}\X{9}{100}\X{7}{100}\X{8}{100}\X{8}{100}\X{13}{100}\X{36}{100}}
\sphinxthelongtablecaptionisattop
\caption{SIMD ALU encoding\strut}\label{\detokenize{instruction_set_extensions:id23}}\\*[\sphinxlongtablecapskipadjust]
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
31  : 27
&\sphinxstyletheadfamily 
\sphinxAtStartPar
26
&\sphinxstyletheadfamily 
\sphinxAtStartPar
25
&\sphinxstyletheadfamily 
\sphinxAtStartPar
24 : 20
&\sphinxstyletheadfamily 
\sphinxAtStartPar
19 : 15
&\sphinxstyletheadfamily 
\sphinxAtStartPar
14  :   12
&\sphinxstyletheadfamily 
\sphinxAtStartPar
11  :  7
&\sphinxstyletheadfamily 
\sphinxAtStartPar
6    :   0
&\sphinxstyletheadfamily \\
\sphinxhline\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{funct5}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{F}
&\sphinxstyletheadfamily &\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rs2}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rs1}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{funct3}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rD}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{opcode}
&\sphinxstyletheadfamily \\
\sphinxmidrule
\endfirsthead

\multicolumn{9}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
31  : 27
&\sphinxstyletheadfamily 
\sphinxAtStartPar
26
&\sphinxstyletheadfamily 
\sphinxAtStartPar
25
&\sphinxstyletheadfamily 
\sphinxAtStartPar
24 : 20
&\sphinxstyletheadfamily 
\sphinxAtStartPar
19 : 15
&\sphinxstyletheadfamily 
\sphinxAtStartPar
14  :   12
&\sphinxstyletheadfamily 
\sphinxAtStartPar
11  :  7
&\sphinxstyletheadfamily 
\sphinxAtStartPar
6    :   0
&\sphinxstyletheadfamily \\
\sphinxhline\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{funct5}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{F}
&\sphinxstyletheadfamily &\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rs2}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rs1}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{funct3}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rD}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{opcode}
&\sphinxstyletheadfamily \\
\sphinxmidrule
\endhead

\sphinxbottomrule
\multicolumn{9}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
0 0000
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
000
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.add.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0000
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
100
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.add.sc.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0000
&
\sphinxAtStartPar
0
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
110
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.add.sci.h rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
0 0000
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
001
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.add.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0000
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
101
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.add.sc.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0000
&
\sphinxAtStartPar
0
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
111
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.add.sci.b rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
0 0001
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
000
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.sub.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0001
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
100
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.sub.sc.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0001
&
\sphinxAtStartPar
0
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
110
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.sub.sci.h rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
0 0001
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
001
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.sub.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0001
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
101
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.sub.sc.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0001
&
\sphinxAtStartPar
0
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
111
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.sub.sci.b rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
0 0010
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
000
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.avg.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0010
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
100
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.avg.sc.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0010
&
\sphinxAtStartPar
0
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
110
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.avg.sci.h rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
0 0010
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
001
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.avg.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0010
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
101
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.avg.sc.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0010
&
\sphinxAtStartPar
0
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
111
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.avg.sci.b rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
0 0011
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
000
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.avgu.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0011
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
100
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.avgu.sc.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0011
&
\sphinxAtStartPar
0
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
110
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.avgu.sci.h rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
0 0011
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
001
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.avgu.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0011
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
101
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.avgu.sc.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0011
&
\sphinxAtStartPar
0
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
111
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.avgu.sci.b rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
0 0100
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
000
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.min.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0100
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
100
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.min.sc.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0100
&
\sphinxAtStartPar
0
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
110
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.min.sci.h rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
0 0100
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
001
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.min.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0100
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
101
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.min.sc.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0100
&
\sphinxAtStartPar
0
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
111
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.min.sci.b rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
0 0101
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
000
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.minu.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0101
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
100
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.minu.sc.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0101
&
\sphinxAtStartPar
0
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
110
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.minu.sci.h rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
0 0101
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
001
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.minu.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0101
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
101
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.minu.sc.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0101
&
\sphinxAtStartPar
0
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
111
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.minu.sci.b rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
0 0110
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
000
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.max.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0110
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
100
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.max.sc.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0110
&
\sphinxAtStartPar
0
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
110
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.max.sci.h rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
0 0110
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
001
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.max.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0110
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
101
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.max.sc.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0110
&
\sphinxAtStartPar
0
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
111
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.max.sci.b rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
0 0111
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
000
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.maxu.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0111
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
100
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.maxu.sc.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0111
&
\sphinxAtStartPar
0
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
110
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.maxu.sci.h rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
0 0111
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
001
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.maxu.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0111
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
101
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.maxu.sc.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0111
&
\sphinxAtStartPar
0
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
111
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.maxu.sci.b rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
0 1000
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
000
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.srl.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 1000
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
100
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.srl.sc.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 1000
&
\sphinxAtStartPar
0
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
110
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.srl.sci.h rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
0 1000
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
001
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.srl.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 1000
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
101
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.srl.sc.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 1000
&
\sphinxAtStartPar
0
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
111
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.srl.sci.b rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
0 1001
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
000
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.sra.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 1001
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
100
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.sra.sc.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 1001
&
\sphinxAtStartPar
0
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
110
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.sra.sci.h rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
0 1001
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
001
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.sra.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 1001
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
101
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.sra.sc.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 1001
&
\sphinxAtStartPar
0
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
111
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.sra.sci.b rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
0 1010
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
000
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.sll.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 1010
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
100
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.sll.sc.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 1010
&
\sphinxAtStartPar
0
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
110
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.sll.sci.h rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
0 1010
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
001
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.sll.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 1010
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
101
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.sll.sc.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 1010
&
\sphinxAtStartPar
0
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
111
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.sll.sci.b rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
0 1011
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
000
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.or.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 1011
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
100
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.or.sc.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 1011
&
\sphinxAtStartPar
0
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
110
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.or.sci.h rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
0 1011
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
001
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.or.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 1011
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
101
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.or.sc.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 1011
&
\sphinxAtStartPar
0
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
111
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.or.sci.b rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
0 1100
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
000
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.xor.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 1100
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
100
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.xor.sc.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 1100
&
\sphinxAtStartPar
0
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
110
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.xor.sci.h rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
0 1100
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
001
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.xor.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 1100
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
101
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.xor.sc.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 1100
&
\sphinxAtStartPar
0
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
111
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.xor.sci.b rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
0 1101
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
000
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.and.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 1101
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
100
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.and.sc.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 1101
&
\sphinxAtStartPar
0
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
110
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.and.sci.h rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
0 1101
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
001
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.and.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 1101
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
101
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.and.sc.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 1101
&
\sphinxAtStartPar
0
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
111
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.and.sci.b rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
0 1110
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
000
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.abs.h rD, rs1}
\\
\sphinxhline
\sphinxAtStartPar
0 1110
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
001
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.abs.b rD, rs1}
\\
\sphinxhline
\sphinxAtStartPar
1 0111
&
\sphinxAtStartPar
0
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
000
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.extract.h rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
1 0111
&
\sphinxAtStartPar
0
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
001
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.extract.b rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
1 0111
&
\sphinxAtStartPar
0
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
010
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.extractu.h rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
1 0111
&
\sphinxAtStartPar
0
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
011
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.extractu.b rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
1 0111
&
\sphinxAtStartPar
0
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
100
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.insert.h rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
1 0111
&
\sphinxAtStartPar
0
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
101
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.insert.b rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
1 0000
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
000
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.dotup.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
1 0000
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
100
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.dotup.sc.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
1 0000
&
\sphinxAtStartPar
0
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
110
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.dotup.sci.h rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
1 0000
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
001
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.dotup.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
1 0000
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
101
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.dotup.sc.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
1 0000
&
\sphinxAtStartPar
0
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
111
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.dotup.sci.b rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
1 0001
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
000
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.dotusp.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
1 0001
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
100
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.dotusp.sc.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
1 0001
&
\sphinxAtStartPar
0
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
110
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.dotusp.sci.h rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
1 0001
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
001
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.dotusp.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
1 0001
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
101
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.dotusp.sc.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
1 0001
&
\sphinxAtStartPar
0
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
111
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.dotusp.sci.b rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
1 0010
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
000
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.dotsp.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
1 0010
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
100
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.dotsp.sc.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
1 0010
&
\sphinxAtStartPar
0
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
110
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.dotsp.sci.h rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
1 0010
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
001
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.dotsp.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
1 0010
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
101
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.dotsp.sc.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
1 0010
&
\sphinxAtStartPar
0
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
111
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.dotsp.sci.b rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
1 0011
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
000
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.sdotup.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
1 0011
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
100
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.sdotup.sc.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
1 0011
&
\sphinxAtStartPar
0
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
110
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.sdotup.sci.h rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
1 0011
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
001
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.sdotup.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
1 0011
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
101
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.sdotup.sc.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
1 0011
&
\sphinxAtStartPar
0
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
111
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.sdotup.sci.b rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
1 0100
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
000
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.sdotusp.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
1 0100
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
100
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.sdotusp.sc.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
1 0100
&
\sphinxAtStartPar
0
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
110
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.sdotusp.sci.h rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
1 0100
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
001
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.sdotusp.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
1 0100
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
101
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.sdotusp.sc.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
1 0100
&
\sphinxAtStartPar
0
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
111
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.sdotusp.sci.b rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
1 0101
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
000
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.sdotsp.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
1 0101
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
100
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.sdotsp.sc.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
1 0101
&
\sphinxAtStartPar
0
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
110
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.sdotsp.sci.h rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
1 0101
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
001
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.sdotsp.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
1 0101
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
101
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.sdotsp.sc.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
1 0101
&
\sphinxAtStartPar
0
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
111
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.sdotsp.sci.b rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
1 1000
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
000
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.shuffle.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
1 1000
&
\sphinxAtStartPar
0
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
110
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.shuffle.sci.h rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
1 1000
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
001
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.shuffle.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
1 1000
&
\sphinxAtStartPar
0
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
111
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.shuffleI0.sci.b rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
1 1001
&
\sphinxAtStartPar
0
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
111
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.shuffleI1.sci.b rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
1 1010
&
\sphinxAtStartPar
0
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
111
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.shuffleI2.sci.b rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
1 1011
&
\sphinxAtStartPar
0
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
111
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.shuffleI3.sci.b rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
1 1100
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
000
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.shuffle2.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
1 1100
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
001
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.shuffle2.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
1 1110
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
000
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.pack rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
1 1110
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
000
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.pack.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
1 1111
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
001
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.packhi.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
1 1111
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
001
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.packlo.b rD, rs1, rs2}
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}


\subsection{SIMD Comparison operations}
\label{\detokenize{instruction_set_extensions:simd-comparison-operations}}
\sphinxAtStartPar
SIMD comparisons are done on individual bytes (.b) or half\sphinxhyphen{}words
(.h), depending on the chosen mode. If the comparison result is true,
all bits in the corresponding byte/half\sphinxhyphen{}word are set to 1. If the
comparison result is false, all bits are set to 0.

\sphinxAtStartPar
The default mode (no .sc, .sci) compares the lowest byte/half\sphinxhyphen{}word of
the first operand with the lowest byte/half\sphinxhyphen{}word of the second operand,
and so on. If the mode is set to scalar replication (.sc), always the
lowest byte/half\sphinxhyphen{}word of the second operand is used for comparisons,
thus instead of a vector comparison a scalar comparison is performed. In
the immediate scalar replication mode (.sci), the immediate given to the
instruction is used for the comparison.


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{SIMD Comparison operations}\label{\detokenize{instruction_set_extensions:id24}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{50}{100}\X{50}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mnemonic}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxstylestrong{cv.cmpeq{[}.sc,.sci{]}\{.h,.b\} rD, rs1, {[}rs2, Imm6{]}}
&
\sphinxAtStartPar
rD{[}i{]} = rs1{[}i{]} == op2 ? ‘1 : ‘0
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.cmpne{[}.sc,.sci{]}\{.h,.b\} rD, rs1, {[}rs2, Imm6{]}}
&
\sphinxAtStartPar
rD{[}i{]} = rs1{[}i{]} != op2 ? ‘1 : ‘0
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.cmpgt{[}.sc,.sci{]}\{.h,.b\} rD, rs1, {[}rs2, Imm6{]}}
&
\sphinxAtStartPar
rD{[}i{]} = rs1{[}i{]} \textgreater{} op2 ? ‘1 : ‘0
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.cmpge{[}.sc,.sci{]}\{.h,.b\} rD, rs1, {[}rs2, Imm6{]}}
&
\sphinxAtStartPar
rD{[}i{]} = rs1{[}i{]} \textgreater{}=op2 ? ‘1 : ‘0
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.cmplt{[}.sc,.sci{]}\{.h,.b\} rD, rs1, {[}rs2, Imm6{]}}
&
\sphinxAtStartPar
rD{[}i{]} = rs1{[}i{]} \textless{} op2 ? ‘1 : ‘0
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.cmple{[}.sc,.sci{]}\{.h,.b\} rD, rs1, {[}rs2, Imm6{]}}
&
\sphinxAtStartPar
rD{[}i{]} = rs1{[}i{]} \textless{}= op2 ? ‘1 : ‘0
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.cmpgtu{[}.sc,.sci{]}\{.h,.b\} rD, rs1, {[}rs2, Imm6{]}}
&
\sphinxAtStartPar
rD{[}i{]} = rs1{[}i{]} \textgreater{} op2 ? ‘1 : ‘0

\sphinxAtStartPar
Note: Unsigned comparison.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.cmpgeu{[}.sc,.sci{]}\{.h,.b\} rD, rs1, {[}rs2, Imm6{]}}
&
\sphinxAtStartPar
rD{[}i{]} = rs1{[}i{]} \textgreater{}= op2 ? ‘1 : ‘0

\sphinxAtStartPar
Note: Unsigned comparison.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.cmpltu{[}.sc,.sci{]}\{.h,.b\} rD, rs1, {[}rs2, Imm6{]}}
&
\sphinxAtStartPar
rD{[}i{]} = rs1{[}i{]} \textless{} op2 ? ‘1 : ‘0

\sphinxAtStartPar
Note: Unsigned comparison.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.cmpleu{[}.sc,.sci{]}\{.h,.b\} rD, rs1, {[}rs2, Imm6{]}}
&
\sphinxAtStartPar
rD{[}i{]} = rs1{[}i{]} \textless{}= op2 ? ‘1 : ‘0

\sphinxAtStartPar
Note: Unsigned comparison.
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\subsection{SIMD Comparison Encoding}
\label{\detokenize{instruction_set_extensions:simd-comparison-encoding}}

\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{11}{100}\X{4}{100}\X{4}{100}\X{9}{100}\X{7}{100}\X{8}{100}\X{8}{100}\X{13}{100}\X{36}{100}}
\sphinxthelongtablecaptionisattop
\caption{SIMD Comparison encoding\strut}\label{\detokenize{instruction_set_extensions:id25}}\\*[\sphinxlongtablecapskipadjust]
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
31  : 27
&\sphinxstyletheadfamily 
\sphinxAtStartPar
26
&\sphinxstyletheadfamily 
\sphinxAtStartPar
25
&\sphinxstyletheadfamily 
\sphinxAtStartPar
24 : 20
&\sphinxstyletheadfamily 
\sphinxAtStartPar
19 : 15
&\sphinxstyletheadfamily 
\sphinxAtStartPar
14  :   12
&\sphinxstyletheadfamily 
\sphinxAtStartPar
11  :  7
&\sphinxstyletheadfamily 
\sphinxAtStartPar
6    :   0
&\sphinxstyletheadfamily \\
\sphinxhline\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{funct5}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{F}
&\sphinxstyletheadfamily &\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rs2}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rs1}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{funct3}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rD}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{opcode}
&\sphinxstyletheadfamily \\
\sphinxmidrule
\endfirsthead

\multicolumn{9}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
31  : 27
&\sphinxstyletheadfamily 
\sphinxAtStartPar
26
&\sphinxstyletheadfamily 
\sphinxAtStartPar
25
&\sphinxstyletheadfamily 
\sphinxAtStartPar
24 : 20
&\sphinxstyletheadfamily 
\sphinxAtStartPar
19 : 15
&\sphinxstyletheadfamily 
\sphinxAtStartPar
14  :   12
&\sphinxstyletheadfamily 
\sphinxAtStartPar
11  :  7
&\sphinxstyletheadfamily 
\sphinxAtStartPar
6    :   0
&\sphinxstyletheadfamily \\
\sphinxhline\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{funct5}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{F}
&\sphinxstyletheadfamily &\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rs2}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rs1}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{funct3}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rD}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{opcode}
&\sphinxstyletheadfamily \\
\sphinxmidrule
\endhead

\sphinxbottomrule
\multicolumn{9}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
0 0000
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
000
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmpeq.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0000
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
100
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmpeq.sc.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0000
&
\sphinxAtStartPar
1
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
110
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmpeq.sci.h rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
0 0000
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
001
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmpeq.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0000
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
101
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmpeq.sc.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0000
&
\sphinxAtStartPar
1
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
111
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmpeq.sci.b rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
0 0001
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
000
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmpne.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0001
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
100
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmpne.sc.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0001
&
\sphinxAtStartPar
1
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
110
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmpne.sci.h rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
0 0001
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
001
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmpne.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0001
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
101
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmpne.sc.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0001
&
\sphinxAtStartPar
1
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
111
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmpne.sci.b rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
0 0010
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
000
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmpgt.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0010
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
100
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmpgt.sc.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0010
&
\sphinxAtStartPar
1
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
110
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmpgt.sci.h rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
0 0010
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
001
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmpgt.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0010
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
101
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmpgt.sc.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0010
&
\sphinxAtStartPar
1
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
111
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmpgt.sci.b rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
0 0011
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
000
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmpge.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0011
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
100
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmpge.sc.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0011
&
\sphinxAtStartPar
1
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
110
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmpge.sci.h rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
0 0011
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
001
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmpge.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0011
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
101
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmpge.sc.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0011
&
\sphinxAtStartPar
1
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
111
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmpge.sci.b rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
0 0100
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
000
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmplt.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0100
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
100
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmplt.sc.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0100
&
\sphinxAtStartPar
1
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
110
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmplt.sci.h rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
0 0100
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
001
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmplt.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0100
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
101
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmplt.sc.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0100
&
\sphinxAtStartPar
1
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
111
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmplt.sci.b rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
0 0101
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
000
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmple.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0101
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
100
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmple.sc.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0101
&
\sphinxAtStartPar
1
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
110
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmple.sci.h rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
0 0101
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
001
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmple.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0101
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
101
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmple.sc.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0101
&
\sphinxAtStartPar
1
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
111
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmple.sci.b rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
0 0110
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
000
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmpgtu.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0110
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
100
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmpgtu.sc.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0110
&
\sphinxAtStartPar
1
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
110
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmpgtu.sci.h rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
0 0110
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
001
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmpgtu.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0110
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
101
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmpgtu.sc.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0110
&
\sphinxAtStartPar
1
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
111
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmpgtu.sci.b rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
0 0111
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
000
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmpgeu.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0111
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
100
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmpgeu.sc.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0111
&
\sphinxAtStartPar
1
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
110
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmpgeu.sci.h rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
0 0111
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
001
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmpgeu.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0111
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
101
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmpgeu.sc.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 0111
&
\sphinxAtStartPar
1
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
111
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmpgeu.sci.b rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
0 1000
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
000
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmpltu.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 1000
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
100
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmpltu.sc.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 1000
&
\sphinxAtStartPar
1
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
110
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmpltu.sci.h rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
0 1000
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
001
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmpltu.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 1000
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
101
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmpltu.sc.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 1000
&
\sphinxAtStartPar
1
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
111
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmpltu.sci.b rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
0 1001
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
000
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmpleu.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 1001
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
100
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmpleu.sc.h rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 1001
&
\sphinxAtStartPar
1
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
110
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmpleu.sci.h rD, rs1, Imm6}
\\
\sphinxhline
\sphinxAtStartPar
0 1001
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
001
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmpleu.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 1001
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
101
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmpleu.sc.b rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 1001
&
\sphinxAtStartPar
1
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxAtStartPar
Imm6{[}0|5:1{]}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
111
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cmpleu.sci.b rD, rs1, Imm6}
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}


\subsection{SIMD Complex\sphinxhyphen{}number operations}
\label{\detokenize{instruction_set_extensions:simd-complex-number-operations}}
\sphinxAtStartPar
SIMD Complex\sphinxhyphen{}number operations are extra instructions
that uses the packed\sphinxhyphen{}SIMD extentions to represent Complex\sphinxhyphen{}numbers.
These extentions use only the half\sphinxhyphen{}words mode and only operand in registers.
A number C = \{Re, Im\} is represented as a vector of two 16\sphinxhyphen{}Bits signed numbers.
C{[}0{]} is the real part {[}15:0{]}, C{[}1{]} is the
imaginary part {[}31:16{]}.
Such operations are subtraction of 2 complexes with post rotation by \sphinxhyphen{}j, the complex and conjugate,
complex multiplications and complex additions/substractions.
The complex multiplications are performed in two separate instructions, one to compute the real part,
and one to compute the imaginary part.

\sphinxAtStartPar
As for all the other SIMD instructions, no flags are raised and CSR register are unmodified.
No carry, overflow is generated. Instructions are rounded up as the mask \& 0xFFFF explicits.


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{SIMD Complex\sphinxhyphen{}number operations}\label{\detokenize{instruction_set_extensions:id26}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{35}{100}\X{65}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mnemonic}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxstylestrong{cv.cplxmul.r\{/,.div2,.div4,.div8\}}
&
\sphinxAtStartPar
rD{[}1{]} = rD{[}1{]}

\sphinxAtStartPar
rD{[}0{]} = (rs1{[}0{]}*rs2{[}0{]} \sphinxhyphen{} rs1{[}1{]}*rs2{[}1{]}) \textgreater{}\textgreater{} \{15,16,17,18\}

\sphinxAtStartPar
Note: Arithmetic shift right.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.cplxmul.i\{/,.div2,.div4,.div8\}}
&
\sphinxAtStartPar
rD{[}1{]} = (rs1{[}0{]}*rs2{[}1{]} + rs1{[}1{]}*rs2{[}0{]}) \textgreater{}\textgreater{} \{15,16,17,18\}

\sphinxAtStartPar
rD{[}0{]} = rD{[}0{]}

\sphinxAtStartPar
Note: Arithmetic shift right.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.cplxconj}
&
\sphinxAtStartPar
rD{[}1{]} = \sphinxhyphen{}rs1{[}1{]}

\sphinxAtStartPar
rD{[}0{]} = rs1{[}0{]}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.subrotmj\{/,.div2,.div4,.div8\}}
&
\sphinxAtStartPar
rD{[}1{]} = ((rs2{[}0{]} \sphinxhyphen{} rs1{[}0{]}) \& 0xFFFF) \textgreater{}\textgreater{} \{0,1,2,3\}

\sphinxAtStartPar
rD{[}0{]} = ((rs1{[}1{]} \sphinxhyphen{} rs2{[}1{]}) \& 0xFFFF) \textgreater{}\textgreater{} \{0,1,2,3\}

\sphinxAtStartPar
Note: Arithmetic shift right.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.add\{.div2,.div4,.div8\}}
&
\sphinxAtStartPar
rD{[}1{]} = ((rs1{[}1{]} + rs2{[}1{]}) \& 0xFFFF) \textgreater{}\textgreater{} \{1,2,3\}

\sphinxAtStartPar
rD{[}0{]} = ((rs1{[}0{]} + rs2{[}0{]}) \& 0xFFFF) \textgreater{}\textgreater{} \{1,2,3\}

\sphinxAtStartPar
Note: Arithmetic shift right.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{cv.sub\{.div2,.div4,.div8\}}
&
\sphinxAtStartPar
rD{[}1{]} = ((rs1{[}1{]} \sphinxhyphen{} rs2{[}1{]}) \& 0xFFFF) \textgreater{}\textgreater{} \{1,2,3\}

\sphinxAtStartPar
rD{[}0{]} = ((rs1{[}0{]} \sphinxhyphen{} rs2{[}0{]}) \& 0xFFFF) \textgreater{}\textgreater{} \{1,2,3\}

\sphinxAtStartPar
Note: Arithmetic shift right.
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\subsection{SIMD Complex\sphinxhyphen{}number Encoding}
\label{\detokenize{instruction_set_extensions:simd-complex-number-encoding}}

\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{SIMD Complex\sphinxhyphen{}number encoding}\label{\detokenize{instruction_set_extensions:id27}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{11}{100}\X{4}{100}\X{4}{100}\X{9}{100}\X{7}{100}\X{8}{100}\X{8}{100}\X{13}{100}\X{36}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
31  : 27
&\sphinxstyletheadfamily 
\sphinxAtStartPar
26
&\sphinxstyletheadfamily 
\sphinxAtStartPar
25
&\sphinxstyletheadfamily 
\sphinxAtStartPar
24 : 20
&\sphinxstyletheadfamily 
\sphinxAtStartPar
19 : 15
&\sphinxstyletheadfamily 
\sphinxAtStartPar
14   :  12
&\sphinxstyletheadfamily 
\sphinxAtStartPar
11  :  7
&\sphinxstyletheadfamily 
\sphinxAtStartPar
6    :   0
&\sphinxstyletheadfamily \\
\sphinxhline\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{funct5}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{F}
&\sphinxstyletheadfamily &\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rs2}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rs1}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{funct3}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{rD}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{opcode}
&\sphinxstyletheadfamily \\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
0 1010
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
000
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cplxmul.r rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 1010
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
010
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cplxmul.r.div2 rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 1010
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
100
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cplxmul.r.div4 rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 1010
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
110
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cplxmul.r.div8 rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 1010
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
000
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cplxmul.i rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 1010
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
010
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cplxmul.i.div2 rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 1010
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
100
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cplxmul.i.div4 rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 1010
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
110
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cplxmul.i.div8 rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 1011
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
00000
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
000
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.cplxconj rD, rs1}
\\
\sphinxhline
\sphinxAtStartPar
0 1100
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
000
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.subrotmj rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 1100
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
010
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.subrotmj.div2 rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 1100
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
100
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.subrotmj.div4 rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 1100
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
110
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.subrotmj.div8 rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 1101
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
010
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.add.div2 rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 1101
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
100
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.add.div4 rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 1101
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
110
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.add.div8 rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 1110
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
010
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.sub.div2 rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 1110
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
100
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.sub.div4 rD, rs1, rs2}
\\
\sphinxhline
\sphinxAtStartPar
0 1110
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
src2
&
\sphinxAtStartPar
src1
&
\sphinxAtStartPar
110
&
\sphinxAtStartPar
dest
&
\sphinxAtStartPar
111 1011
&
\sphinxAtStartPar
\sphinxstylestrong{cv.sub.div8 rD, rs1, rs2}
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxstepscope


\chapter{Performance Counters}
\label{\detokenize{perf_counters:performance-counters}}\label{\detokenize{perf_counters:id1}}\label{\detokenize{perf_counters::doc}}
\sphinxAtStartPar
CV32E40P implements performance counters according to the RISC\sphinxhyphen{}V Privileged Specification, version 1.11 (see Hardware Performance Monitor, Section 3.1.11).
The performance counters are placed inside the Control and Status Registers (CSRs) and can be accessed with the \sphinxcode{\sphinxupquote{CSRRW(I)}} and \sphinxcode{\sphinxupquote{CSRRS/C(I)}} instructions.

\sphinxAtStartPar
CV32E40P implements the clock cycle counter \sphinxcode{\sphinxupquote{mcycle(h)}}, the retired instruction counter \sphinxcode{\sphinxupquote{minstret(h)}}, as well as the parameterizable number of event counters
\sphinxcode{\sphinxupquote{mhpmcounter3(h)}} \sphinxhyphen{} \sphinxcode{\sphinxupquote{mhpmcounter31(h)}} and the corresponding event selector CSRs \sphinxcode{\sphinxupquote{mhpmevent3}} \sphinxhyphen{} \sphinxcode{\sphinxupquote{mhpmevent31}}, and the \sphinxcode{\sphinxupquote{mcountinhibit}} CSR to individually enable/disable the counters.
\sphinxcode{\sphinxupquote{mcycle(h)}} and \sphinxcode{\sphinxupquote{minstret(h)}} are always available.

\sphinxAtStartPar
All counters are 64 bit wide.

\sphinxAtStartPar
The number of event counters is determined by the parameter \sphinxcode{\sphinxupquote{NUM\_MHPMCOUNTERS}} with a range from 0 to 29 (default value of 1).

\sphinxAtStartPar
Unimplemented counters always read 0.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
All performance counters are using the gated version of \sphinxcode{\sphinxupquote{clk\_i}}. The \sphinxstylestrong{wfi} instruction, the
\sphinxstylestrong{cv.elw} instruction, and \sphinxcode{\sphinxupquote{pulp\_clock\_en\_i}} impact the gating of \sphinxcode{\sphinxupquote{clk\_i}} as explained
in {\hyperref[\detokenize{sleep:sleep-unit}]{\sphinxcrossref{\DUrole{std,std-ref}{Sleep Unit}}}} and can therefore affect the counters.
\end{sphinxadmonition}


\section{Event Selector}
\label{\detokenize{perf_counters:event-selector}}\label{\detokenize{perf_counters:id2}}
\sphinxAtStartPar
The following events can be monitored using the performance counters of CV32E40P.


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Event Selector}\label{\detokenize{perf_counters:id3}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{10}{95}\X{20}{95}\X{65}{95}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Bit \#}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Event Name}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
0
&
\sphinxAtStartPar
CYCLES
&
\sphinxAtStartPar
Number of cycles
\\
\sphinxhline
\sphinxAtStartPar
1
&
\sphinxAtStartPar
INSTR
&
\sphinxAtStartPar
Number of instructions retired
\\
\sphinxhline
\sphinxAtStartPar
2
&
\sphinxAtStartPar
LD\_STALL
&
\sphinxAtStartPar
Number of load use hazards
\\
\sphinxhline
\sphinxAtStartPar
3
&
\sphinxAtStartPar
JMP\_STALL
&
\sphinxAtStartPar
Number of jump register hazards
\\
\sphinxhline
\sphinxAtStartPar
4
&
\sphinxAtStartPar
IMISS
&
\sphinxAtStartPar
Cycles waiting for instruction fethces,
excluding jumps and branches
\\
\sphinxhline
\sphinxAtStartPar
5
&
\sphinxAtStartPar
LD
&
\sphinxAtStartPar
Number of load instructions
\\
\sphinxhline
\sphinxAtStartPar
6
&
\sphinxAtStartPar
ST
&
\sphinxAtStartPar
Number of store instructions
\\
\sphinxhline
\sphinxAtStartPar
7
&
\sphinxAtStartPar
JUMP
&
\sphinxAtStartPar
Number of jumps (unconditional)
\\
\sphinxhline
\sphinxAtStartPar
8
&
\sphinxAtStartPar
BRANCH
&
\sphinxAtStartPar
Number of branches (conditional)
\\
\sphinxhline
\sphinxAtStartPar
9
&
\sphinxAtStartPar
BRANCH\_TAKEN
&
\sphinxAtStartPar
Number of branches taken (conditional)
\\
\sphinxhline
\sphinxAtStartPar
10
&
\sphinxAtStartPar
COMP\_INSTR
&
\sphinxAtStartPar
Number of compressed instructions retired
\\
\sphinxhline
\sphinxAtStartPar
11
&
\sphinxAtStartPar
PIPE\_STALL
&
\sphinxAtStartPar
Cycles from stalled pipeline
\\
\sphinxhline
\sphinxAtStartPar
12
&
\sphinxAtStartPar
APU\_TYPE
&
\sphinxAtStartPar
Numbe of type conflicts on APU/FP
\\
\sphinxhline
\sphinxAtStartPar
13
&
\sphinxAtStartPar
APU\_CONT
&
\sphinxAtStartPar
Number of contentions on APU/FP
\\
\sphinxhline
\sphinxAtStartPar
14
&
\sphinxAtStartPar
APU\_DEP
&
\sphinxAtStartPar
Number of dependency stall on APU/FP
\\
\sphinxhline
\sphinxAtStartPar
15
&
\sphinxAtStartPar
APU\_WB
&
\sphinxAtStartPar
Number of write backs on APUB/FP
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
The event selector CSRs \sphinxcode{\sphinxupquote{mhpmevent3}} \sphinxhyphen{} \sphinxcode{\sphinxupquote{mhpmevent31}} define which of these events are counted by the event counters \sphinxcode{\sphinxupquote{mhpmcounter3(h)}} \sphinxhyphen{} \sphinxcode{\sphinxupquote{mhpmcounter31(h)}}.
If a specific bit in an event selector CSR is set to 1, this means that events with this ID are being counted by the counter associated with that selector CSR.
If an event selector CSR is 0, this means that the corresponding counter is not counting any event.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
At most 1 bit should be set in an event selector. If multiple bits are set in an event selector, then the operation of the associated counter is undefined.
\end{sphinxadmonition}


\section{Controlling the counters from software}
\label{\detokenize{perf_counters:controlling-the-counters-from-software}}
\sphinxAtStartPar
By default, all available counters are disabled after reset in order to provide the lowest power consumption.

\sphinxAtStartPar
They can be individually enabled/disabled by overwriting the corresponding bit in the \sphinxcode{\sphinxupquote{mcountinhibit}} CSR at address \sphinxcode{\sphinxupquote{0x320}} as described in the RISC\sphinxhyphen{}V Privileged Specification,
version 1.11 (see Machine Counter\sphinxhyphen{}Inhibit CSR, Section 3.1.13).
In particular, to enable/disable \sphinxcode{\sphinxupquote{mcycle(h)}}, bit 0 must be written. For \sphinxcode{\sphinxupquote{minstret(h)}}, it is bit 2. For event counter \sphinxcode{\sphinxupquote{mhpmcounterX(h)}}, it is bit X.

\sphinxAtStartPar
The lower 32 bits of all counters can be accessed through the base register, whereas the upper 32 bits are accessed through the \sphinxcode{\sphinxupquote{h}}\sphinxhyphen{}register.
Reads of all these registers are non\sphinxhyphen{}destructive.


\section{Parametrization at synthesis time}
\label{\detokenize{perf_counters:parametrization-at-synthesis-time}}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{mcycle(h)}} and \sphinxcode{\sphinxupquote{minstret(h)}} counters are always available and 64 bit wide.

\sphinxAtStartPar
The number of available event counters \sphinxcode{\sphinxupquote{mhpmcounterX(h)}} can be controlled via the \sphinxcode{\sphinxupquote{NUM\_MHPMCOUNTERS}} parameter.
By default \sphinxcode{\sphinxupquote{NUM\_MHPCOUNTERS}} set to 1.

\sphinxAtStartPar
An increment of 1 to the NUM\_MHPCOUNTERS results in the addition of the following:
\begin{itemize}
\item {} 
\sphinxAtStartPar
64 flops for \sphinxcode{\sphinxupquote{mhpmcounterX}}

\item {} 
\sphinxAtStartPar
15 flops for \sphinxtitleref{mhpmeventX}

\item {} 
\sphinxAtStartPar
1 flop  for \sphinxtitleref{mcountinhibit{[}X{]}}

\item {} 
\sphinxAtStartPar
Adder and event enablement logic

\end{itemize}


\section{Time Registers (\sphinxstyleliteralintitle{\sphinxupquote{time(h)}})}
\label{\detokenize{perf_counters:time-registers-time-h}}
\sphinxAtStartPar
The user mode \sphinxcode{\sphinxupquote{time(h)}} registers are not implemented. Any access to these
registers will cause an illegal instruction trap. It is recommended that a software trap handler is
implemented to detect access of these CSRs and convert that into access of the
platform\sphinxhyphen{}defined \sphinxcode{\sphinxupquote{mtime}} register (if implemented in the platform).

\sphinxstepscope


\chapter{Control and Status Registers}
\label{\detokenize{control_status_registers:control-and-status-registers}}\label{\detokenize{control_status_registers:cs-registers}}\label{\detokenize{control_status_registers::doc}}
\sphinxAtStartPar
CV32E40P does not implement all control and status registers specified in
the RISC\sphinxhyphen{}V privileged specifications, but is limited to the registers
that were needed for the PULP system. The reason for this is that we
wanted to keep the footprint of the core as low as possible and avoid
any overhead that we do not explicitly need.


\section{CSR Map}
\label{\detokenize{control_status_registers:csr-map}}
\sphinxAtStartPar
\hyperref[\detokenize{control_status_registers:control-and-status-register-map}]{Table \ref{\detokenize{control_status_registers:control-and-status-register-map}}} lists all
implemented CSRs.  Two columns in \hyperref[\detokenize{control_status_registers:control-and-status-register-map}]{Table \ref{\detokenize{control_status_registers:control-and-status-register-map}}} may require additional explanation:

\sphinxAtStartPar
The \sphinxstylestrong{Privilege} column indicates the access mode of a CSR. The first letter
indicates the lowest privilege level required to access the CSR. Attempts to
access a CSR with a higher privilege level than the core is currently running
in will throw an illegal instruction exception.  This is largely a moot point
for the CV32E40P as it only supports machine and debug modes. The remaining
letters indicate the read and/or write behavior of the CSR when accessed by
the indicated or higher privilge level:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{RW}: CSR is \sphinxstylestrong{read\sphinxhyphen{}write}.  That is, CSR instructions (e.g. csrrw) may
write any value and that value will be returned on a subsequent read (unless
a side\sphinxhyphen{}effect causes the core to change the CSR value).

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{RO}: CSR is \sphinxstylestrong{read\sphinxhyphen{}only}.  Writes by CSR instructions raise an illegal
instruction exception.

\end{itemize}

\sphinxAtStartPar
Writes of a non\sphinxhyphen{}supported value to \sphinxstylestrong{WLRL} bitfields of a \sphinxstylestrong{RW} CSR do not result in an illegal
instruction exception. The exact bitfield access types, e.g. \sphinxstylestrong{WLRL} or \sphinxstylestrong{WARL}, can be found in the RISC\sphinxhyphen{}V
privileged specification.

\sphinxAtStartPar
In the \sphinxstylestrong{Description} column there is a specific comment which identifies those CSRs that are dependent on the value
of specific parameters. If these parameters are not set as
indicated in \hyperref[\detokenize{control_status_registers:control-and-status-register-map}]{Table \ref{\detokenize{control_status_registers:control-and-status-register-map}}} then the associated CSR is not implemented. If the column does not
mention any parameter then the associated CSR is always implemented.

\sphinxAtStartPar
Reads or writes to a CSR that is not implemented will result in an illegal
instruction exception.


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{13}{100}\X{17}{100}\X{15}{100}\X{55}{100}}
\sphinxthelongtablecaptionisattop
\caption{Control and Status Register Map\strut}\label{\detokenize{control_status_registers:control-and-status-register-map}}\\*[\sphinxlongtablecapskipadjust]
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{CSR Address}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Privilege}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\endfirsthead

\multicolumn{4}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{CSR Address}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Privilege}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\endhead

\sphinxbottomrule
\multicolumn{4}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook
\sphinxstartmulticolumn{4}%
\begin{varwidth}[t]{\sphinxcolwidth{4}{4}}
\sphinxAtStartPar
\sphinxstylestrong{User CSRs}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\sphinxhline
\sphinxAtStartPar
0x001
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fflags}}
&
\sphinxAtStartPar
URW
&
\sphinxAtStartPar
Floating\sphinxhyphen{}point accrued exceptions.

\sphinxAtStartPar
Only present if \sphinxcode{\sphinxupquote{FPU}} = 1
\\
\sphinxhline
\sphinxAtStartPar
0x002
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{frm}}
&
\sphinxAtStartPar
URW
&
\sphinxAtStartPar
Floating\sphinxhyphen{}point dynamic rounding mode.

\sphinxAtStartPar
Only present if \sphinxcode{\sphinxupquote{FPU}} = 1
\\
\sphinxhline
\sphinxAtStartPar
0x003
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fcsr}}
&
\sphinxAtStartPar
URW
&
\sphinxAtStartPar
Floating\sphinxhyphen{}point control and status register.

\sphinxAtStartPar
Only present if \sphinxcode{\sphinxupquote{FPU}} = 1
\\
\sphinxhline
\sphinxAtStartPar
0xC00
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cycle}}
&
\sphinxAtStartPar
URO
&
\sphinxAtStartPar
(HPM) Cycle Counter
\\
\sphinxhline
\sphinxAtStartPar
0xC02
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{instret}}
&
\sphinxAtStartPar
URO
&
\sphinxAtStartPar
(HPM) Instructions\sphinxhyphen{}Retired Counter
\\
\sphinxhline
\sphinxAtStartPar
0xC03
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hpmcounter3}}
&
\sphinxAtStartPar
URO
&
\sphinxAtStartPar
(HPM) Performance\sphinxhyphen{}Monitoring Counter 3
\\
\sphinxhline\sphinxstartmulticolumn{4}%
\begin{varwidth}[t]{\sphinxcolwidth{4}{4}}
\sphinxAtStartPar
.                 .                   .               .
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\sphinxhline
\sphinxAtStartPar
0xC1F
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hpmcounter31}}
&
\sphinxAtStartPar
URO
&
\sphinxAtStartPar
(HPM) Performance\sphinxhyphen{}Monitoring Counter 31
\\
\sphinxhline
\sphinxAtStartPar
0xC80
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cycleh}}
&
\sphinxAtStartPar
URO
&
\sphinxAtStartPar
(HPM) Upper 32 bits Cycle Counter
\\
\sphinxhline
\sphinxAtStartPar
0xC82
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{instreth}}
&
\sphinxAtStartPar
URO
&
\sphinxAtStartPar
(HPM) Upper 32 bits Instructions\sphinxhyphen{}Retired Counter
\\
\sphinxhline
\sphinxAtStartPar
0xC83
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hpmcounterh3}}
&
\sphinxAtStartPar
URO
&
\sphinxAtStartPar
(HPM) Upper 32 bits Performance\sphinxhyphen{}Monitoring Counter 3
\\
\sphinxhline\sphinxstartmulticolumn{4}%
\begin{varwidth}[t]{\sphinxcolwidth{4}{4}}
\sphinxAtStartPar
.                 .                   .               .
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\sphinxhline
\sphinxAtStartPar
0xC9F
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hpmcounterh31}}
&
\sphinxAtStartPar
URO
&
\sphinxAtStartPar
(HPM) Upper 32 bits Performance\sphinxhyphen{}Monitoring Counter 31
\\
\sphinxhline\sphinxstartmulticolumn{4}%
\begin{varwidth}[t]{\sphinxcolwidth{4}{4}}
\sphinxAtStartPar
\sphinxstylestrong{User Custom CSRs}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\sphinxhline
\sphinxAtStartPar
0xCC0
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{lpstart0}}
&
\sphinxAtStartPar
URO
&
\sphinxAtStartPar
Hardware Loop 0 Start.

\sphinxAtStartPar
Only present if \sphinxcode{\sphinxupquote{COREV\_PULP}} = 1
\\
\sphinxhline
\sphinxAtStartPar
0xCC1
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{lpend0}}
&
\sphinxAtStartPar
URO
&
\sphinxAtStartPar
Hardware Loop 0 End.

\sphinxAtStartPar
Only present if \sphinxcode{\sphinxupquote{COREV\_PULP}} = 1
\\
\sphinxhline
\sphinxAtStartPar
0xCC2
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{lpcount0}}
&
\sphinxAtStartPar
URO
&
\sphinxAtStartPar
Hardware Loop 0 Counter.

\sphinxAtStartPar
Only present if \sphinxcode{\sphinxupquote{COREV\_PULP}} = 1
\\
\sphinxhline
\sphinxAtStartPar
0xCC4
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{lpstart1}}
&
\sphinxAtStartPar
URO
&
\sphinxAtStartPar
Hardware Loop 1 Start.

\sphinxAtStartPar
Only present if \sphinxcode{\sphinxupquote{COREV\_PULP}} = 1
\\
\sphinxhline
\sphinxAtStartPar
0xCC5
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{lpend1}}
&
\sphinxAtStartPar
URO
&
\sphinxAtStartPar
Hardware Loop 1 End.

\sphinxAtStartPar
Only present if \sphinxcode{\sphinxupquote{COREV\_PULP}} = 1
\\
\sphinxhline
\sphinxAtStartPar
0xCC6
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{lpcount1}}
&
\sphinxAtStartPar
URO
&
\sphinxAtStartPar
Hardware Loop 1 Counter.

\sphinxAtStartPar
Only present if \sphinxcode{\sphinxupquote{COREV\_PULP}} = 1
\\
\sphinxhline
\sphinxAtStartPar
0xCD0
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{uhartid}}
&
\sphinxAtStartPar
URO
&
\sphinxAtStartPar
Hardware Thread ID

\sphinxAtStartPar
Only present if \sphinxcode{\sphinxupquote{COREV\_PULP}} = 1
\\
\sphinxhline
\sphinxAtStartPar
0xCD1
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{privlv}}
&
\sphinxAtStartPar
URO
&
\sphinxAtStartPar
Privilege Level

\sphinxAtStartPar
Only present if \sphinxcode{\sphinxupquote{COREV\_PULP}} = 1
\\
\sphinxhline
\sphinxAtStartPar
0xCD2
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{zfinx}}
&
\sphinxAtStartPar
URO
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ZFINX}} ISA

\sphinxAtStartPar
Only present if
\sphinxcode{\sphinxupquote{COREV\_PULP}} = 1 \& (\sphinxcode{\sphinxupquote{FPU}} = 0 | (\sphinxcode{\sphinxupquote{FPU}} = 1 \& \sphinxcode{\sphinxupquote{ZFINX}} = 1))
\\
\sphinxhline\sphinxstartmulticolumn{4}%
\begin{varwidth}[t]{\sphinxcolwidth{4}{4}}
\sphinxAtStartPar
\sphinxstylestrong{Machine CSRs}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\sphinxhline
\sphinxAtStartPar
0x300
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mstatus}}
&
\sphinxAtStartPar
MRW
&
\sphinxAtStartPar
Machine Status
\\
\sphinxhline
\sphinxAtStartPar
0x301
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{misa}}
&
\sphinxAtStartPar
MRW
&
\sphinxAtStartPar
Machine ISA
\\
\sphinxhline
\sphinxAtStartPar
0x304
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mie}}
&
\sphinxAtStartPar
MRW
&
\sphinxAtStartPar
Machine Interrupt Enable register
\\
\sphinxhline
\sphinxAtStartPar
0x305
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mtvec}}
&
\sphinxAtStartPar
MRW
&
\sphinxAtStartPar
Machine Trap\sphinxhyphen{}Handler Base Address
\\
\sphinxhline
\sphinxAtStartPar
0x320
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mcountinhibit}}
&
\sphinxAtStartPar
MRW
&
\sphinxAtStartPar
(HPM) Machine Counter\sphinxhyphen{}Inhibit register
\\
\sphinxhline
\sphinxAtStartPar
0x323
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mhpmevent3}}
&
\sphinxAtStartPar
MRW
&
\sphinxAtStartPar
(HPM) Machine Performance\sphinxhyphen{}Monitoring Event Selector 3
\\
\sphinxhline\sphinxstartmulticolumn{4}%
\begin{varwidth}[t]{\sphinxcolwidth{4}{4}}
\sphinxAtStartPar
.                 .                   .               .
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\sphinxhline
\sphinxAtStartPar
0x33F
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mhpmevent31}}
&
\sphinxAtStartPar
MRW
&
\sphinxAtStartPar
(HPM) Machine Performance\sphinxhyphen{}Monitoring Event Selector 31
\\
\sphinxhline
\sphinxAtStartPar
0x340
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mscratch}}
&
\sphinxAtStartPar
MRW
&
\sphinxAtStartPar
Machine Scratch
\\
\sphinxhline
\sphinxAtStartPar
0x341
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mepc}}
&
\sphinxAtStartPar
MRW
&
\sphinxAtStartPar
Machine Exception Program Counter
\\
\sphinxhline
\sphinxAtStartPar
0x342
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mcause}}
&
\sphinxAtStartPar
MRW
&
\sphinxAtStartPar
Machine Trap Cause
\\
\sphinxhline
\sphinxAtStartPar
0x343
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mtval}}
&
\sphinxAtStartPar
MRW
&
\sphinxAtStartPar
Machine Trap Value
\\
\sphinxhline
\sphinxAtStartPar
0x344
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mip}}
&
\sphinxAtStartPar
MRW
&
\sphinxAtStartPar
Machine Interrupt Pending register
\\
\sphinxhline
\sphinxAtStartPar
0x7A0
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tselect}}
&
\sphinxAtStartPar
MRW
&
\sphinxAtStartPar
Trigger Select register
\\
\sphinxhline
\sphinxAtStartPar
0x7A1
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tdata1}}
&
\sphinxAtStartPar
MRW
&
\sphinxAtStartPar
Trigger Data register 1
\\
\sphinxhline
\sphinxAtStartPar
0x7A2
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tdata2}}
&
\sphinxAtStartPar
MRW
&
\sphinxAtStartPar
Trigger Data register 2
\\
\sphinxhline
\sphinxAtStartPar
0x7A3
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tdata3}}
&
\sphinxAtStartPar
MRW
&
\sphinxAtStartPar
Trigger Data register 3
\\
\sphinxhline
\sphinxAtStartPar
0x7A4
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tinfo}}
&
\sphinxAtStartPar
MRO
&
\sphinxAtStartPar
Trigger Info
\\
\sphinxhline
\sphinxAtStartPar
0x7A8
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mcontext}}
&
\sphinxAtStartPar
MRW
&
\sphinxAtStartPar
Machine Context register
\\
\sphinxhline
\sphinxAtStartPar
0x7AA
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{scontext}}
&
\sphinxAtStartPar
MRW
&
\sphinxAtStartPar
Machine Context register
\\
\sphinxhline
\sphinxAtStartPar
0x7B0
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dcsr}}
&
\sphinxAtStartPar
DRW
&
\sphinxAtStartPar
Debug Control and Status
\\
\sphinxhline
\sphinxAtStartPar
0x7B1
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dpc}}
&
\sphinxAtStartPar
DRW
&
\sphinxAtStartPar
Debug PC
\\
\sphinxhline
\sphinxAtStartPar
0x7B2
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dscratch0}}
&
\sphinxAtStartPar
DRW
&
\sphinxAtStartPar
Debug Scratch register 0
\\
\sphinxhline
\sphinxAtStartPar
0x7B3
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dscratch1}}
&
\sphinxAtStartPar
DRW
&
\sphinxAtStartPar
Debug Scratch register 1
\\
\sphinxhline
\sphinxAtStartPar
0xB00
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mcycle}}
&
\sphinxAtStartPar
MRW
&
\sphinxAtStartPar
(HPM) Machine Cycle Counter
\\
\sphinxhline
\sphinxAtStartPar
0xB02
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{minstret}}
&
\sphinxAtStartPar
MRW
&
\sphinxAtStartPar
(HPM) Machine Instructions\sphinxhyphen{}Retired Counter
\\
\sphinxhline
\sphinxAtStartPar
0xB03
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mhpmcounter3}}
&
\sphinxAtStartPar
MRW
&
\sphinxAtStartPar
(HPM) Machine Performance\sphinxhyphen{}Monitoring Counter 3
\\
\sphinxhline\sphinxstartmulticolumn{4}%
\begin{varwidth}[t]{\sphinxcolwidth{4}{4}}
\sphinxAtStartPar
.                 .                   .               .
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\sphinxhline
\sphinxAtStartPar
0xB1F
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mhpmcounter31}}
&
\sphinxAtStartPar
MRW
&
\sphinxAtStartPar
(HPM) Machine Performance\sphinxhyphen{}Monitoring Counter 31
\\
\sphinxhline
\sphinxAtStartPar
0xB80
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mcycleh}}
&
\sphinxAtStartPar
MRW
&
\sphinxAtStartPar
(HPM) Upper 32 bits Machine Cycle Counter
\\
\sphinxhline
\sphinxAtStartPar
0xB82
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{minstreth}}
&
\sphinxAtStartPar
MRW
&
\sphinxAtStartPar
(HPM) Upper 32 bits Machine Instructions\sphinxhyphen{}Retired Counter
\\
\sphinxhline
\sphinxAtStartPar
0xB83
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mhpmcounterh3}}
&
\sphinxAtStartPar
MRW
&
\sphinxAtStartPar
(HPM) Upper 32 bits Machine Performance\sphinxhyphen{}Monitoring Counter 3
\\
\sphinxhline\sphinxstartmulticolumn{4}%
\begin{varwidth}[t]{\sphinxcolwidth{4}{4}}
\sphinxAtStartPar
.                 .                   .               .
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\sphinxhline
\sphinxAtStartPar
0xB9F
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mhpmcounterh31}}
&
\sphinxAtStartPar
MRW
&
\sphinxAtStartPar
(HPM) Upper 32 bits Machine Performance\sphinxhyphen{}Monitoring Counter 31
\\
\sphinxhline
\sphinxAtStartPar
0xF11
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mvendorid}}
&
\sphinxAtStartPar
MRO
&
\sphinxAtStartPar
Machine Vendor ID
\\
\sphinxhline
\sphinxAtStartPar
0xF12
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{marchid}}
&
\sphinxAtStartPar
MRO
&
\sphinxAtStartPar
Machine Architecture ID
\\
\sphinxhline
\sphinxAtStartPar
0xF13
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mimpid}}
&
\sphinxAtStartPar
MRO
&
\sphinxAtStartPar
Machine Implementation ID
\\
\sphinxhline
\sphinxAtStartPar
0xF14
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mhartid}}
&
\sphinxAtStartPar
MRO
&
\sphinxAtStartPar
Hardware Thread ID
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}


\section{CSR Descriptions}
\label{\detokenize{control_status_registers:csr-descriptions}}
\sphinxAtStartPar
What follows is a detailed definition of each of the CSRs listed above. The
\sphinxstylestrong{Mode} column defines the access mode behavior of each bit field when
accessed by the privilege level specified in \hyperref[\detokenize{control_status_registers:control-and-status-register-map}]{Table \ref{\detokenize{control_status_registers:control-and-status-register-map}}} (or a higher privilege
level):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{RO}: \sphinxstylestrong{read\sphinxhyphen{}only} fields are not affect by CSR write instructions.  Such
fields either return a fixed value, or a value determined by the operation of
the core.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{RW}: \sphinxstylestrong{read/write} fields store the value written by CSR writes. Subsequent
reads return either the previously written value or a value determined by the
operation of the core.

\end{itemize}


\subsection{Floating\sphinxhyphen{}point CSRs}
\label{\detokenize{control_status_registers:floating-point-csrs}}

\subsubsection{Floating\sphinxhyphen{}point accrued exceptions (\sphinxstyleliteralintitle{\sphinxupquote{fflags}})}
\label{\detokenize{control_status_registers:floating-point-accrued-exceptions-fflags}}\label{\detokenize{control_status_registers:csr-fflags}}
\sphinxAtStartPar
CSR Address: 0x001 (only present if \sphinxcode{\sphinxupquote{FPU}} = 1)

\sphinxAtStartPar
Reset Value: 0x0000\_0000

\sphinxAtStartPar
Detailed:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabular}[t]{\X{15}{100}\X{15}{100}\X{70}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Bit \#}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mode}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
31:5
&
\sphinxAtStartPar
RO
&
\sphinxAtStartPar
Writes are ignored; reads return 0.
\\
\sphinxhline
\sphinxAtStartPar
4
&
\sphinxAtStartPar
RW
&
\sphinxAtStartPar
NV \sphinxhyphen{} Invalid Operation
\\
\sphinxhline
\sphinxAtStartPar
3
&
\sphinxAtStartPar
RW
&
\sphinxAtStartPar
DZ \sphinxhyphen{} Divide by Zero
\\
\sphinxhline
\sphinxAtStartPar
2
&
\sphinxAtStartPar
RW
&
\sphinxAtStartPar
OF \sphinxhyphen{} Overflow
\\
\sphinxhline
\sphinxAtStartPar
1
&
\sphinxAtStartPar
RW
&
\sphinxAtStartPar
UF \sphinxhyphen{} Underflow
\\
\sphinxhline
\sphinxAtStartPar
0
&
\sphinxAtStartPar
RW
&
\sphinxAtStartPar
NX \sphinxhyphen{} Inexact
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\subsubsection{Floating\sphinxhyphen{}point dynamic rounding mode (\sphinxstyleliteralintitle{\sphinxupquote{frm}})}
\label{\detokenize{control_status_registers:floating-point-dynamic-rounding-mode-frm}}\label{\detokenize{control_status_registers:csr-frm}}
\sphinxAtStartPar
CSR Address: 0x002 (only present if \sphinxcode{\sphinxupquote{FPU}} = 1)

\sphinxAtStartPar
Reset Value: 0x0000\_0000

\sphinxAtStartPar
Detailed:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabular}[t]{\X{15}{100}\X{15}{100}\X{70}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Bit \#}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mode}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
31:3
&
\sphinxAtStartPar
RO
&
\sphinxAtStartPar
Writes are ignored; reads return 0.
\\
\sphinxhline
\sphinxAtStartPar
2:0
&
\sphinxAtStartPar
RW
&
\sphinxAtStartPar
Rounding mode:

\sphinxAtStartPar
000 = RNE

\sphinxAtStartPar
001 = RTZ

\sphinxAtStartPar
010 = RDN

\sphinxAtStartPar
011 = RUP

\sphinxAtStartPar
100 = RMM

\sphinxAtStartPar
101 = Invalid

\sphinxAtStartPar
110 = Invalid

\sphinxAtStartPar
111 = DYN
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\subsubsection{Floating\sphinxhyphen{}point control and status register (\sphinxstyleliteralintitle{\sphinxupquote{fcsr}})}
\label{\detokenize{control_status_registers:floating-point-control-and-status-register-fcsr}}\label{\detokenize{control_status_registers:csr-fcsr}}
\sphinxAtStartPar
CSR Address: 0x003 (only present if \sphinxcode{\sphinxupquote{FPU}} = 1)

\sphinxAtStartPar
Reset Value: 0x0000\_0000

\sphinxAtStartPar
Detailed:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabular}[t]{\X{15}{100}\X{15}{100}\X{70}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Bit \#}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mode}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
31:8
&
\sphinxAtStartPar
RO
&
\sphinxAtStartPar
Reserved. Writes are ignored; reads return 0.
\\
\sphinxhline
\sphinxAtStartPar
7:5
&
\sphinxAtStartPar
RW
&
\sphinxAtStartPar
Rounding Mode (\sphinxcode{\sphinxupquote{frm}})
\\
\sphinxhline
\sphinxAtStartPar
4:0
&
\sphinxAtStartPar
RW
&
\sphinxAtStartPar
Accrued Exceptions (\sphinxcode{\sphinxupquote{fflags}})
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\subsection{Hardware Loops CSRs}
\label{\detokenize{control_status_registers:hardware-loops-csrs}}

\subsubsection{HWLoop Start Address 0/1 (\sphinxstyleliteralintitle{\sphinxupquote{lpstart0/1}})}
\label{\detokenize{control_status_registers:hwloop-start-address-0-1-lpstart0-1}}
\sphinxAtStartPar
CSR Address: 0xCC0/0xCC4 (only present if \sphinxcode{\sphinxupquote{COREV\_PULP}} = 1)

\sphinxAtStartPar
Reset Value: 0x0000\_0000

\sphinxAtStartPar
Detailed:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabular}[t]{\X{15}{100}\X{15}{100}\X{70}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Bit \#}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mode}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
31:2
&
\sphinxAtStartPar
URO
&
\sphinxAtStartPar
Start Address of the HWLoop 0/1.
\\
\sphinxhline
\sphinxAtStartPar
1:0
&
\sphinxAtStartPar
URO
&
\sphinxAtStartPar
0
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\subsubsection{HWLoop End Address 0/1 (\sphinxstyleliteralintitle{\sphinxupquote{lpend0/1}})}
\label{\detokenize{control_status_registers:hwloop-end-address-0-1-lpend0-1}}
\sphinxAtStartPar
CSR Address: 0xCC1/0xCC5 (only present if \sphinxcode{\sphinxupquote{COREV\_PULP}} = 1)

\sphinxAtStartPar
Reset Value: 0x0000\_0000

\sphinxAtStartPar
Detailed:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabular}[t]{\X{15}{100}\X{15}{100}\X{70}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Bit \#}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mode}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
31:2
&
\sphinxAtStartPar
URO
&
\sphinxAtStartPar
End Address of the HWLoop 0/1.
\\
\sphinxhline
\sphinxAtStartPar
1:0
&
\sphinxAtStartPar
URO
&
\sphinxAtStartPar
0
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\subsubsection{HWLoop Count Address 0/1 (\sphinxstyleliteralintitle{\sphinxupquote{lpcount0/1}})}
\label{\detokenize{control_status_registers:hwloop-count-address-0-1-lpcount0-1}}
\sphinxAtStartPar
CSR Address: 0xCC2/0xCC6 (only present if \sphinxcode{\sphinxupquote{COREV\_PULP}} = 1)

\sphinxAtStartPar
Reset Value: 0x0000\_0000

\sphinxAtStartPar
Detailed:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabular}[t]{\X{15}{100}\X{15}{100}\X{70}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Bit \#}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mode}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
31:0
&
\sphinxAtStartPar
URO
&
\sphinxAtStartPar
Number of iteration of HWLoop 0/1.
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\subsection{Other CSRs}
\label{\detokenize{control_status_registers:other-csrs}}

\subsubsection{Machine Status (\sphinxstyleliteralintitle{\sphinxupquote{mstatus}})}
\label{\detokenize{control_status_registers:machine-status-mstatus}}
\sphinxAtStartPar
CSR Address: 0x300

\sphinxAtStartPar
Reset Value: 0x0000\_1800

\sphinxAtStartPar
Detailed:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabular}[t]{\X{15}{100}\X{15}{100}\X{70}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Bit \#}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mode}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
31
&
\sphinxAtStartPar
RO
&
\sphinxAtStartPar
\sphinxstylestrong{SD:} State Dirty

\sphinxAtStartPar
SD set to 1 if \sphinxstylestrong{FS} = 11 meaning Floating point State is dirty so save/restore is needed in case of context switch.

\sphinxAtStartPar
0 if \sphinxcode{\sphinxupquote{FPU}} = 0 or (\sphinxcode{\sphinxupquote{FPU}} = 1 and \sphinxcode{\sphinxupquote{ZFINX}} = 1).
\\
\sphinxhline
\sphinxAtStartPar
30:15
&
\sphinxAtStartPar
RO
&
\sphinxAtStartPar
0, Unimplemented.
\\
\sphinxhline
\sphinxAtStartPar
14:13
&
\sphinxAtStartPar
RW
&
\sphinxAtStartPar
\sphinxstylestrong{FS:} Floating point State (See note below)

\sphinxAtStartPar
00 = Off

\sphinxAtStartPar
01 = Initial

\sphinxAtStartPar
10 = Clean

\sphinxAtStartPar
11 = Dirty

\sphinxAtStartPar
0 if \sphinxcode{\sphinxupquote{FPU}} = 0 or (\sphinxcode{\sphinxupquote{FPU}} = 1 and \sphinxcode{\sphinxupquote{ZFINX}} = 1).
\\
\sphinxhline
\sphinxAtStartPar
12:11
&
\sphinxAtStartPar
RW
&
\sphinxAtStartPar
\sphinxstylestrong{MPP:} Machine Previous Priviledge mode

\sphinxAtStartPar
Hardwired to 11 when the User mode is not enabled.
\\
\sphinxhline
\sphinxAtStartPar
10:8
&
\sphinxAtStartPar
RO
&
\sphinxAtStartPar
0, Unimplemented.
\\
\sphinxhline
\sphinxAtStartPar
7
&
\sphinxAtStartPar
RW
&
\sphinxAtStartPar
\sphinxstylestrong{MPIE:} Machine Previous Interrupt Enable

\sphinxAtStartPar
When an exception is encountered, MPIE will be set to MIE.
When the mret instruction is executed, the value of MPIE will be stored to MIE.
\\
\sphinxhline
\sphinxAtStartPar
6:4
&
\sphinxAtStartPar
RO
&
\sphinxAtStartPar
0, Unimplemented.
\\
\sphinxhline
\sphinxAtStartPar
3
&
\sphinxAtStartPar
RW
&
\sphinxAtStartPar
\sphinxstylestrong{MIE:} Machine Interrupt Enable

\sphinxAtStartPar
If you want to enable interrupt handling in your exception handler,
set the Interrupt Enable MIE to 1 inside your handler code.
\\
\sphinxhline
\sphinxAtStartPar
2:0
&
\sphinxAtStartPar
RO
&
\sphinxAtStartPar
0, Unimplemented.
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
As allowed by RISC\sphinxhyphen{}V ISA and to simplify MSTATUS.FS update in the design, the state is updated to Dirty when executing any F instructions except for all FSW ones.
\end{sphinxadmonition}


\subsubsection{Machine Interrupt Enable register (\sphinxstyleliteralintitle{\sphinxupquote{mie}})}
\label{\detokenize{control_status_registers:machine-interrupt-enable-register-mie}}
\sphinxAtStartPar
CSR Address: 0x304

\sphinxAtStartPar
Reset Value: 0x0000\_0000

\sphinxAtStartPar
Detailed:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabular}[t]{\X{15}{100}\X{15}{100}\X{70}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Bit \#}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mode}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
31:16
&
\sphinxAtStartPar
RW
&
\sphinxAtStartPar
Machine Fast Interrupt Enables

\sphinxAtStartPar
Set bit x to enable interrupt irq\_i{[}x{]} (x between 16 and 31).
\\
\sphinxhline
\sphinxAtStartPar
15:12
&
\sphinxAtStartPar
RO
&
\sphinxAtStartPar
0
\\
\sphinxhline
\sphinxAtStartPar
11
&
\sphinxAtStartPar
RW
&
\sphinxAtStartPar
\sphinxstylestrong{MEIE:} Machine External Interrupt Enable

\sphinxAtStartPar
If set, irq\_i{[}11{]} is enabled.
\\
\sphinxhline
\sphinxAtStartPar
10:8
&
\sphinxAtStartPar
RO
&
\sphinxAtStartPar
0
\\
\sphinxhline
\sphinxAtStartPar
7
&
\sphinxAtStartPar
RW
&
\sphinxAtStartPar
\sphinxstylestrong{MTIE:} Machine Timer Interrupt Enable

\sphinxAtStartPar
If set, irq\_i{[}7{]} is enabled.
\\
\sphinxhline
\sphinxAtStartPar
6:4
&
\sphinxAtStartPar
RO
&
\sphinxAtStartPar
0
\\
\sphinxhline
\sphinxAtStartPar
3
&
\sphinxAtStartPar
RW
&
\sphinxAtStartPar
\sphinxstylestrong{MSIE:} Machine Software Interrupt Enable

\sphinxAtStartPar
If set, irq\_i{[}3{]} is enabled.
\\
\sphinxhline
\sphinxAtStartPar
2:0
&
\sphinxAtStartPar
RO
&
\sphinxAtStartPar
0
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\subsubsection{Machine Trap\sphinxhyphen{}Vector Base Address (\sphinxstyleliteralintitle{\sphinxupquote{mtvec}})}
\label{\detokenize{control_status_registers:machine-trap-vector-base-address-mtvec}}\label{\detokenize{control_status_registers:csr-mtvec}}
\sphinxAtStartPar
CSR Address: 0x305

\sphinxAtStartPar
Reset Value: Defined

\sphinxAtStartPar
Detailed:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabular}[t]{\X{15}{100}\X{15}{100}\X{70}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Bit \#}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mode}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
31 : 8
&
\sphinxAtStartPar
RW
&
\sphinxAtStartPar
BASE{[}31:8{]}

\sphinxAtStartPar
The trap\sphinxhyphen{}handler base address, always aligned to 256 bytes.
\\
\sphinxhline
\sphinxAtStartPar
7 : 2
&
\sphinxAtStartPar
RO
&
\sphinxAtStartPar
BASE{[}7:2{]}

\sphinxAtStartPar
The trap\sphinxhyphen{}handler base address, always aligned to 256 bytes, i.e., mtvec{[}7:2{]} is always set to 0.
\\
\sphinxhline
\sphinxAtStartPar
1
&
\sphinxAtStartPar
RO
&
\sphinxAtStartPar
MODE{[}1{]}

\sphinxAtStartPar
0
\\
\sphinxhline
\sphinxAtStartPar
0
&
\sphinxAtStartPar
RW
&
\sphinxAtStartPar
MODE{[}0{]}

\sphinxAtStartPar
0 = Direct mode

\sphinxAtStartPar
1 = Vectored mode.
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
The initial value of \sphinxcode{\sphinxupquote{mtvec}} is equal to \{\sphinxstylestrong{mtvec\_addr\_i{[}31:8{]}}, 6’b0, 2’b01\}.

\sphinxAtStartPar
When an exception or an interrupt is encountered, the core jumps to the corresponding
handler using the content of the MTVEC{[}31:8{]} as base address. Only
8\sphinxhyphen{}byte aligned addresses are allowed. Both direct mode and vectored mode
are supported.


\subsubsection{Machine Scratch (\sphinxstyleliteralintitle{\sphinxupquote{mscratch}})}
\label{\detokenize{control_status_registers:machine-scratch-mscratch}}
\sphinxAtStartPar
CSR Address: 0x340

\sphinxAtStartPar
Reset Value: 0x0000\_0000

\sphinxAtStartPar
Detailed:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabular}[t]{\X{15}{100}\X{15}{100}\X{70}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Bit \#}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mode}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
31:0
&
\sphinxAtStartPar
RW
&
\sphinxAtStartPar
Scratch value
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\subsubsection{Machine Exception PC (\sphinxstyleliteralintitle{\sphinxupquote{mepc}})}
\label{\detokenize{control_status_registers:machine-exception-pc-mepc}}
\sphinxAtStartPar
CSR Address: 0x341

\sphinxAtStartPar
Reset Value: 0x0000\_0000

\sphinxAtStartPar
Detailed:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabular}[t]{\X{15}{100}\X{15}{100}\X{70}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Bit \#}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mode}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
31:1
&
\sphinxAtStartPar
RW
&
\sphinxAtStartPar
\sphinxstylestrong{MEPC:} Machine Exception Program Counter
\\
\sphinxhline
\sphinxAtStartPar
0
&
\sphinxAtStartPar
R0
&
\sphinxAtStartPar
0
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
When an exception is encountered, the current program counter is saved
in MEPC, and the core jumps to the exception address. When a mret
instruction is executed, the value from MEPC replaces the current
program counter.


\subsubsection{Machine Cause (\sphinxstyleliteralintitle{\sphinxupquote{mcause}})}
\label{\detokenize{control_status_registers:machine-cause-mcause}}
\sphinxAtStartPar
CSR Address: 0x342

\sphinxAtStartPar
Reset Value: 0x0000\_0000

\sphinxAtStartPar
Detailed:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabular}[t]{\X{15}{100}\X{15}{100}\X{70}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Bit \#}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mode}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
31
&
\sphinxAtStartPar
RW
&
\sphinxAtStartPar
\sphinxstylestrong{Interrupt:} This bit is set when the exception was triggered by an interrupt.
\\
\sphinxhline
\sphinxAtStartPar
30:5
&
\sphinxAtStartPar
RO (0)
&
\sphinxAtStartPar
0
\\
\sphinxhline
\sphinxAtStartPar
4:0
&
\sphinxAtStartPar
RW
&
\sphinxAtStartPar
\sphinxstylestrong{Exception Code}   (See note below)
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Software accesses to \sphinxtitleref{mcause{[}4:0{]}} must be sensitive to the WLRL field specification of this CSR. For example,
when \sphinxtitleref{mcause{[}31{]}} is set, writing 0x1 to \sphinxtitleref{mcause{[}1{]}} (Supervisor software interrupt) will result in UNDEFINED behavior.
\end{sphinxadmonition}


\subsubsection{Machine Trap Value (\sphinxstyleliteralintitle{\sphinxupquote{mtval}})}
\label{\detokenize{control_status_registers:machine-trap-value-mtval}}
\sphinxAtStartPar
CSR Address: 0x343

\sphinxAtStartPar
Reset Value: 0x0000\_0000

\sphinxAtStartPar
Detailed:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabular}[t]{\X{15}{100}\X{15}{100}\X{70}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Bit \#}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mode}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
31:0
&
\sphinxAtStartPar
RO
&
\sphinxAtStartPar
Writes are ignored; reads return 0.
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\subsubsection{Machine Interrupt Pending register (\sphinxstyleliteralintitle{\sphinxupquote{mip}})}
\label{\detokenize{control_status_registers:machine-interrupt-pending-register-mip}}
\sphinxAtStartPar
CSR Address: 0x344

\sphinxAtStartPar
Reset Value: 0x0000\_0000

\sphinxAtStartPar
Detailed:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabular}[t]{\X{15}{100}\X{15}{100}\X{70}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Bit \#}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mode}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
31:16
&
\sphinxAtStartPar
RO
&
\sphinxAtStartPar
Machine Fast Interrupts Pending

\sphinxAtStartPar
If bit x is set, interrupt irq\_i{[}x{]} is pending (x between 16 and 31).
\\
\sphinxhline
\sphinxAtStartPar
15:12
&
\sphinxAtStartPar
RO
&
\sphinxAtStartPar
0
\\
\sphinxhline
\sphinxAtStartPar
11
&
\sphinxAtStartPar
RO
&
\sphinxAtStartPar
\sphinxstylestrong{MEIP:} Machine External Interrupt Pending

\sphinxAtStartPar
If set, irq\_i{[}11{]} is pending.
\\
\sphinxhline
\sphinxAtStartPar
10:8
&
\sphinxAtStartPar
RO
&
\sphinxAtStartPar
0
\\
\sphinxhline
\sphinxAtStartPar
7
&
\sphinxAtStartPar
RO
&
\sphinxAtStartPar
\sphinxstylestrong{MTIP:} Machine Timer Interrupt Pending

\sphinxAtStartPar
If set, irq\_i{[}7{]} is pending.
\\
\sphinxhline
\sphinxAtStartPar
6:4
&
\sphinxAtStartPar
RO
&
\sphinxAtStartPar
0
\\
\sphinxhline
\sphinxAtStartPar
3
&
\sphinxAtStartPar
RO
&
\sphinxAtStartPar
\sphinxstylestrong{MSIP:} Machine Software Interrupt Pending

\sphinxAtStartPar
If set, irq\_i{[}3{]} is pending.
\\
\sphinxhline
\sphinxAtStartPar
2:0
&
\sphinxAtStartPar
RO
&
\sphinxAtStartPar
0
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\subsection{Trigger CSRs}
\label{\detokenize{control_status_registers:trigger-csrs}}

\subsubsection{Trigger Select register (\sphinxstyleliteralintitle{\sphinxupquote{tselect}})}
\label{\detokenize{control_status_registers:trigger-select-register-tselect}}\label{\detokenize{control_status_registers:csr-tselect}}
\sphinxAtStartPar
CSR Address: 0x7A0

\sphinxAtStartPar
Reset Value: 0x0000\_0000

\sphinxAtStartPar
Detailed:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabular}[t]{\X{15}{100}\X{15}{100}\X{70}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Bit \#}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mode}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
31:0
&
\sphinxAtStartPar
RO
&
\sphinxAtStartPar
CV32E40P implements a single trigger, therefore this register will always read as zero.
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Accessible in Debug Mode or M\sphinxhyphen{}Mode.


\subsubsection{Trigger Data register 1 (\sphinxstyleliteralintitle{\sphinxupquote{tdata1}})}
\label{\detokenize{control_status_registers:trigger-data-register-1-tdata1}}\label{\detokenize{control_status_registers:csr-tdata1}}
\sphinxAtStartPar
CSR Address: 0x7A1

\sphinxAtStartPar
Reset Value: 0x2800\_1040

\sphinxAtStartPar
Detailed:

\sphinxAtStartPar
Accessible in Debug Mode or M\sphinxhyphen{}Mode.
Since native triggers are not supported, writes to this register from M\sphinxhyphen{}Mode will be ignored.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
CV32E40P only implements one type of trigger, Match Control. Most fields of this register will read as a fixed value to
reflect the single mode that is supported, in particular, instruction address match as described in the Debug Specification
0.13.2 section 5.2.2 \& 5.2.9. The \sphinxstylestrong{type}, \sphinxstylestrong{dmode}, \sphinxstylestrong{hit}, \sphinxstylestrong{select}, \sphinxstylestrong{timing}, \sphinxstylestrong{sizelo}, \sphinxstylestrong{action}, \sphinxstylestrong{chain},
\sphinxstylestrong{match}, \sphinxstylestrong{m}, \sphinxstylestrong{s}, \sphinxstylestrong{u},  \sphinxstylestrong{store} and  \sphinxstylestrong{load} bitfields of this CSR, which are marked as R/W in Debug Specification
0.13.2, are therefore implemented as WARL bitfields (corresponding to how these bitfields will be specified in the forthcoming
Debug Specification 0.14.0).
\end{sphinxadmonition}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabular}[t]{\X{15}{100}\X{15}{100}\X{70}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Bit \#}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mode}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
31:28
&
\sphinxAtStartPar
RO (0x2)
&
\sphinxAtStartPar
\sphinxstylestrong{type:} 2 = Address/Data match trigger type.
\\
\sphinxhline
\sphinxAtStartPar
27
&
\sphinxAtStartPar
RO (0x1)
&
\sphinxAtStartPar
\sphinxstylestrong{dmode:} 1 = Only debug mode can write tdata registers
\\
\sphinxhline
\sphinxAtStartPar
26:21
&
\sphinxAtStartPar
RO (0x0)
&
\sphinxAtStartPar
\sphinxstylestrong{maskmax:} 0 = Only exact matching supported.
\\
\sphinxhline
\sphinxAtStartPar
20
&
\sphinxAtStartPar
RO (0x0)
&
\sphinxAtStartPar
\sphinxstylestrong{hit:} 0 = Hit indication not supported.
\\
\sphinxhline
\sphinxAtStartPar
19
&
\sphinxAtStartPar
RO (0x0)
&
\sphinxAtStartPar
\sphinxstylestrong{select:} 0 = Only address matching is supported.
\\
\sphinxhline
\sphinxAtStartPar
18
&
\sphinxAtStartPar
RO (0x0)
&
\sphinxAtStartPar
\sphinxstylestrong{timing:} 0 = Break before the instruction at the specified
address.
\\
\sphinxhline
\sphinxAtStartPar
17:16
&
\sphinxAtStartPar
RO (0x0)
&
\sphinxAtStartPar
\sphinxstylestrong{sizelo:} 0 = Match accesses of any size.
\\
\sphinxhline
\sphinxAtStartPar
15:12
&
\sphinxAtStartPar
RO (0x1)
&
\sphinxAtStartPar
\sphinxstylestrong{action:} 1 = Enter debug mode on match.
\\
\sphinxhline
\sphinxAtStartPar
11
&
\sphinxAtStartPar
RO (0x0)
&
\sphinxAtStartPar
\sphinxstylestrong{chain:} 0 = Chaining not supported.
\\
\sphinxhline
\sphinxAtStartPar
10:7
&
\sphinxAtStartPar
RO (0x0)
&
\sphinxAtStartPar
\sphinxstylestrong{match:} 0 = Match the whole address.
\\
\sphinxhline
\sphinxAtStartPar
6
&
\sphinxAtStartPar
RO (0x1)
&
\sphinxAtStartPar
\sphinxstylestrong{m:} 1 = Match in M\sphinxhyphen{}Mode.
\\
\sphinxhline
\sphinxAtStartPar
5
&
\sphinxAtStartPar
RO (0x0)
&
\sphinxAtStartPar
zero.
\\
\sphinxhline
\sphinxAtStartPar
4
&
\sphinxAtStartPar
RO (0x0)
&
\sphinxAtStartPar
\sphinxstylestrong{s:} 0 = S\sphinxhyphen{}Mode not supported.
\\
\sphinxhline
\sphinxAtStartPar
3
&
\sphinxAtStartPar
RO (0x0)
&
\sphinxAtStartPar
\sphinxstylestrong{u:} 0 = U\sphinxhyphen{}Mode not supported.
\\
\sphinxhline
\sphinxAtStartPar
2
&
\sphinxAtStartPar
RW
&
\sphinxAtStartPar
\sphinxstylestrong{execute:} Enable matching on instruction address.
\\
\sphinxhline
\sphinxAtStartPar
1
&
\sphinxAtStartPar
RO (0x0)
&
\sphinxAtStartPar
\sphinxstylestrong{store:} 0 = Store address / data matching not supported.
\\
\sphinxhline
\sphinxAtStartPar
0
&
\sphinxAtStartPar
RO (0x0)
&
\sphinxAtStartPar
\sphinxstylestrong{load:} 0 = Load address / data matching not supported.
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\subsubsection{Trigger Data register 2 (\sphinxstyleliteralintitle{\sphinxupquote{tdata2}})}
\label{\detokenize{control_status_registers:trigger-data-register-2-tdata2}}\label{\detokenize{control_status_registers:csr-tdata2}}
\sphinxAtStartPar
CSR Address: 0x7A2

\sphinxAtStartPar
Reset Value: 0x0000\_0000

\sphinxAtStartPar
Detailed:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabular}[t]{\X{15}{100}\X{15}{100}\X{70}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Bit \#}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mode}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
31:0
&
\sphinxAtStartPar
RW
&
\sphinxAtStartPar
\sphinxstylestrong{data}
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Accessible in Debug Mode or M\sphinxhyphen{}Mode. Since native triggers are not supported, writes to this register from M\sphinxhyphen{}Mode will be ignored.
This register stores the instruction address to match against for a breakpoint trigger.


\subsubsection{Trigger Data register 3 (\sphinxstyleliteralintitle{\sphinxupquote{tdata3}})}
\label{\detokenize{control_status_registers:trigger-data-register-3-tdata3}}
\sphinxAtStartPar
CSR Address: 0x7A3

\sphinxAtStartPar
Reset Value: 0x0000\_0000

\sphinxAtStartPar
Detailed:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabular}[t]{\X{15}{100}\X{15}{100}\X{70}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Bit \#}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mode}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
31:0
&
\sphinxAtStartPar
RO
&
\sphinxAtStartPar
0
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Accessible in Debug Mode or M\sphinxhyphen{}Mode.
CV32E40P does not support the features requiring this register. Writes are ignored and reads will always return zero.


\subsubsection{Trigger Info (\sphinxstyleliteralintitle{\sphinxupquote{tinfo}})}
\label{\detokenize{control_status_registers:trigger-info-tinfo}}\label{\detokenize{control_status_registers:csr-tinfo}}
\sphinxAtStartPar
CSR Address: 0x7A4

\sphinxAtStartPar
Reset Value: 0x0000\_0004

\sphinxAtStartPar
Detailed:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabular}[t]{\X{15}{100}\X{15}{100}\X{70}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Bit \#}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mode}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
31:16
&
\sphinxAtStartPar
RO
&
\sphinxAtStartPar
0
\\
\sphinxhline
\sphinxAtStartPar
15:0
&
\sphinxAtStartPar
RO (0x4)
&
\sphinxAtStartPar
\sphinxstylestrong{info}. Only type 2 is supported.
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
The \sphinxstylestrong{info} field contains one bit for each possible \sphinxtitleref{type} enumerated in
\sphinxtitleref{tdata1}.  Bit N corresponds to type N.  If the bit is set, then that type is
supported by the currently selected trigger.  If the currently selected trigger
does not exist, this field contains 1.

\sphinxAtStartPar
Accessible in Debug Mode or M\sphinxhyphen{}Mode.


\subsubsection{Machine Context register (\sphinxstyleliteralintitle{\sphinxupquote{mcontext}})}
\label{\detokenize{control_status_registers:machine-context-register-mcontext}}
\sphinxAtStartPar
CSR Address: 0x7A8

\sphinxAtStartPar
Reset Value: 0x0000\_0000

\sphinxAtStartPar
Detailed:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabular}[t]{\X{15}{100}\X{15}{100}\X{70}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Bit \#}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mode}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
31:0
&
\sphinxAtStartPar
RO
&
\sphinxAtStartPar
0
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Accessible in Debug Mode or M\sphinxhyphen{}Mode.
CV32E40P does not support the features requiring this register. Writes are ignored and
reads will always return zero.


\subsection{Debug CSRs}
\label{\detokenize{control_status_registers:debug-csrs}}

\subsubsection{Debug Control and Status (\sphinxstyleliteralintitle{\sphinxupquote{dcsr}})}
\label{\detokenize{control_status_registers:debug-control-and-status-dcsr}}\label{\detokenize{control_status_registers:csr-dcsr}}
\sphinxAtStartPar
CSR Address: 0x7B0

\sphinxAtStartPar
Reset Value: 0x4000\_0003

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The \sphinxstylestrong{ebreaks}, \sphinxstylestrong{ebreaku} and \sphinxstylestrong{prv} bitfields of this CSR are marked as R/W in Debug Specification 0.13.2. However,
as CV32E40P only supports machine mode, these bitfields are implemented as WARL bitfields (corresponding to how these bitfields will
be specified in the forthcoming Debug Specification 0.14.0).
\end{sphinxadmonition}

\sphinxAtStartPar
Detailed:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabular}[t]{\X{15}{100}\X{15}{100}\X{70}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Bit \#}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mode}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
31:28
&
\sphinxAtStartPar
RO (0x4)
&
\sphinxAtStartPar
\sphinxstylestrong{xdebugver:} returns 4 \sphinxhyphen{} External debug support exists as it is described in this document.
\\
\sphinxhline
\sphinxAtStartPar
27:16
&
\sphinxAtStartPar
RO (0x0)
&
\sphinxAtStartPar
Reserved
\\
\sphinxhline
\sphinxAtStartPar
15
&
\sphinxAtStartPar
RW
&
\sphinxAtStartPar
\sphinxstylestrong{ebreakm}
\\
\sphinxhline
\sphinxAtStartPar
14
&
\sphinxAtStartPar
RO (0x0)
&
\sphinxAtStartPar
Reserved
\\
\sphinxhline
\sphinxAtStartPar
13
&
\sphinxAtStartPar
RO (0x0)
&
\sphinxAtStartPar
\sphinxstylestrong{ebreaks}. Always 0.
\\
\sphinxhline
\sphinxAtStartPar
12
&
\sphinxAtStartPar
RO (0x0)
&
\sphinxAtStartPar
\sphinxstylestrong{ebreaku}. Always 0.
\\
\sphinxhline
\sphinxAtStartPar
11
&
\sphinxAtStartPar
RW
&
\sphinxAtStartPar
\sphinxstylestrong{stepie}
\\
\sphinxhline
\sphinxAtStartPar
10
&
\sphinxAtStartPar
RO (0x0)
&
\sphinxAtStartPar
\sphinxstylestrong{stopcount}. Always 0.
\\
\sphinxhline
\sphinxAtStartPar
9
&
\sphinxAtStartPar
RO (0x0)
&
\sphinxAtStartPar
\sphinxstylestrong{stoptime}. Always 0.
\\
\sphinxhline
\sphinxAtStartPar
8:6
&
\sphinxAtStartPar
RO
&
\sphinxAtStartPar
\sphinxstylestrong{cause}
\\
\sphinxhline
\sphinxAtStartPar
5
&
\sphinxAtStartPar
RO (0x0)
&
\sphinxAtStartPar
Reserved
\\
\sphinxhline
\sphinxAtStartPar
4
&
\sphinxAtStartPar
RO (0x0)
&
\sphinxAtStartPar
\sphinxstylestrong{mprven}. Always 0.
\\
\sphinxhline
\sphinxAtStartPar
3
&
\sphinxAtStartPar
RO (0x0)
&
\sphinxAtStartPar
\sphinxstylestrong{nmip}. Always 0.
\\
\sphinxhline
\sphinxAtStartPar
2
&
\sphinxAtStartPar
RW
&
\sphinxAtStartPar
\sphinxstylestrong{step}
\\
\sphinxhline
\sphinxAtStartPar
1:0
&
\sphinxAtStartPar
RO (0x3)
&
\sphinxAtStartPar
\sphinxstylestrong{prv:} returns the current priviledge mode
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\subsubsection{Debug PC (\sphinxstyleliteralintitle{\sphinxupquote{dpc}})}
\label{\detokenize{control_status_registers:debug-pc-dpc}}\label{\detokenize{control_status_registers:csr-dpc}}
\sphinxAtStartPar
CSR Address: 0x7B1

\sphinxAtStartPar
Reset Value: 0x0000\_0000

\sphinxAtStartPar
Detailed:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabular}[t]{\X{15}{100}\X{15}{100}\X{70}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Bit \#}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mode}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
31:1
&
\sphinxAtStartPar
RO
&
\sphinxAtStartPar
zero
\\
\sphinxhline
\sphinxAtStartPar
0
&
\sphinxAtStartPar
RO
&
\sphinxAtStartPar
DPC
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
When the core enters in Debug Mode, DPC contains the virtual address of
the next instruction to be executed.


\subsubsection{Debug Scratch register 0/1 (\sphinxstyleliteralintitle{\sphinxupquote{dscratch0/1}})}
\label{\detokenize{control_status_registers:debug-scratch-register-0-1-dscratch0-1}}
\sphinxAtStartPar
CSR Address: 0x7B2/0x7B3

\sphinxAtStartPar
Reset Value: 0x0000\_0000

\sphinxAtStartPar
Detailed:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabular}[t]{\X{15}{100}\X{15}{100}\X{70}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Bit \#}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mode}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
31:0
&
\sphinxAtStartPar
RW
&
\sphinxAtStartPar
DSCRATCH0/1
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\subsection{Performances counters}
\label{\detokenize{control_status_registers:performances-counters}}

\subsubsection{Machine Counter\sphinxhyphen{}Inhibit register (\sphinxstyleliteralintitle{\sphinxupquote{mcountinhibit}})}
\label{\detokenize{control_status_registers:machine-counter-inhibit-register-mcountinhibit}}
\sphinxAtStartPar
CSR Address: 0x320

\sphinxAtStartPar
Reset Value: 0x0000\_000D

\sphinxAtStartPar
Detailed:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabular}[t]{\X{15}{100}\X{15}{100}\X{70}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Bit \#}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mode}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
31:4
&
\sphinxAtStartPar
RW
&
\sphinxAtStartPar
Dependent on number of counters implemented in design parameter
\\
\sphinxhline
\sphinxAtStartPar
3
&
\sphinxAtStartPar
RW
&
\sphinxAtStartPar
\sphinxstylestrong{selectors:} mhpmcounter3 inhibit
\\
\sphinxhline
\sphinxAtStartPar
2
&
\sphinxAtStartPar
RW
&
\sphinxAtStartPar
minstret inhibit
\\
\sphinxhline
\sphinxAtStartPar
1
&
\sphinxAtStartPar
RO
&
\sphinxAtStartPar
0
\\
\sphinxhline
\sphinxAtStartPar
0
&
\sphinxAtStartPar
RW
&
\sphinxAtStartPar
mcycle inhibit
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
The performance counter inhibit control register. The default value is to inihibit counters out of reset.
The bit returns a read value of 0 for non implemented counters. This reset value
shows the result using the default number of performance counters to be 1.


\subsubsection{Machine Performance Monitoring Event Selector (\sphinxstyleliteralintitle{\sphinxupquote{mhpmevent3 .. mhpmevent31}})}
\label{\detokenize{control_status_registers:machine-performance-monitoring-event-selector-mhpmevent3-mhpmevent31}}
\sphinxAtStartPar
CSR Address: 0x323 \sphinxhyphen{} 0x33F

\sphinxAtStartPar
Reset Value: 0x0000\_0000

\sphinxAtStartPar
Detailed:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabular}[t]{\X{15}{100}\X{15}{100}\X{70}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Bit \#}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mode}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
31:16
&
\sphinxAtStartPar
RO
&
\sphinxAtStartPar
0
\\
\sphinxhline
\sphinxAtStartPar
15:0
&
\sphinxAtStartPar
RW
&
\sphinxAtStartPar
\sphinxstylestrong{selectors:} Each bit represent a unique event to count
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
The event selector fields are further described in Performance Counters section.
Non implemented counters always return a read value of 0.


\subsubsection{Machine Cycle Counter (\sphinxstyleliteralintitle{\sphinxupquote{mcycle}})}
\label{\detokenize{control_status_registers:machine-cycle-counter-mcycle}}
\sphinxAtStartPar
CSR Address: 0xB00

\sphinxAtStartPar
Reset Value: 0x0000\_0000

\sphinxAtStartPar
Detailed:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabular}[t]{\X{15}{100}\X{15}{100}\X{70}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Bit \#}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mode}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
31:0
&
\sphinxAtStartPar
RW
&
\sphinxAtStartPar
The lower 32 bits of the 64 bit machine mode cycle counter.
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\subsubsection{Machine Instructions\sphinxhyphen{}Retired Counter (\sphinxstyleliteralintitle{\sphinxupquote{minstret}})}
\label{\detokenize{control_status_registers:machine-instructions-retired-counter-minstret}}
\sphinxAtStartPar
CSR Address: 0xB02

\sphinxAtStartPar
Reset Value: 0x0000\_0000

\sphinxAtStartPar
Detailed:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabular}[t]{\X{15}{100}\X{15}{100}\X{70}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Bit \#}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mode}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
31:0
&
\sphinxAtStartPar
RW
&
\sphinxAtStartPar
The lower 32 bits of the 64 bit machine mode instruction retired counter.
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\subsubsection{Machine Performance Monitoring Counter (\sphinxstyleliteralintitle{\sphinxupquote{mhpmcounter3 .. mhpmcounter31}})}
\label{\detokenize{control_status_registers:machine-performance-monitoring-counter-mhpmcounter3-mhpmcounter31}}
\sphinxAtStartPar
CSR Address: 0xB03 \sphinxhyphen{} 0xB1F

\sphinxAtStartPar
Reset Value: 0x0000\_0000

\sphinxAtStartPar
Detailed:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabular}[t]{\X{15}{100}\X{15}{100}\X{70}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Bit \#}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mode}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
31:0
&
\sphinxAtStartPar
RW
&
\sphinxAtStartPar
Machine performance\sphinxhyphen{}monitoring counter
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
The lower 32 bits of the 64 bit machine performance\sphinxhyphen{}monitoring counter(s).
The number of machine performance\sphinxhyphen{}monitoring counters is determined by the parameter \sphinxcode{\sphinxupquote{NUM\_MHPMCOUNTERS}} with a range from 0 to 29 (default value of 1). Non implemented counters always return a read value of 0.


\subsubsection{Upper 32 bits Machine Cycle Counter (\sphinxstyleliteralintitle{\sphinxupquote{mcycleh}})}
\label{\detokenize{control_status_registers:upper-32-bits-machine-cycle-counter-mcycleh}}
\sphinxAtStartPar
CSR Address: 0xB80

\sphinxAtStartPar
Reset Value: 0x0000\_0000

\sphinxAtStartPar
Detailed:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabular}[t]{\X{15}{100}\X{15}{100}\X{70}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Bit \#}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mode}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
31:0
&
\sphinxAtStartPar
RW
&
\sphinxAtStartPar
The upper 32 bits of the 64 bit machine mode cycle counter.
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\subsubsection{Upper 32 bits Machine Instructions\sphinxhyphen{}Retired Counter (\sphinxstyleliteralintitle{\sphinxupquote{minstreth}})}
\label{\detokenize{control_status_registers:upper-32-bits-machine-instructions-retired-counter-minstreth}}
\sphinxAtStartPar
CSR Address: 0xB82

\sphinxAtStartPar
Reset Value: 0x0000\_0000

\sphinxAtStartPar
Detailed:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabular}[t]{\X{15}{100}\X{15}{100}\X{70}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Bit \#}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mode}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
31:0
&
\sphinxAtStartPar
RW
&
\sphinxAtStartPar
The upper 32 bits of the 64 bit machine mode instruction retired counter.
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\subsubsection{Upper 32 bits Machine Performance Monitoring Counter (\sphinxstyleliteralintitle{\sphinxupquote{mhpmcounter3h .. mhpmcounter31h}})}
\label{\detokenize{control_status_registers:upper-32-bits-machine-performance-monitoring-counter-mhpmcounter3h-mhpmcounter31h}}
\sphinxAtStartPar
CSR Address: 0xB83 \sphinxhyphen{} 0xB9F

\sphinxAtStartPar
Reset Value: 0x0000\_0000

\sphinxAtStartPar
Detailed:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabular}[t]{\X{15}{100}\X{15}{100}\X{70}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Bit \#}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mode}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
31:0
&
\sphinxAtStartPar
RW
&
\sphinxAtStartPar
Machine performance\sphinxhyphen{}monitoring counter
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
The upper 32 bits of the 64 bit machine performance\sphinxhyphen{}monitoring counter(s).
The number of machine performance\sphinxhyphen{}monitoring counters is determined by the parameter \sphinxcode{\sphinxupquote{NUM\_MHPMCOUNTERS}} with a range from 0 to 29 (default value of 1). Non implemented counters always return a read value of 0.


\subsubsection{Cycle Counter (\sphinxstyleliteralintitle{\sphinxupquote{cycle}})}
\label{\detokenize{control_status_registers:cycle-counter-cycle}}
\sphinxAtStartPar
CSR Address: 0xC00

\sphinxAtStartPar
Reset Value: 0x0000\_0000

\sphinxAtStartPar
Detailed:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabular}[t]{\X{15}{100}\X{15}{100}\X{70}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Bit \#}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mode}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
31:0
&
\sphinxAtStartPar
RO
&
\sphinxAtStartPar
0
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Read\sphinxhyphen{}only unprivileged shadow of the lower 32 bits of the 64 bit machine mode cycle counter.


\subsubsection{Instructions\sphinxhyphen{}Retired Counter (\sphinxstyleliteralintitle{\sphinxupquote{instret}})}
\label{\detokenize{control_status_registers:instructions-retired-counter-instret}}
\sphinxAtStartPar
CSR Address: 0xC02

\sphinxAtStartPar
Reset Value: 0x0000\_0000

\sphinxAtStartPar
Detailed:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabular}[t]{\X{15}{100}\X{15}{100}\X{70}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Bit \#}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mode}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
31:0
&
\sphinxAtStartPar
RO
&
\sphinxAtStartPar
0
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Read\sphinxhyphen{}only unprivileged shadow of the lower 32 bits of the 64 bit machine mode instruction retired counter.


\subsubsection{Performance Monitoring Counter (\sphinxstyleliteralintitle{\sphinxupquote{hpmcounter3 .. hpmcounter31}})}
\label{\detokenize{control_status_registers:performance-monitoring-counter-hpmcounter3-hpmcounter31}}
\sphinxAtStartPar
CSR Address: 0xC03 \sphinxhyphen{} 0xC1F

\sphinxAtStartPar
Reset Value: 0x0000\_0000

\sphinxAtStartPar
Detailed:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabular}[t]{\X{15}{100}\X{15}{100}\X{70}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Bit \#}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mode}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
31:0
&
\sphinxAtStartPar
RO
&
\sphinxAtStartPar
0
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Read\sphinxhyphen{}only unprivileged shadow of the lower 32 bits of the 64 bit machine mode
performance counter. Non implemented counters always return a read value of 0.


\subsubsection{Upper 32 bits Cycle Counter (\sphinxstyleliteralintitle{\sphinxupquote{cycleh}})}
\label{\detokenize{control_status_registers:upper-32-bits-cycle-counter-cycleh}}
\sphinxAtStartPar
CSR Address: 0xC80

\sphinxAtStartPar
Reset Value: 0x0000\_0000

\sphinxAtStartPar
Detailed:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabular}[t]{\X{15}{100}\X{15}{100}\X{70}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Bit \#}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mode}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
31:0
&
\sphinxAtStartPar
RO
&
\sphinxAtStartPar
0
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Read\sphinxhyphen{}only unprivileged shadow of the upper 32 bits of the 64 bit machine mode cycle counter.


\subsubsection{Upper 32 bits Instructions\sphinxhyphen{}Retired Counter (\sphinxstyleliteralintitle{\sphinxupquote{instreth}})}
\label{\detokenize{control_status_registers:upper-32-bits-instructions-retired-counter-instreth}}
\sphinxAtStartPar
CSR Address: 0xC82

\sphinxAtStartPar
Reset Value: 0x0000\_0000

\sphinxAtStartPar
Detailed:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabular}[t]{\X{15}{100}\X{15}{100}\X{70}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Bit \#}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mode}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
31:0
&
\sphinxAtStartPar
RO
&
\sphinxAtStartPar
0
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Read\sphinxhyphen{}only unprivileged shadow of the upper 32 bits of the 64 bit machine mode instruction retired counter.


\subsubsection{Upper 32 bits Performance Monitoring Counter (\sphinxstyleliteralintitle{\sphinxupquote{hpmcounter3h .. hpmcounter31h}})}
\label{\detokenize{control_status_registers:upper-32-bits-performance-monitoring-counter-hpmcounter3h-hpmcounter31h}}
\sphinxAtStartPar
CSR Address: 0xC83 \sphinxhyphen{} 0xC9F

\sphinxAtStartPar
Reset Value: 0x0000\_0000

\sphinxAtStartPar
Detailed:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabular}[t]{\X{15}{100}\X{15}{100}\X{70}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Bit \#}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mode}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
31:0
&
\sphinxAtStartPar
RO
&
\sphinxAtStartPar
0
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Read\sphinxhyphen{}only unprivileged shadow of the upper 32 bits of the 64 bit machine mode
performance counter. Non implemented counters always return a read value of 0.


\subsection{ID CSRs}
\label{\detokenize{control_status_registers:id-csrs}}

\subsubsection{Machine ISA (\sphinxstyleliteralintitle{\sphinxupquote{misa}})}
\label{\detokenize{control_status_registers:machine-isa-misa}}
\sphinxAtStartPar
CSR Address: 0x301

\sphinxAtStartPar
Reset Value: defined

\sphinxAtStartPar
Detailed:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabular}[t]{\X{15}{100}\X{15}{100}\X{70}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Bit \#}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mode}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
31:30
&
\sphinxAtStartPar
RO   (0x1)
&
\sphinxAtStartPar
\sphinxstylestrong{MXL} (Machine XLEN)
\\
\sphinxhline
\sphinxAtStartPar
29:26
&
\sphinxAtStartPar
RO   (0x0)
&
\sphinxAtStartPar
(Reserved)
\\
\sphinxhline
\sphinxAtStartPar
25
&
\sphinxAtStartPar
RO   (0x0)
&
\sphinxAtStartPar
\sphinxstylestrong{Z} (Reserved)
\\
\sphinxhline
\sphinxAtStartPar
24
&
\sphinxAtStartPar
RO   (0x0)
&
\sphinxAtStartPar
\sphinxstylestrong{Y} (Reserved)
\\
\sphinxhline
\sphinxAtStartPar
23
&
\sphinxAtStartPar
RO
&
\sphinxAtStartPar
\sphinxstylestrong{X} (Non\sphinxhyphen{}standard extensions present)
\\
\sphinxhline
\sphinxAtStartPar
22
&
\sphinxAtStartPar
RO   (0x0)
&
\sphinxAtStartPar
\sphinxstylestrong{W} (Reserved)
\\
\sphinxhline
\sphinxAtStartPar
21
&
\sphinxAtStartPar
RO   (0x0)
&
\sphinxAtStartPar
\sphinxstylestrong{V} (Tentatively reserved for Vector extension)
\\
\sphinxhline
\sphinxAtStartPar
20
&
\sphinxAtStartPar
RO   (0x0)
&
\sphinxAtStartPar
\sphinxstylestrong{U} (User mode implemented)
\\
\sphinxhline
\sphinxAtStartPar
19
&
\sphinxAtStartPar
RO   (0x0)
&
\sphinxAtStartPar
\sphinxstylestrong{T} (Tentatively reserved for Transactional Memory extension)
\\
\sphinxhline
\sphinxAtStartPar
18
&
\sphinxAtStartPar
RO   (0x0)
&
\sphinxAtStartPar
\sphinxstylestrong{S} (Supervisor mode implemented)
\\
\sphinxhline
\sphinxAtStartPar
17
&
\sphinxAtStartPar
RO   (0x0)
&
\sphinxAtStartPar
\sphinxstylestrong{R} (Reserved)
\\
\sphinxhline
\sphinxAtStartPar
16
&
\sphinxAtStartPar
RO   (0x0)
&
\sphinxAtStartPar
\sphinxstylestrong{Q} (Quad\sphinxhyphen{}precision floating\sphinxhyphen{}point extension)
\\
\sphinxhline
\sphinxAtStartPar
15
&
\sphinxAtStartPar
RO   (0x0)
&
\sphinxAtStartPar
\sphinxstylestrong{P} (Tentatively reserved for Packed\sphinxhyphen{}SIMD extension)
\\
\sphinxhline
\sphinxAtStartPar
14
&
\sphinxAtStartPar
RO   (0x0)
&
\sphinxAtStartPar
\sphinxstylestrong{O} (Reserved)
\\
\sphinxhline
\sphinxAtStartPar
13
&
\sphinxAtStartPar
RO   (0x0)
&
\sphinxAtStartPar
\sphinxstylestrong{N} (User\sphinxhyphen{}level interrupts supported)
\\
\sphinxhline
\sphinxAtStartPar
12
&
\sphinxAtStartPar
RO   (0x1)
&
\sphinxAtStartPar
\sphinxstylestrong{M} (Integer Multiply/Divide extension)
\\
\sphinxhline
\sphinxAtStartPar
11
&
\sphinxAtStartPar
RO   (0x0)
&
\sphinxAtStartPar
\sphinxstylestrong{L} (Tentatively reserved for Decimal Floating\sphinxhyphen{}Point extension)
\\
\sphinxhline
\sphinxAtStartPar
10
&
\sphinxAtStartPar
RO   (0x0)
&
\sphinxAtStartPar
\sphinxstylestrong{K} (Reserved)
\\
\sphinxhline
\sphinxAtStartPar
9
&
\sphinxAtStartPar
RO   (0x0)
&
\sphinxAtStartPar
\sphinxstylestrong{J} (Tentatively reserved for Dynamically Translated Languages
extension)
\\
\sphinxhline
\sphinxAtStartPar
8
&
\sphinxAtStartPar
RO   (0x1)
&
\sphinxAtStartPar
\sphinxstylestrong{I} (RV32I/64I/128I base ISA)
\\
\sphinxhline
\sphinxAtStartPar
7
&
\sphinxAtStartPar
RO   (0x0)
&
\sphinxAtStartPar
\sphinxstylestrong{H} (Hypervisor extension)
\\
\sphinxhline
\sphinxAtStartPar
6
&
\sphinxAtStartPar
RO   (0x0)
&
\sphinxAtStartPar
\sphinxstylestrong{G} (Additional standard extensions present)
\\
\sphinxhline
\sphinxAtStartPar
5
&
\sphinxAtStartPar
RO
&
\sphinxAtStartPar
\sphinxstylestrong{F} (Single\sphinxhyphen{}precision floating\sphinxhyphen{}point extension)
\\
\sphinxhline
\sphinxAtStartPar
4
&
\sphinxAtStartPar
RO   (0x0)
&
\sphinxAtStartPar
\sphinxstylestrong{E} (RV32E base ISA)
\\
\sphinxhline
\sphinxAtStartPar
3
&
\sphinxAtStartPar
RO   (0x0)
&
\sphinxAtStartPar
\sphinxstylestrong{D} (Double\sphinxhyphen{}precision floating\sphinxhyphen{}point extension)
\\
\sphinxhline
\sphinxAtStartPar
2
&
\sphinxAtStartPar
RO   (0x1)
&
\sphinxAtStartPar
\sphinxstylestrong{C} (Compressed extension)
\\
\sphinxhline
\sphinxAtStartPar
1
&
\sphinxAtStartPar
RO   (0x0)
&
\sphinxAtStartPar
\sphinxstylestrong{B} (Tentatively reserved for Bit\sphinxhyphen{}Manipulation extension)
\\
\sphinxhline
\sphinxAtStartPar
0
&
\sphinxAtStartPar
RO   (0x0)
&
\sphinxAtStartPar
\sphinxstylestrong{A} (Atomic extension)
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Writes are ignored and all bitfields in the \sphinxcode{\sphinxupquote{misa}} CSR area read as 0 except for the following:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{C} = 1

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{F} = 1 if \sphinxcode{\sphinxupquote{FPU}} = 1 and \sphinxcode{\sphinxupquote{ZFINX}} = 0

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{I} = 1

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{M} = 1

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{X} = 1 if \sphinxcode{\sphinxupquote{COREV\_PULP}} = 1 or \sphinxcode{\sphinxupquote{COREV\_CLUSTER}} = 1

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{MXL} = 1 (i.e. XLEN = 32)

\end{itemize}


\subsubsection{Machine Vendor ID (\sphinxstyleliteralintitle{\sphinxupquote{mvendorid}})}
\label{\detokenize{control_status_registers:machine-vendor-id-mvendorid}}
\sphinxAtStartPar
CSR Address: 0xF11

\sphinxAtStartPar
Reset Value: 0x0000\_0602

\sphinxAtStartPar
Detailed:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabular}[t]{\X{15}{100}\X{15}{100}\X{70}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Bit \#}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mode}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
31:7
&
\sphinxAtStartPar
RO
&
\sphinxAtStartPar
0xC. Number of continuation codes in JEDEC manufacturer ID.
\\
\sphinxhline
\sphinxAtStartPar
6:0
&
\sphinxAtStartPar
RO
&
\sphinxAtStartPar
0x2. Final byte of JEDEC manufacturer ID, discarding the parity bit.
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{mvendorid}} encodes the OpenHW JEDEC Manufacturer ID, which is 2 decimal (bank 13).


\subsubsection{Machine Architecture ID (\sphinxstyleliteralintitle{\sphinxupquote{marchid}})}
\label{\detokenize{control_status_registers:machine-architecture-id-marchid}}
\sphinxAtStartPar
CSR Address: 0xF12

\sphinxAtStartPar
Reset Value: 0x0000\_0004

\sphinxAtStartPar
Detailed:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabular}[t]{\X{15}{100}\X{15}{100}\X{70}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Bit \#}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mode}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
31:0
&
\sphinxAtStartPar
RO
&
\sphinxAtStartPar
Machine Architecture ID of CV32E40P is 4
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\subsubsection{Machine Implementation ID (\sphinxstyleliteralintitle{\sphinxupquote{mimpid}})}
\label{\detokenize{control_status_registers:machine-implementation-id-mimpid}}
\sphinxAtStartPar
CSR Address: 0xF13

\sphinxAtStartPar
Reset Value: Defined

\sphinxAtStartPar
Detailed:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabular}[t]{\X{15}{100}\X{15}{100}\X{70}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Bit \#}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mode}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
31 : 1
&
\sphinxAtStartPar
RO
&
\sphinxAtStartPar
0
\\
\sphinxhline
\sphinxAtStartPar
0
&
\sphinxAtStartPar
RO
&
\sphinxAtStartPar
1 if \sphinxcode{\sphinxupquote{FPU}} = 1 or \sphinxcode{\sphinxupquote{COREV\_PULP}} = 1 or \sphinxcode{\sphinxupquote{COREV\_CLUSTER}} = 1 else 0.
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\subsubsection{Hardware Thread ID (\sphinxstyleliteralintitle{\sphinxupquote{mhartid}})}
\label{\detokenize{control_status_registers:hardware-thread-id-mhartid}}\label{\detokenize{control_status_registers:csr-mhartid}}
\sphinxAtStartPar
CSR Address: 0xF14

\sphinxAtStartPar
Reset Value: Defined

\sphinxAtStartPar
Detailed:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabular}[t]{\X{15}{100}\X{15}{100}\X{70}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Bit \#}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mode}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
31:0
&
\sphinxAtStartPar
RO
&
\sphinxAtStartPar
Hardware Thread ID \sphinxstylestrong{hart\_id\_i}, see  {\hyperref[\detokenize{integration:core-integration}]{\sphinxcrossref{\DUrole{std,std-ref}{Core Integration}}}}
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\subsection{Non\sphinxhyphen{}RISC\sphinxhyphen{}V CSRs}
\label{\detokenize{control_status_registers:non-risc-v-csrs}}

\subsubsection{User Hardware Thread ID (\sphinxstyleliteralintitle{\sphinxupquote{uhartid}})}
\label{\detokenize{control_status_registers:user-hardware-thread-id-uhartid}}\label{\detokenize{control_status_registers:csr-uhartid}}
\sphinxAtStartPar
CSR Address: 0xCD0 (only present if \sphinxcode{\sphinxupquote{COREV\_PULP}} = 1)

\sphinxAtStartPar
Reset Value: Defined

\sphinxAtStartPar
Detailed:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabular}[t]{\X{15}{100}\X{15}{100}\X{70}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Bit \#}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mode}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
31:0
&
\sphinxAtStartPar
RO
&
\sphinxAtStartPar
Hardware Thread ID \sphinxstylestrong{hart\_id\_i}, see  {\hyperref[\detokenize{integration:core-integration}]{\sphinxcrossref{\DUrole{std,std-ref}{Core Integration}}}}
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Similar to \sphinxcode{\sphinxupquote{mhartid}} the \sphinxcode{\sphinxupquote{uhartid}} provides the Hardware Thread ID. It differs from \sphinxcode{\sphinxupquote{mhartid}} only in the required privilege level.
On CV32E40P, as it is a machine mode only implementation, this difference is not noticeable.


\subsubsection{Privilege Level (\sphinxstyleliteralintitle{\sphinxupquote{privlv}})}
\label{\detokenize{control_status_registers:privilege-level-privlv}}
\sphinxAtStartPar
CSR Address: 0xCD1 (only present if \sphinxcode{\sphinxupquote{COREV\_PULP}} = 1)

\sphinxAtStartPar
Reset Value: 0x0000\_0003

\sphinxAtStartPar
Detailed:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabular}[t]{\X{15}{100}\X{15}{100}\X{70}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Bit \#}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mode}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
31:2
&
\sphinxAtStartPar
RO
&
\sphinxAtStartPar
Reads as 0.
\\
\sphinxhline
\sphinxAtStartPar
1:0
&
\sphinxAtStartPar
RO
&
\sphinxAtStartPar
Current Privilege Level

\sphinxAtStartPar
00 = User

\sphinxAtStartPar
01 = Supervisor

\sphinxAtStartPar
10 = Hypervisor

\sphinxAtStartPar
11 = Machine

\sphinxAtStartPar
CV32E40P only supports Machine mode.
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\subsubsection{ZFINX ISA (\sphinxstyleliteralintitle{\sphinxupquote{zfinx}})}
\label{\detokenize{control_status_registers:zfinx-isa-zfinx}}\label{\detokenize{control_status_registers:csr-zfinx}}
\sphinxAtStartPar
CSR Address: 0xCD2 (only present if \sphinxcode{\sphinxupquote{COREV\_PULP}} = 1 \& (\sphinxcode{\sphinxupquote{FPU}} = 0 | (\sphinxcode{\sphinxupquote{FPU}} = 1 \& \sphinxcode{\sphinxupquote{ZFINX}} = 1)) )

\sphinxAtStartPar
Reset Value: Defined


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabular}[t]{\X{15}{100}\X{15}{100}\X{70}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Bit \#}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Mode}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
31:1
&
\sphinxAtStartPar
RO
&
\sphinxAtStartPar
0
\\
\sphinxhline
\sphinxAtStartPar
0
&
\sphinxAtStartPar
RO
&
\sphinxAtStartPar
1 if \sphinxcode{\sphinxupquote{FPU}} = 1 and \sphinxcode{\sphinxupquote{ZFINX}} = 1 else 0.
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxstepscope


\chapter{Exceptions and Interrupts}
\label{\detokenize{exceptions_interrupts:exceptions-and-interrupts}}\label{\detokenize{exceptions_interrupts:exceptions-interrupts}}\label{\detokenize{exceptions_interrupts::doc}}
\sphinxAtStartPar
CV32E40P implements trap handling for interrupts and exceptions according to the RISC\sphinxhyphen{}V Privileged Specification, version 1.11.
The \sphinxcode{\sphinxupquote{irq\_i{[}31:16{]}}} interrupts are a custom extension.

\sphinxAtStartPar
When entering an interrupt/exception handler, the core sets the \sphinxcode{\sphinxupquote{mepc}} CSR to the current program counter and saves \sphinxcode{\sphinxupquote{mstatus}}.MIE to \sphinxcode{\sphinxupquote{mstatus}}.MPIE.
All exceptions cause the core to jump to the base address of the vector table in the \sphinxcode{\sphinxupquote{mtvec}} CSR.
Interrupts are handled in either direct mode or vectored mode depending on the value of \sphinxcode{\sphinxupquote{mtvec}}.MODE. In direct mode the core
jumps to the base address of the vector table in the \sphinxcode{\sphinxupquote{mtvec}} CSR. In vectored mode the core jumps to the base address
plus four times the interrupt ID. Upon executing an MRET instruction, the core jumps to the program counter previously saved in the
\sphinxcode{\sphinxupquote{mepc}} CSR and restores \sphinxcode{\sphinxupquote{mstatus}}.MPIE to \sphinxcode{\sphinxupquote{mstatus}}.MIE.

\sphinxAtStartPar
The base address of the vector table must be aligned to 256 bytes (i.e., its least significant byte must be 0x00) and can be programmed
by writing to the \sphinxcode{\sphinxupquote{mtvec}} CSR. For more information, see the {\hyperref[\detokenize{control_status_registers:cs-registers}]{\sphinxcrossref{\DUrole{std,std-ref}{Control and Status Registers}}}} documentation.

\sphinxAtStartPar
The core starts fetching at the address defined by \sphinxcode{\sphinxupquote{boot\_addr\_i}}. It is assumed that the boot address is supplied via a register
to avoid long paths to the instruction fetch unit.


\section{Interrupt Interface}
\label{\detokenize{exceptions_interrupts:interrupt-interface}}
\sphinxAtStartPar
\hyperref[\detokenize{exceptions_interrupts:interrupt-interface-signals}]{Table \ref{\detokenize{exceptions_interrupts:interrupt-interface-signals}}} describes the interrupt interface.


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Interrupt interface signals}\label{\detokenize{exceptions_interrupts:interrupt-interface-signals}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{20}{100}\X{15}{100}\X{65}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Signal}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Direction}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{irq\_i{[}31:0{]}}}
&
\sphinxAtStartPar
input
&
\sphinxAtStartPar
Level sensistive active high interrupt inputs.
Not all interrupt inputs can be used on
CV32E40P. Specifically irq\_i{[}15:12{]},
irq\_i{[}10:8{]}, irq\_i{[}6:4{]} and irq\_i{[}2:0{]} shall be
tied to 0 externally as they are reserved for
future standard use (or for cores which are not
Machine mode only) in the RISC\sphinxhyphen{}V Privileged
specification.

\sphinxAtStartPar
irq\_i{[}11{]}, irq\_i{[}7{]}, and irq\_i{[}3{]}
correspond to the Machine External
Interrupt (MEI), Machine Timer Interrupt (MTI),
and Machine Software Interrupt (MSI)
respectively.

\sphinxAtStartPar
The irq\_i{[}31:16{]} interrupts
are a CV32E40P specific extension to the RISC\sphinxhyphen{}V
Basic (a.k.a. CLINT) interrupt scheme.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{irq\_ack\_o}}
&
\sphinxAtStartPar
output
&
\sphinxAtStartPar
Interrupt acknowledge

\sphinxAtStartPar
Set to 1 for one cycle
when the interrupt with ID \sphinxcode{\sphinxupquote{irq\_id\_o{[}4:0{]}}} is
taken.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{irq\_id\_o{[}4:0{]}}}
&
\sphinxAtStartPar
output
&
\sphinxAtStartPar
Interrupt index for taken interrupt

\sphinxAtStartPar
Only valid when \sphinxcode{\sphinxupquote{irq\_ack\_o}} = 1.
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\section{Interrupts}
\label{\detokenize{exceptions_interrupts:interrupts}}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{irq\_i{[}31:0{]}}} interrupts are controlled via the \sphinxcode{\sphinxupquote{mstatus}}, \sphinxcode{\sphinxupquote{mie}} and \sphinxcode{\sphinxupquote{mip}} CSRs. CV32E40P uses the upper 16 bits of \sphinxcode{\sphinxupquote{mie}} and \sphinxcode{\sphinxupquote{mip}} for custom interrupts (\sphinxcode{\sphinxupquote{irq\_i{[}31:16{]}}}),
which reflects an intended custom extension in the RISC\sphinxhyphen{}V Basic (a.k.a. CLINT) interrupt architecture.
After reset, all interrupts are disabled.
To enable interrupts, both the global interrupt enable (MIE) bit in the \sphinxcode{\sphinxupquote{mstatus}} CSR and the corresponding individual interrupt enable bit in the \sphinxcode{\sphinxupquote{mie}} CSR need to be set.
For more information, see the {\hyperref[\detokenize{control_status_registers:cs-registers}]{\sphinxcrossref{\DUrole{std,std-ref}{Control and Status Registers}}}} documentation.

\sphinxAtStartPar
If multiple interrupts are pending, they are handled in the fixed priority order defined by the RISC\sphinxhyphen{}V Privileged Specification, version 1.11 (see Machine Interrupt Registers, Section 3.1.9).
The highest priority is given to the interrupt with the highest ID, except for the Machine Timer Interrupt, which has the lowest priority. So from high to low priority the interrupts are
ordered as follows: \sphinxcode{\sphinxupquote{irq\_i{[}31{]}}}, \sphinxcode{\sphinxupquote{irq\_i{[}30{]}}}, …, \sphinxcode{\sphinxupquote{irq\_i{[}16{]}}}, \sphinxcode{\sphinxupquote{irq\_i{[}11{]}}}, \sphinxcode{\sphinxupquote{irq\_i{[}3{]}}}, \sphinxcode{\sphinxupquote{irq\_i{[}7{]}}}.

\sphinxAtStartPar
All interrupt lines are level\sphinxhyphen{}sensitive. There are two supported mechanisms by which interrupts can be cleared at the external source.
\begin{itemize}
\item {} 
\sphinxAtStartPar
A software\sphinxhyphen{}based mechanism in which the interrupt handler signals completion of the handling routine to the interrupt source, e.g., through a memory\sphinxhyphen{}mapped register, which then deasserts the corresponding interrupt line.

\item {} 
\sphinxAtStartPar
A hardware\sphinxhyphen{}based mechanism in which the \sphinxcode{\sphinxupquote{irq\_ack\_o}} and \sphinxcode{\sphinxupquote{irq\_id\_o{[}4:0{]}}} signals are used to clear the interrupt sourcee, e.g. by an external interrupt controller. \sphinxcode{\sphinxupquote{irq\_ack\_o}} is a 1 \sphinxcode{\sphinxupquote{clk\_i}} cycle pulse during which \sphinxcode{\sphinxupquote{irq\_id\_o{[}4:0{]}}} reflects the index in \sphinxcode{\sphinxupquote{irq\_id{[}*{]}}} of the taken interrupt.

\end{itemize}

\sphinxAtStartPar
In Debug Mode, all interrupts are ignored independent of \sphinxcode{\sphinxupquote{mstatus}}.MIE and the content of the \sphinxcode{\sphinxupquote{mie}} CSR.


\section{Exceptions}
\label{\detokenize{exceptions_interrupts:exceptions}}
\sphinxAtStartPar
CV32E40P can trigger an exception due to the following exception causes:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Exceptions}\label{\detokenize{exceptions_interrupts:id1}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{20}{100}\X{80}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Exception Code}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
2
&
\sphinxAtStartPar
Illegal instruction
\\
\sphinxhline
\sphinxAtStartPar
3
&
\sphinxAtStartPar
Breakpoint
\\
\sphinxhline
\sphinxAtStartPar
11
&
\sphinxAtStartPar
Environment call from M\sphinxhyphen{}Mode (ECALL)
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
The illegal instruction exception and M\sphinxhyphen{}Mode ECALL instruction exceptions cannot be disabled and are always active.
The core raises an illegal instruction exception for any instruction in the RISC\sphinxhyphen{}V privileged and unprivileged specifications that is explicitly defined as being illegal according to the ISA implemented by the core, as well as for any instruction that is left undefined in these specifications unless the instruction encoding is configured as a custom CV32E40P instruction for specific parameter settings as defined in (see {\hyperref[\detokenize{instruction_set_extensions:custom-isa-extensions}]{\sphinxcrossref{\DUrole{std,std-ref}{CORE\sphinxhyphen{}V Instruction Set Custom Extensions}}}}).
For example, in case the parameter \sphinxcode{\sphinxupquote{FPU}} is set to 0, the CV32E40P raises an illegal instruction exception for any RVF instruction or CSR instruction trying to access F CSRs.
The same concerns PULP extensions everytime both parameters \sphinxcode{\sphinxupquote{COREV\_PULP}} and \sphinxcode{\sphinxupquote{CORE\_CLUSTER}} are set to 0 (see {\hyperref[\detokenize{integration:core-integration}]{\sphinxcrossref{\DUrole{std,std-ref}{Core Integration}}}}).


\section{Nested Interrupt/Exception Handling}
\label{\detokenize{exceptions_interrupts:nested-interrupt-exception-handling}}
\sphinxAtStartPar
CV32E40P does support nested interrupt/exception handling in software.
The hardware automatically disables interrupts upon entering an interrupt/exception handler.
Otherwise, interrupts/exceptions during the critical part of the handler, i.e. before software has saved the \sphinxcode{\sphinxupquote{mepc}} and \sphinxcode{\sphinxupquote{mstatus}} CSRs, would cause those CSRs to be overwritten.
If desired, software can explicitly enable interrupts by setting \sphinxcode{\sphinxupquote{mstatus}}.MIE to 1 from within the handler.
However, software should only do this after saving \sphinxcode{\sphinxupquote{mepc}} and \sphinxcode{\sphinxupquote{mstatus}}.
There is no limit on the maximum number of nested interrupts.
Note that, after enabling interrupts by setting \sphinxcode{\sphinxupquote{mstatus}}.MIE to 1, the current handler will be interrupted also by lower priority interrupts.
To allow higher priority interrupts only, the handler must configure \sphinxcode{\sphinxupquote{mie}} accordingly.

\sphinxAtStartPar
The following pseudo\sphinxhyphen{}code snippet visualizes how to perform nested interrupt handling in software.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{isr\PYGZus{}handle\PYGZus{}nested\PYGZus{}interrupts}\PYG{p}{(}\PYG{n}{id}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{c+c1}{// Save mpec and mstatus to stack}
\PYG{+w}{  }\PYG{n}{mepc\PYGZus{}bak}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{mepc}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{mstatus\PYGZus{}bak}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{mstatus}\PYG{p}{;}

\PYG{+w}{  }\PYG{c+c1}{// Save mie to stack (optional)}
\PYG{+w}{  }\PYG{n}{mie\PYGZus{}bak}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{mie}\PYG{p}{;}

\PYG{+w}{  }\PYG{c+c1}{// Keep lower\PYGZhy{}priority interrupts disabled (optional)}
\PYG{+w}{  }\PYG{n}{mie}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{mie}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{o}{\PYGZti{}}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{id}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{  }\PYG{c+c1}{// Re\PYGZhy{}enable interrupts}
\PYG{+w}{  }\PYG{n}{mstatus}\PYG{p}{.}\PYG{n}{MIE}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}

\PYG{+w}{  }\PYG{c+c1}{// Handle interrupt}
\PYG{+w}{  }\PYG{c+c1}{// This code block can be interrupted by other interrupts.}
\PYG{+w}{  }\PYG{c+c1}{// ...}

\PYG{+w}{  }\PYG{c+c1}{// Restore mstatus (this disables interrupts) and mepc}
\PYG{+w}{  }\PYG{n}{mstatus}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{mstatus\PYGZus{}bak}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{mepc}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{mepc\PYGZus{}bak}\PYG{p}{;}

\PYG{+w}{  }\PYG{c+c1}{// Restore mie (optional)}
\PYG{+w}{  }\PYG{n}{mie}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{mie\PYGZus{}bak}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Nesting of interrupts/exceptions in hardware is not supported.

\sphinxstepscope


\chapter{Debug \& Trigger}
\label{\detokenize{debug:debug-trigger}}\label{\detokenize{debug:debug-support}}\label{\detokenize{debug::doc}}
\sphinxAtStartPar
CV32E40P offers support for execution\sphinxhyphen{}based debug according to the \sphinxhref{https://github.com/riscv/riscv-debug-spec/blob/release/riscv-debug-release.pdf}{RISC\sphinxhyphen{}V Debug Specification}, version 0.13.2.
The main requirements for the core are described in Chapter 4: RISC\sphinxhyphen{}V Debug, Chapter 5: Trigger Module, and Appendix A.2: Execution Based.

\sphinxAtStartPar
The following list shows the simplified overview of events that occur in the core when debug is requested:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Enters Debug Mode

\item {} 
\sphinxAtStartPar
Saves the PC to DPC

\item {} 
\sphinxAtStartPar
Updates the cause in the DCSR

\item {} 
\sphinxAtStartPar
Points the PC to the location determined by the input port dm\_haltaddr\_i

\item {} 
\sphinxAtStartPar
Begins executing debug control code.

\end{enumerate}

\sphinxAtStartPar
Debug Mode can be entered by one of the following conditions:
\begin{itemize}
\item {} 
\sphinxAtStartPar
External debug event using the debug\_req\_i signal

\item {} 
\sphinxAtStartPar
Trigger Module match event

\item {} 
\sphinxAtStartPar
ebreak instruction when not in Debug Mode and when DCSR.EBREAKM == 1 (see {\hyperref[\detokenize{debug:ebreak-behavior}]{\sphinxcrossref{\DUrole{std,std-ref}{EBREAK Behavior}}}} below)

\end{itemize}

\sphinxAtStartPar
A user wishing to perform an abstract access, whereby the user can observe or control a core’s GPR (either integer of floating\sphinxhyphen{}point one) or CSR register from the hart,
is done by invoking debug control code to move values to and from internal registers to an externally addressable Debug Module (DM).
Using this execution\sphinxhyphen{}based debug allows for the reduction of the overall number of debug interface signals.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Debug support in CV32E40P is only one of the components needed to build a System on Chip design with run\sphinxhyphen{}control debug support (think “the ability to attach GDB to a core over JTAG”).
Additionally, a Debug Module and a Debug Transport Module, compliant with the RISC\sphinxhyphen{}V Debug Specification, are needed.

\sphinxAtStartPar
A supported open source implementation of these building blocks can be found in the \sphinxhref{https://github.com/pulp-platform/riscv-dbg/}{RISC\sphinxhyphen{}V Debug Support for PULP Cores IP block}.
\end{sphinxadmonition}

\sphinxAtStartPar
The CV3240P also supports a Trigger Module to enable entry into Debug Mode on a trigger event with the following features:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Number of trigger register(s) : 1

\item {} 
\sphinxAtStartPar
Supported trigger types: instruction address match (Match Control)

\end{itemize}

\sphinxAtStartPar
The CV32E40P will not support the optional debug features 10, 11, \& 12 listed in Section 4.1 of the \sphinxhref{https://github.com/riscv/riscv-debug-spec/blob/release/riscv-debug-release.pdf}{RISC\sphinxhyphen{}V Debug Specification}.
Specifically, a control transfer instruction’s destination location being in or out of the Program Buffer and instructions depending on PC value shall \sphinxstylestrong{not} cause an illegal instruction.


\section{Debug Interface}
\label{\detokenize{debug:debug-interface}}

\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Debug interface signals}\label{\detokenize{debug:debug-interface-signals}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{30}{100}\X{15}{100}\X{55}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Signal}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Direction}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{debug\_req\_i}}
&
\sphinxAtStartPar
input
&
\sphinxAtStartPar
Request to enter Debug Mode
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{debug\_havereset\_o}}
&
\sphinxAtStartPar
output
&
\sphinxAtStartPar
Debug status: Core has been reset
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{debug\_running\_o}}
&
\sphinxAtStartPar
output
&
\sphinxAtStartPar
Debug status: Core is running
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{debug\_halted\_o}}
&
\sphinxAtStartPar
output
&
\sphinxAtStartPar
Debug status: Core is halted
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dm\_halt\_addr\_i{[}31:0{]}}}
&
\sphinxAtStartPar
input
&
\sphinxAtStartPar
Address for debugger entry
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dm\_exception\_addr\_i{[}31:0{]}}}
&
\sphinxAtStartPar
input
&
\sphinxAtStartPar
Address for debugger exception entry
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{debug\_req\_i}} is the “debug interrupt”, issued by the debug module when the core should enter Debug Mode.
The \sphinxcode{\sphinxupquote{debug\_req\_i}} is synchronous to \sphinxcode{\sphinxupquote{clk\_i}} and requires a minimum assertion of one clock period to enter Debug Mode.
The instruction being decoded during the same cycle that \sphinxcode{\sphinxupquote{debug\_req\_i}} is first asserted shall not be executed before entering Debug Mode.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{debug\_havereset\_o}}, \sphinxcode{\sphinxupquote{debug\_running\_o}} and \sphinxcode{\sphinxupquote{debug\_mode\_o}} signals provide the operational status of the core to the debug module.
The assertion of these signals is mutually exclusive.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{debug\_havereset\_o}} is used to signal that the CV32E40P has been reset. \sphinxcode{\sphinxupquote{debug\_havereset\_o}} is set high during the assertion of \sphinxcode{\sphinxupquote{rst\_ni}}.
It will be cleared low a few (unspecified) cycles after \sphinxcode{\sphinxupquote{rst\_ni}} has been deasserted \sphinxstylestrong{and} \sphinxcode{\sphinxupquote{fetch\_enable\_i}} has been sampled high.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{debug\_running\_o}} is used to signal that the CV32E40P is running normally.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{debug\_halted\_o}} is used to signal that the CV32E40P is in debug mode.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dm\_halt\_addr\_i}} is the address where the PC jumps to for a debug entry event. When in Debug Mode, an ebreak instruction will also cause the PC
to jump back to this address without affecting status registers (see {\hyperref[\detokenize{debug:ebreak-behavior}]{\sphinxcrossref{\DUrole{std,std-ref}{EBREAK Behavior}}}} below).

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dm\_exception\_addr\_i}} is the address where the PC jumps to when an exception occurs during Debug Mode.
When in Debug Mode, the mret or uret instruction will also cause the PC to jump back to this address without affecting status registers.

\sphinxAtStartPar
Both \sphinxcode{\sphinxupquote{dm\_halt\_addr\_i}} and \sphinxcode{\sphinxupquote{dm\_exception\_addr\_i}} must be word aligned.


\section{Core Debug Registers}
\label{\detokenize{debug:core-debug-registers}}
\sphinxAtStartPar
CV32E40P implements four core debug registers, namely {\hyperref[\detokenize{control_status_registers:csr-dcsr}]{\sphinxcrossref{\DUrole{std,std-ref}{Debug Control and Status (dcsr)}}}}, {\hyperref[\detokenize{control_status_registers:csr-dpc}]{\sphinxcrossref{\DUrole{std,std-ref}{Debug PC (dpc)}}}} and two debug scratch registers.
Access to these registers in non Debug Mode results in an illegal instruction.

\sphinxAtStartPar
Several trigger registers are required to adhere to specification. The following are the most relevant: {\hyperref[\detokenize{control_status_registers:csr-tselect}]{\sphinxcrossref{\DUrole{std,std-ref}{Trigger Select register (tselect)}}}}, {\hyperref[\detokenize{control_status_registers:csr-tdata1}]{\sphinxcrossref{\DUrole{std,std-ref}{Trigger Data register 1 (tdata1)}}}},  {\hyperref[\detokenize{control_status_registers:csr-tdata2}]{\sphinxcrossref{\DUrole{std,std-ref}{Trigger Data register 2 (tdata2)}}}} and {\hyperref[\detokenize{control_status_registers:csr-tinfo}]{\sphinxcrossref{\DUrole{std,std-ref}{Trigger Info (tinfo)}}}}.

\sphinxAtStartPar
The TDATA1.DMODE is hardwired to a value of 1. In non Debug Mode, writes to Trigger registers are ignored and reads reflect CSR values.


\section{Debug state}
\label{\detokenize{debug:debug-state}}
\sphinxAtStartPar
As specified in \sphinxhref{https://github.com/riscv/riscv-debug-spec/blob/release/riscv-debug-release.pdf}{RISC\sphinxhyphen{}V Debug Specification} every hart that can be selected by
the Debug Module is in exactly one of four states: \sphinxcode{\sphinxupquote{nonexistent}}, \sphinxcode{\sphinxupquote{unavailable}}, \sphinxcode{\sphinxupquote{running}} or \sphinxcode{\sphinxupquote{halted}}.

\sphinxAtStartPar
The remainder of this section assumes that the CV32E40P will not be classified as \sphinxcode{\sphinxupquote{nonexistent}} by the integrator.

\sphinxAtStartPar
The CV32E40P signals to the Debug Module whether it is \sphinxcode{\sphinxupquote{running}} or \sphinxcode{\sphinxupquote{halted}} via its \sphinxcode{\sphinxupquote{debug\_running\_o}} and \sphinxcode{\sphinxupquote{debug\_halted\_o}} pins
respectively. Therefore, assuming that this core will not be integrated as a \sphinxcode{\sphinxupquote{nonexistent}} core, the CV32E40P is classified as \sphinxcode{\sphinxupquote{unavailable}}
when neither \sphinxcode{\sphinxupquote{debug\_running\_o}} or \sphinxcode{\sphinxupquote{debug\_halted\_o}} is asserted. Upon \sphinxcode{\sphinxupquote{rst\_ni}} assertion the debug state will be \sphinxcode{\sphinxupquote{unavailable}} until some
cycle(s) after \sphinxcode{\sphinxupquote{rst\_ni}} has been deasserted and \sphinxcode{\sphinxupquote{fetch\_enable\_i}} has been sampled high. After this point (until a next reset assertion) the
core will transition between having its \sphinxcode{\sphinxupquote{debug\_halted\_o}} or \sphinxcode{\sphinxupquote{debug\_running\_o}} pin asserted depending whether the core is in debug mode or not.
Exactly one of the \sphinxcode{\sphinxupquote{debug\_havereset\_o}}, \sphinxcode{\sphinxupquote{debug\_running\_o}} or \sphinxcode{\sphinxupquote{debug\_halted\_o}} is asserted at all times.

\sphinxAtStartPar
\hyperref[\detokenize{debug:debug-running}]{Figure \ref{\detokenize{debug:debug-running}}} and show \hyperref[\detokenize{debug:debug-halted}]{Figure \ref{\detokenize{debug:debug-halted}}} show typical examples of transitioning into the \sphinxcode{\sphinxupquote{running}} and \sphinxcode{\sphinxupquote{halted}} states.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{debug_running}.svg}
\caption{Transition into debug \sphinxcode{\sphinxupquote{running}} state}\label{\detokenize{debug:debug-running}}\end{figure}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{debug_halted}.svg}
\caption{Transition into debug \sphinxcode{\sphinxupquote{halted}} state}\label{\detokenize{debug:debug-halted}}\end{figure}

\sphinxAtStartPar
The key properties of the debug states are:
\begin{itemize}
\item {} 
\sphinxAtStartPar
The CV32E40P can remain in its \sphinxcode{\sphinxupquote{unavailable}} state for an arbitrarily long time (depending on \sphinxcode{\sphinxupquote{rst\_ni}} and \sphinxcode{\sphinxupquote{fetch\_enable\_i}}).

\item {} 
\sphinxAtStartPar
If \sphinxcode{\sphinxupquote{debug\_req\_i}} is asserted after \sphinxcode{\sphinxupquote{rst\_ni}} deassertion and before or coincident with the assertion of \sphinxcode{\sphinxupquote{fetch\_enable\_i}}, then the CV32E40P
is guaranteed to transition straight from its \sphinxcode{\sphinxupquote{unavailable}} state into its \sphinxcode{\sphinxupquote{halted}} state. If \sphinxcode{\sphinxupquote{debug\_req\_i}} is asserted at a later
point in time, then the CV32E40P might transition through the \sphinxcode{\sphinxupquote{running}} state on its ways to the \sphinxcode{\sphinxupquote{halted}} state.

\item {} 
\sphinxAtStartPar
If \sphinxcode{\sphinxupquote{debug\_req\_i}} is asserted during the \sphinxcode{\sphinxupquote{running}} state, the core will eventually transition into the \sphinxcode{\sphinxupquote{halted}} state (typically after a couple of cycles).

\end{itemize}


\section{EBREAK Behavior}
\label{\detokenize{debug:ebreak-behavior}}\label{\detokenize{debug:id3}}
\sphinxAtStartPar
The EBREAK instruction description is distributed across several RISC\sphinxhyphen{}V specifications: \sphinxhref{https://github.com/riscv/riscv-debug-spec/blob/release/riscv-debug-release.pdf}{RISC\sphinxhyphen{}V Debug Specification},
\sphinxhref{https://github.com/riscv/riscv-isa-manual/releases/tag/Ratified-IMFDQC-and-Priv-v1.11}{RISC\sphinxhyphen{}V Priveleged Specification},
\sphinxhref{https://github.com/riscv/riscv-isa-manual/releases/tag/Ratified-IMAFDQC}{RISC\sphinxhyphen{}V ISA}. The following is a summary of the behavior for three common scenarios.


\subsection{Scenario 1 : Enter Exception}
\label{\detokenize{debug:scenario-1-enter-exception}}\label{\detokenize{debug:ebreak-scenario-1}}
\sphinxAtStartPar
Executing the EBREAK instruction when the core is \sphinxstylestrong{not} in Debug Mode and the DCSR.EBREAKM == 0 shall result in the following actions:
\begin{itemize}
\item {} 
\sphinxAtStartPar
The core enters the exception handler routine located at MTVEC (Debug Mode is not entered)

\item {} 
\sphinxAtStartPar
MEPC \& MCAUSE are updated

\end{itemize}

\sphinxAtStartPar
To properly return from the exception, the ebreak handler will need to increment the MEPC to the next instruction.
This requires querying the size of the ebreak instruction that was used to enter the exception (16 bit c.ebreak or 32 bit ebreak).

\sphinxAtStartPar
As mentioned in {\hyperref[\detokenize{corev_hw_loop:hwloop-exceptions-handlers}]{\sphinxcrossref{\DUrole{std,std-ref}{Hardware loops impact on application, exceptions handlers and debugger}}}}, some additional cases exist for MEPC update when ebreak is the last instruction of an Hardware Loop.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The CV32E40P does not support MTVAL CSR register which would have saved the value of the instruction for exceptions. This may be supported on a future core.
\end{sphinxadmonition}


\subsection{Scenario 2 : Enter Debug Mode}
\label{\detokenize{debug:scenario-2-enter-debug-mode}}\label{\detokenize{debug:ebreak-scenario-2}}
\sphinxAtStartPar
Executing the EBREAK instruction when the core is \sphinxstylestrong{not} in Debug Mode and the DCSR.EBREAKM == 1 shall result in the following actions:
\begin{itemize}
\item {} 
\sphinxAtStartPar
The core enters Debug Mode and starts executing debug code located at \sphinxcode{\sphinxupquote{dm\_halt\_addr\_i}} (exception routine not called)

\item {} 
\sphinxAtStartPar
DPC \& DCSR are updated

\end{itemize}

\sphinxAtStartPar
Similar to the exception scenario above, the debugger will need to increment the DPC to the next instruction before returning from Debug Mode.

\sphinxAtStartPar
There is no forseseen situtation where it would be needed to enter in Debug Mode only on the last instruction of an Hardware Loop but just in case this is mentioned in {\hyperref[\detokenize{corev_hw_loop:hwloop-exceptions-handlers}]{\sphinxcrossref{\DUrole{std,std-ref}{Hardware loops impact on application, exceptions handlers and debugger}}}} as well.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The default value of DCSR.EBREAKM is 0 and the DCSR is only accessible in Debug Mode. To enter Debug Mode from EBREAK,
the user will first need to enter Debug Mode through some other means, such as from the external \sphinxcode{\sphinxupquote{debug\_req\_i}}, and set DCSR.EBREAKM.
\end{sphinxadmonition}


\subsection{Scenario 3 : Exit Program Buffer \& Restart Debug Code}
\label{\detokenize{debug:scenario-3-exit-program-buffer-restart-debug-code}}\label{\detokenize{debug:ebreak-scenario-3}}
\sphinxAtStartPar
Executing the EBREAK instruction when the core is in Debug Mode shall result in the following actions:
\begin{itemize}
\item {} 
\sphinxAtStartPar
The core remains in Debug Mode and execution jumps back to the beginning of the debug code located at \sphinxcode{\sphinxupquote{dm\_halt\_addr\_i}}

\item {} 
\sphinxAtStartPar
none of the CSRs are modified

\end{itemize}


\section{Interrupts during Single\sphinxhyphen{}Step Behavior}
\label{\detokenize{debug:interrupts-during-single-step-behavior}}\label{\detokenize{debug:interrupts-single-stepping}}
\sphinxAtStartPar
The CV32E40P is not compliant with the intended interpretation of the RISC\sphinxhyphen{}V Debug spec 0.13.2 specification when interrupts occur during Single\sphinxhyphen{}Steps.
However, the intended behavior has been clarified a posteriori only in version 1.0.0.
See \sphinxurl{https://github.com/riscv/riscv-debug-spec/issues/510}.
The CV32E40P executes the first instruction of the interrupt handler and retires it before re\sphinxhyphen{}entering in Debug Mode, which is prohibited in version 1.0.0 but not specified in 0.13.2.
For details about the specific use\sphinxhyphen{}case, please refer to \sphinxurl{https://github.com/openhwgroup/core-v-verif/issues/904}.

\sphinxstepscope


\chapter{Pipeline Details}
\label{\detokenize{pipeline:pipeline-details}}\label{\detokenize{pipeline:id1}}\label{\detokenize{pipeline::doc}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{CV32E40P_Pipeline}.png}
\caption{CV32E40P Pipeline}\label{\detokenize{pipeline:cv32e40p-pipeline}}\end{figure}

\sphinxAtStartPar
CV32E40P has a 4\sphinxhyphen{}stage in\sphinxhyphen{}order completion pipeline, the 4 stages are:
\begin{description}
\sphinxlineitem{Instruction Fetch (IF)}
\sphinxAtStartPar
Fetches instructions from memory via an aligning prefetch buffer, capable of fetching 1 instruction per cycle if the instruction side memory system allows. This prefetch buffer is able to store 2 32\sphinxhyphen{}b data.
The IF stage also pre\sphinxhyphen{}decodes RVC instructions into RV32I base instructions. See {\hyperref[\detokenize{instruction_fetch:instruction-fetch}]{\sphinxcrossref{\DUrole{std,std-ref}{Instruction Fetch}}}} for details.

\sphinxlineitem{Instruction Decode (ID)}
\sphinxAtStartPar
Decodes fetched instruction and performs required register file reads. Jumps are taken from the ID stage.

\sphinxlineitem{Execute (EX)}
\sphinxAtStartPar
Executes the instructions. The EX stage contains the ALU, Multiplier and Divider. Branches (with their condition met) are taken from the EX stage. Multi\sphinxhyphen{}cycle instructions will stall this stage until they are complete.
The ALU, Multiplier and Divider instructions write back their result to the register file from the EX stage. The address generation part of the load\sphinxhyphen{}store\sphinxhyphen{}unit (LSU) is contained in EX as well.

\sphinxAtStartPar
The FPU writes back its result at EX stage as well through this ALU/Mult/Div register file write port when FPU\_*\_LAT is either 0 cycle or greater than 1 cycle.
When FPU\_*\_LAT \textgreater{} 1, FPU write\sphinxhyphen{}back has the highest priority so it will stall EX stage if there is a conflict. There are few exceptions to this FPU priority over ALU/Mult/Div.

\sphinxAtStartPar
They are:
\begin{itemize}
\item {} 
\sphinxAtStartPar
There is a multi\sphinxhyphen{}cycle MULH in EX.

\item {} 
\sphinxAtStartPar
There is a Misaligned LOAD/STORE in EX.

\item {} 
\sphinxAtStartPar
There is a Post\sphinxhyphen{}Increment LOAD/STORE in EX.

\end{itemize}

\sphinxAtStartPar
In those 3 exceptions, EX will not be stalled, FPU result (and flags) are memorized and will be written back in the register file (and FPU CSR) as soon as there is no conflict anymore.

\sphinxlineitem{Writeback (WB)}
\sphinxAtStartPar
Writes the result of Load instructions back to the register file.

\sphinxAtStartPar
The FPU writes back its result from WB stage as well when FPU\_*\_LAT is 1 cycle. It is reusing register file LSU write port but LSU has the highest priority over FPU if there is a conflict.

\end{description}


\section{Hazards}
\label{\detokenize{pipeline:hazards}}
\sphinxAtStartPar
There is a forwarding path betwen ALU, Multiplier and Divider result in EX stage and ID stage flip\sphinxhyphen{}flops to avoid the need of a write\sphinxhyphen{}through register file.
This allows to have 0\sphinxhyphen{}cycle penalty between those instructions and immediately following one when using result.
This is the same with 0\sphinxhyphen{}cycle latency FPU instructions.

\sphinxAtStartPar
But the CV32E40P experiences a 1\sphinxhyphen{}cycle penalty on the following hazards:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Load data hazard in case the instruction immediately following a load uses the result of that load

\item {} 
\sphinxAtStartPar
Jump register (jalr) data hazard in case that a jalr depends on the result of an immediately preceding instruction

\item {} 
\sphinxAtStartPar
FPU data hazard when FPU\_*\_LAT = 1 in case the instruction immediately following a FPU one (except FDIV/FSQRT) uses the result of the FPU

\end{itemize}

\sphinxAtStartPar
More than 1\sphinxhyphen{}cycle penalty will happen when:
\begin{itemize}
\item {} 
\sphinxAtStartPar
FPU data hazard of FPU\_*\_LAT cycles (FPU\_*\_LAT \textgreater{} 1) in case the instruction immediately following a FPU one (except FDIV/FSQRT) uses the result of the FPU

\item {} 
\sphinxAtStartPar
FPU data hazard in case the instruction immediately following FDIV/FSQRT uses the result of those instructions

\end{itemize}

\sphinxAtStartPar
Those cycles penalty can be hidden if the compiler is able to add instructions between the instructions causing this data hazard.


\section{Single\sphinxhyphen{} and Multi\sphinxhyphen{}Cycle Instructions}
\label{\detokenize{pipeline:single-and-multi-cycle-instructions}}
\sphinxAtStartPar
\hyperref[\detokenize{pipeline:cycle-counts-per-instruction-type}]{Table \ref{\detokenize{pipeline:cycle-counts-per-instruction-type}}} shows the cycle count per instruction type. Some instructions have a variable time, this is indicated as a range e.g. 1..32 means that the instruction takes a minimum of 1 cycle and a maximum of 32 cycles.
The cycle counts assume zero stall on the instruction\sphinxhyphen{}side interface and zero stall on the data\sphinxhyphen{}side memory interface.


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Cycle counts per instruction type}\label{\detokenize{pipeline:cycle-counts-per-instruction-type}}\label{\detokenize{pipeline:instructions-latency-table}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{20}{100}\X{30}{100}\X{50}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Instruction Type}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Cycles}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
Integer

\sphinxAtStartPar
Computational
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
Integer Computational Instructions are defined in the
RISCV\sphinxhyphen{}V RV32I Base Integer Instruction Set.
\\
\sphinxhline
\sphinxAtStartPar
Multiplication
&
\sphinxAtStartPar
1 (mul)

\sphinxAtStartPar
5 (mulh, mulhsu, mulhu)
&
\sphinxAtStartPar
CV32E40P uses a single\sphinxhyphen{}cycle 32\sphinxhyphen{}bit x 32\sphinxhyphen{}bit multiplier
with a 32\sphinxhyphen{}bit result. The multiplications with upper\sphinxhyphen{}word
result take 5 cycles to compute.
\\
\sphinxhline
\sphinxAtStartPar
Division

\sphinxAtStartPar
Remainder
&
\sphinxAtStartPar
3..35

\sphinxAtStartPar
3..35
&
\sphinxAtStartPar
The number of cycles depends on the divider operand value
(operand b), i.e. in the number of leading bits at 0.
The minimum number of cycles is 3 when the divider has zero
leading bits at 0 (e.g., 0x8000000).
The maximum number of cycles is 35 when the divider is 0.
\\
\sphinxhline
\sphinxAtStartPar
Load/Store
&
\sphinxAtStartPar
1

\sphinxAtStartPar
2 (non\sphinxhyphen{}word aligned word
transfer)

\sphinxAtStartPar
2 (halfword transfer crossing
word boundary)

\sphinxAtStartPar
4 (cv.elw)
&
\sphinxAtStartPar
Load/Store is handled in 1 bus transaction using both EX
and WB stages for 1 cycle each. For misaligned word
transfers and for halfword transfers that cross a word
boundary 2 bus transactions are performed using EX and WB
stages for 2 cycles each.
A \sphinxstylestrong{cv.elw} takes 4 cycles.
\\
\sphinxhline
\sphinxAtStartPar
Jump
&
\sphinxAtStartPar
2

\sphinxAtStartPar
3 (target is a non\sphinxhyphen{}word\sphinxhyphen{}aligned
non\sphinxhyphen{}RVC instruction)
&
\sphinxAtStartPar
Jumps are performed in the ID stage. Upon a jump the IF
stage (including prefetch buffer) is flushed. The new PC
request will appear on the instruction\sphinxhyphen{}side memory
interface the same cycle the jump instruction is in the ID
stage.
\\
\sphinxhline
\sphinxAtStartPar
Branch

\sphinxAtStartPar
(Not\sphinxhyphen{}Taken)
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
Any branch where the condition is not met will
not stall.
\\
\sphinxhline
\sphinxAtStartPar
Branch

\sphinxAtStartPar
(Taken)
&
\sphinxAtStartPar
3

\sphinxAtStartPar
4 (target is a non\sphinxhyphen{}word\sphinxhyphen{}aligned
non\sphinxhyphen{}RVC instruction)
&
\sphinxAtStartPar
The EX stage is used to compute the branch decision. Any
branch where the condition is met will be taken from  the
EX stage and will cause a flush of the IF stage (including
prefetch buffer) and ID stage.
\\
\sphinxhline
\sphinxAtStartPar
CSR Access
&
\sphinxAtStartPar
4 (mstatus, mepc, mtvec, mcause,
mcycle, minstret, mhpmcounter*,
mcycleh, minstreth, mhpmcounter*h,
mcountinhibit, mhpmevent*, dscr,
dpc, dscratch0, dscratch1)

\sphinxAtStartPar
1 (all the other CSRs)
&
\sphinxAtStartPar
CSR Access Instruction are defined in ‘Zicsr’ of the
RISC\sphinxhyphen{}V specification.
\\
\sphinxhline
\sphinxAtStartPar
Instruction Fence
&
\sphinxAtStartPar
2

\sphinxAtStartPar
3 (target is a non\sphinxhyphen{}word\sphinxhyphen{}aligned
non\sphinxhyphen{}RVC instruction)
&
\sphinxAtStartPar
The FENCE.I instruction as defined in ‘Zifencei’ of the
RISC\sphinxhyphen{}V specification. Internally it is implemented as a
jump to the instruction following the fence. The jump
performs the required flushing as described above.
\\
\sphinxhline
\sphinxAtStartPar
Floating\sphinxhyphen{}Point
Addition or
Multiplication
&
\sphinxAtStartPar
1..FPU\_ADDMUL\_LAT + 1
&\sphinxmultirow{3}{33}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
\sphinxAtStartPar
Floating\sphinxhyphen{}Point instructions are dispatched to the FPU.
Following instructions can be executed by the Core as long
as they are not FPU ones and there are no Read\sphinxhyphen{}After\sphinxhyphen{}Write
or Write\sphinxhyphen{}After\sphinxhyphen{}Write data hazard between them and the
destination register of the outstanding FPU instruction.
If there are enough instructions between FPU one and
the instruction using the result then cycle number is 1.
“Enough instruction” number is either FPU\_ADDMUL\_LAT,
FPU\_OTHERS\_LAT or 11.
If there are no instruction in between then cycle number is
the maximum value for each category.
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
\\
\sphinxcline{1-2}\sphinxfixclines{3}
\sphinxAtStartPar
Floating\sphinxhyphen{}Point
Comparison, Conversion
or Classify
&
\sphinxAtStartPar
1..FPU\_OTHERS\_LAT + 1
&\sphinxtablestrut{33}\\
\sphinxcline{1-2}\sphinxfixclines{3}
\sphinxAtStartPar
Single Precision
Floating\sphinxhyphen{}Point
Division and
Square\sphinxhyphen{}Root
&
\sphinxAtStartPar
1..19
&\sphinxtablestrut{33}\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxstepscope


\chapter{Instruction Fetch}
\label{\detokenize{instruction_fetch:instruction-fetch}}\label{\detokenize{instruction_fetch:id1}}\label{\detokenize{instruction_fetch::doc}}
\sphinxAtStartPar
The Instruction Fetch (IF) stage of the CV32E40P is able to supply one instruction per cycle to
the Instruction Decode (ID ) stage if the external bus interface is able
to serve one fetch request per cycle. In case of executing compressed instructions,
on average less than one 32\sphinxhyphen{}bit fetch request will be needed per instruction
in the ID stage.

\sphinxAtStartPar
For optimal performance and timing closure reasons, a prefetcher is used
which fetches instructions via the external bus interface from for example
an externally connected instruction memory or instruction cache.

\sphinxAtStartPar
The prefetch buffer performs word\sphinxhyphen{}aligned 32\sphinxhyphen{}bit prefetches and stores the
fetched words in a FIFO with a number of entries depending of a local parameter.
It is called \sphinxcode{\sphinxupquote{DEPTH}} and can be found in \sphinxcode{\sphinxupquote{cv32e40p\_prefetch\_buffer.sv}} (default value of 2).
As a result of this (speculative) prefetch, CV32E40P can fetch up to \sphinxcode{\sphinxupquote{DEPTH}} words outside of the code region
and care should therefore be taken that no unwanted read side effects occur
for such prefetches outside of the actual code region.

\sphinxAtStartPar
\hyperref[\detokenize{instruction_fetch:instruction-fetch-interface-signals}]{Table \ref{\detokenize{instruction_fetch:instruction-fetch-interface-signals}}} describes the signals that are used to fetch instructions. This
interface is a simplified version of the interface that is used by the
LSU, which is described in {\hyperref[\detokenize{load_store_unit:load-store-unit}]{\sphinxcrossref{\DUrole{std,std-ref}{Load\sphinxhyphen{}Store\sphinxhyphen{}Unit (LSU)}}}}. The difference is that no writes
are possible and thus it needs fewer signals.


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Instruction Fetch interface signals}\label{\detokenize{instruction_fetch:instruction-fetch-interface-signals}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{25}{100}\X{15}{100}\X{60}{100}}
\sphinxtoprule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxstylestrong{Signal}
&
\sphinxAtStartPar
\sphinxstylestrong{Direction}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{instr\_addr\_o{[}31:0{]}}}
&
\sphinxAtStartPar
output
&
\sphinxAtStartPar
Address, word aligned
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{instr\_req\_o}}
&
\sphinxAtStartPar
output
&
\sphinxAtStartPar
Request valid, will stay high until \sphinxcode{\sphinxupquote{instr\_gnt\_i}} is high for one cycle
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{instr\_gnt\_i}}
&
\sphinxAtStartPar
input
&
\sphinxAtStartPar
The other side accepted the request. \sphinxcode{\sphinxupquote{instr\_addr\_o}} may change in the next cycle.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{instr\_rvalid\_i}}
&
\sphinxAtStartPar
input
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{instr\_rdata\_i}} holds valid data when \sphinxcode{\sphinxupquote{instr\_rvalid\_i}} is high. This signal will be high for exactly one cycle per request.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{instr\_rdata\_i{[}31:0{]}}}
&
\sphinxAtStartPar
input
&
\sphinxAtStartPar
Data read from memory
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\section{Misaligned Accesses}
\label{\detokenize{instruction_fetch:misaligned-accesses}}
\sphinxAtStartPar
Externally, the IF interface performs word\sphinxhyphen{}aligned instruction fetches only.
Misaligned instruction fetches are handled by performing two separate word\sphinxhyphen{}aligned instruction fetches.
Internally, the core can deal with both word\sphinxhyphen{} and half\sphinxhyphen{}word\sphinxhyphen{}aligned instruction addresses to support compressed instructions.
The LSB of the instruction address is ignored internally.


\section{Protocol}
\label{\detokenize{instruction_fetch:protocol}}
\sphinxAtStartPar
The CV32E40P instruction fetch interface does not implement the following optional OBI signals: we, be, wdata, auser, wuser, aid,
rready, err, ruser, rid. These signals can be thought of as being tied off as specified in the OBI specification.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
\sphinxstylestrong{Transactions Ordering}
As mentioned above, instruction fetch interface can generate up to \sphinxcode{\sphinxupquote{DEPTH}} outstanding transactions.
OBI specification states that links are always in\sphinxhyphen{}order from master point of view. So as the fetch interface does not generate transaction id (aid),
interconnect infrastructure should ensure that transaction responses come back in the same order they were sent by adding its own additional information.
\end{sphinxadmonition}

\sphinxAtStartPar
\hyperref[\detokenize{instruction_fetch:obi-instruction-basic}]{Figure \ref{\detokenize{instruction_fetch:obi-instruction-basic}}} and \hyperref[\detokenize{instruction_fetch:obi-instruction-multiple-outstanding}]{Figure \ref{\detokenize{instruction_fetch:obi-instruction-multiple-outstanding}}} show example timing diagrams of the protocol.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{obi_instruction_basic}.svg}
\caption{Back\sphinxhyphen{}to\sphinxhyphen{}back Memory Transactions}\label{\detokenize{instruction_fetch:obi-instruction-basic}}\end{figure}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{obi_instruction_multiple_outstanding}.svg}
\caption{Multiple Outstanding Memory Transactions}\label{\detokenize{instruction_fetch:obi-instruction-multiple-outstanding}}\end{figure}

\sphinxstepscope


\chapter{Load\sphinxhyphen{}Store\sphinxhyphen{}Unit (LSU)}
\label{\detokenize{load_store_unit:load-store-unit-lsu}}\label{\detokenize{load_store_unit:load-store-unit}}\label{\detokenize{load_store_unit::doc}}
\sphinxAtStartPar
The Load\sphinxhyphen{}Store Unit (LSU) of the core takes care of accessing the data memory. Load and
stores on words (32 bit), half words (16 bit) and bytes (8 bit) are
supported. The CV32E40P data interface can cause up to 2 outstanding
transactions and there is no FIFO to allow more outstanding requests.

\sphinxAtStartPar
\hyperref[\detokenize{load_store_unit:lsu-interface-signals}]{Table \ref{\detokenize{load_store_unit:lsu-interface-signals}}} describes the signals that are used by the LSU.


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{LSU interface signals}\label{\detokenize{load_store_unit:lsu-interface-signals}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{25}{100}\X{15}{100}\X{60}{100}}
\sphinxtoprule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxstylestrong{Signal}
&
\sphinxAtStartPar
\sphinxstylestrong{Direction}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{data\_addr\_o{[}31:0{]}}}
&
\sphinxAtStartPar
output
&
\sphinxAtStartPar
Address
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{data\_req\_o}}
&
\sphinxAtStartPar
output
&
\sphinxAtStartPar
Request valid, will stay high until \sphinxcode{\sphinxupquote{data\_gnt\_i}} is high for one cycle
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{data\_gnt\_i}}
&
\sphinxAtStartPar
input
&
\sphinxAtStartPar
The other side accepted the request. \sphinxcode{\sphinxupquote{data\_addr\_o}} may change in the next cycle.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{data\_we\_o}}
&
\sphinxAtStartPar
output
&
\sphinxAtStartPar
Write Enable, high for writes, low for reads. Sent together with \sphinxcode{\sphinxupquote{data\_req\_o}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{data\_be\_o{[}3:0{]}}}
&
\sphinxAtStartPar
output
&
\sphinxAtStartPar
Byte Enable. Is set for the bytes to write/read, sent together with \sphinxcode{\sphinxupquote{data\_req\_o}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{data\_wdata\_o{[}31:0{]}}}
&
\sphinxAtStartPar
output
&
\sphinxAtStartPar
Data to be written to memory, sent together with \sphinxcode{\sphinxupquote{data\_req\_o}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{data\_rvalid\_i}}
&
\sphinxAtStartPar
input
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{data\_rvalid\_i}} will be high for exactly one cycle to signal the end of the response phase of for both read and write
transactions. For a read transaction \sphinxcode{\sphinxupquote{data\_rdata\_i}} holds valid data when \sphinxcode{\sphinxupquote{data\_rvalid\_i}} is high.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{data\_rdata\_i{[}31:0{]}}}
&
\sphinxAtStartPar
input
&
\sphinxAtStartPar
Data read from memory
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\section{Misaligned Accesses}
\label{\detokenize{load_store_unit:misaligned-accesses}}
\sphinxAtStartPar
The LSU never raises address\sphinxhyphen{}misaligned exceptions. For loads and stores where the effective address is not naturally aligned to the referenced
datatype (i.e., on a four\sphinxhyphen{}byte boundary for word accesses, and a two\sphinxhyphen{}byte boundary for halfword accesses) the load/store is performed as two
bus transactions in case that the data item crosses a word boundary. A single load/store instruction is therefore performed as two bus
transactions for the following scenarios:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Load/store of a word for a non\sphinxhyphen{}word\sphinxhyphen{}aligned address

\item {} 
\sphinxAtStartPar
Load/store of a halfword crossing a word address boundary

\end{itemize}

\sphinxAtStartPar
In both cases the transfer corresponding to the lowest address is performed first. All other scenarios can be handled with a single bus transaction.


\section{Protocol}
\label{\detokenize{load_store_unit:protocol}}
\sphinxAtStartPar
The CV32E40P data interface does not implement the following optional OBI signals: auser, wuser, aid, rready, err, ruser, rid.
These signals can be thought of as being tied off as specified in the OBI specification.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
\sphinxstylestrong{Transactions Ordering}
As mentioned above, data interface can generate up to 2 outstanding transactions.
OBI specification states that links are always in\sphinxhyphen{}order from master point of view. So as the data interface does not generate transaction id (aid),
interconnect infrastructure should ensure that transaction responses come back in the same order they were sent by adding its own additional information.
\end{sphinxadmonition}

\sphinxAtStartPar
The OBI protocol that is used by the LSU to communicate with a memory works
as follows.

\sphinxAtStartPar
The LSU provides a valid address on \sphinxcode{\sphinxupquote{data\_addr\_o}}, control information
on \sphinxcode{\sphinxupquote{data\_we\_o}}, \sphinxcode{\sphinxupquote{data\_be\_o}} (as well as write data on \sphinxcode{\sphinxupquote{data\_wdata\_o}} in
case of a store) and sets \sphinxcode{\sphinxupquote{data\_req\_o}} high. The memory sets \sphinxcode{\sphinxupquote{data\_gnt\_i}}
high as soon as it is ready to serve the request. This may happen at any
time, even before the request was sent. After a request has been granted
the address phase signals (\sphinxcode{\sphinxupquote{data\_addr\_o}}, \sphinxcode{\sphinxupquote{data\_we\_o}}, \sphinxcode{\sphinxupquote{data\_be\_o}} and
\sphinxcode{\sphinxupquote{data\_wdata\_o}}) may be changed in the next cycle by the LSU as the memory
is assumed to already have processed and stored that information. After
granting a request, the memory answers with a \sphinxcode{\sphinxupquote{data\_rvalid\_i}} set high
if \sphinxcode{\sphinxupquote{data\_rdata\_i}} is valid. This may happen one or more cycles after the
request has been granted. Note that \sphinxcode{\sphinxupquote{data\_rvalid\_i}} must also be set high
to signal the end of the response phase for a write transaction (although
the \sphinxcode{\sphinxupquote{data\_rdata\_i}} has no meaning in that case). When multiple granted requests
are outstanding, it is assumed that the memory requests will be kept in\sphinxhyphen{}order and
one \sphinxcode{\sphinxupquote{data\_rvalid\_i}} will be signalled for each of them, in the order they were issued.

\sphinxAtStartPar
\hyperref[\detokenize{load_store_unit:obi-data-basic}]{Figure \ref{\detokenize{load_store_unit:obi-data-basic}}}, \hyperref[\detokenize{load_store_unit:obi-data-back-to-back}]{Figure \ref{\detokenize{load_store_unit:obi-data-back-to-back}}}, \hyperref[\detokenize{load_store_unit:obi-data-slow-response}]{Figure \ref{\detokenize{load_store_unit:obi-data-slow-response}}} and
\hyperref[\detokenize{load_store_unit:obi-data-multiple-outstanding}]{Figure \ref{\detokenize{load_store_unit:obi-data-multiple-outstanding}}} show example timing diagrams of the protocol.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{obi_data_basic}.svg}
\caption{Basic Memory Transaction}\label{\detokenize{load_store_unit:obi-data-basic}}\end{figure}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{obi_data_back_to_back}.svg}
\caption{Back\sphinxhyphen{}to\sphinxhyphen{}back Memory Transactions}\label{\detokenize{load_store_unit:obi-data-back-to-back}}\end{figure}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{obi_data_slow_response}.svg}
\caption{Slow Response Memory Transaction}\label{\detokenize{load_store_unit:obi-data-slow-response}}\end{figure}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{obi_data_multiple_outstanding}.svg}
\caption{Multiple Outstanding Memory Transactions}\label{\detokenize{load_store_unit:obi-data-multiple-outstanding}}\end{figure}


\section{Post\sphinxhyphen{}Incrementing Load and Store Instructions}
\label{\detokenize{load_store_unit:post-incrementing-load-and-store-instructions}}
\sphinxAtStartPar
This section is only valid if \sphinxcode{\sphinxupquote{COREV\_PULP = 1}}

\sphinxAtStartPar
Post\sphinxhyphen{}incrementing load and store instructions perform a load/store
operation from/to the data memory while at the same time increasing the
base address by the specified offset. For the memory access, the base
address without offset is used.

\sphinxAtStartPar
Post\sphinxhyphen{}incrementing load and stores reduce the number of required
instructions to execute code with regular data access patterns, which
can typically be found in loops. These post\sphinxhyphen{}incrementing load/store
instructions allow the address increment to be embedded in the memory
access instructions and get rid of separate instructions to handle
pointers. Coupled with hardware loop extension, these instructions allow
to reduce the loop overhead significantly.

\sphinxstepscope


\chapter{Register File}
\label{\detokenize{register_file:register-file}}\label{\detokenize{register_file:id1}}\label{\detokenize{register_file::doc}}
\sphinxAtStartPar
Source files: \sphinxcode{\sphinxupquote{rtl/cv32e40p\_register\_file\_ff.sv}}

\sphinxAtStartPar
CV32E40P has 31 32\sphinxhyphen{}bit wide registers which form registers \sphinxcode{\sphinxupquote{x1}} to \sphinxcode{\sphinxupquote{x31}}.
Register \sphinxcode{\sphinxupquote{x0}} is statically bound to 0 and can only be read, it does not
contain any sequential logic.

\sphinxAtStartPar
The register file has three read ports and two write ports. Register file reads are performed in the ID stage.
Register file writes are performed in the WB stage.


\section{Floating\sphinxhyphen{}Point Register File}
\label{\detokenize{register_file:floating-point-register-file}}
\sphinxAtStartPar
If the optional FPU is instantiated, unless \sphinxcode{\sphinxupquote{ZFINX}} is configured, the register file is extended
with an additional register bank of 32 registers \sphinxcode{\sphinxupquote{f0}}\sphinxhyphen{}\sphinxcode{\sphinxupquote{f31}}. These registers
are stacked on top of the existing register file and can be accessed
concurrently with the limitation that a maximum of three operands per
cycle can be read. Each of the three operands addresses is extended with
an register file select signal which is generated in the instruction decoder
when a FP instruction is decoded. This additional signals determines if
the operand is located in the integer or the floating point register
file.

\sphinxAtStartPar
Forwarding paths, and write\sphinxhyphen{}back logic are shared for the integer and
floating point operations and are not replicated.

\sphinxAtStartPar
If \sphinxcode{\sphinxupquote{ZFINX}} parameter is set, there is no additional register bank and FPU instructions are using
the same register file than for integer instructions.

\sphinxstepscope


\chapter{Sleep Unit}
\label{\detokenize{sleep:sleep-unit}}\label{\detokenize{sleep:id1}}\label{\detokenize{sleep::doc}}
\sphinxAtStartPar
Source File: \sphinxcode{\sphinxupquote{rtl/cv32e40p\_sleep\_unit.sv}}

\sphinxAtStartPar
The Sleep Unit contains and controls the instantiated clock gate (see {\hyperref[\detokenize{integration:clock-gating-cell}]{\sphinxcrossref{\DUrole{std,std-ref}{Clock Gating Cell}}}}) that gates \sphinxcode{\sphinxupquote{clk\_i}} and produces a gated clock
for use by the other modules inside CV32E40P. The Sleep Unit is the only place in which \sphinxcode{\sphinxupquote{clk\_i}} itself is used; all other modules use the gated version of \sphinxcode{\sphinxupquote{clk\_i}}.

\sphinxAtStartPar
The clock gating in the Sleep Unit is impacted by the following:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rst\_ni}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fetch\_enable\_i}}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{wfi} instruction (only when \sphinxcode{\sphinxupquote{COREV\_CLUSTER}} = 0)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{cv.elw} instruction (only when \sphinxcode{\sphinxupquote{COREV\_CLUSTER}} = 1)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pulp\_clock\_en\_i}} (only when \sphinxcode{\sphinxupquote{COREV\_CLUSTER}} = 1)

\end{itemize}

\sphinxAtStartPar
\hyperref[\detokenize{sleep:sleep-unit-interface-signals}]{Table \ref{\detokenize{sleep:sleep-unit-interface-signals}}} describes the Sleep Unit interface.


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Sleep Unit interface signals}\label{\detokenize{sleep:sleep-unit-interface-signals}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{20}{100}\X{15}{100}\X{65}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Signal}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Direction}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook\sphinxmultirow{2}{4}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pulp\_clock\_en\_i}}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&\sphinxmultirow{2}{5}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
\sphinxAtStartPar
input
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{COREV\_CLUSTER}} = 0:

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pulp\_clock\_en\_i}} is not used. Tie to 0.
\\
\sphinxvlinecrossing{1}\sphinxcline{3-3}\sphinxfixclines{3}\sphinxtablestrut{4}&\sphinxtablestrut{5}&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{COREV\_CLUSTER}} = 1:

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pulp\_clock\_en\_i}} can be used to gate \sphinxcode{\sphinxupquote{clk\_i}}
internal to the core when \sphinxcode{\sphinxupquote{core\_sleep\_o}} = 1.

\sphinxAtStartPar
See {\hyperref[\detokenize{sleep:pulp-cluster}]{\sphinxcrossref{\DUrole{std,std-ref}{PULP Cluster Extension}}}} for details.
\\
\sphinxhline\sphinxmultirow{2}{8}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{core\_sleep\_o}}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&\sphinxmultirow{2}{9}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
\sphinxAtStartPar
output
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{COREV\_CLUSTER}} = 0:

\sphinxAtStartPar
Core is sleeping because of a \sphinxstylestrong{wfi} instruction.
If \sphinxcode{\sphinxupquote{core\_sleep\_o}} = 1 then \sphinxcode{\sphinxupquote{clk\_i}} is gated
off internally and it is allowing to gate off
\sphinxcode{\sphinxupquote{clk\_i}} externally as well (e.g. FPU).

\sphinxAtStartPar
See {\hyperref[\detokenize{sleep:wfi}]{\sphinxcrossref{\DUrole{std,std-ref}{WFI}}}} for details.
\\
\sphinxvlinecrossing{1}\sphinxcline{3-3}\sphinxfixclines{3}\sphinxtablestrut{8}&\sphinxtablestrut{9}&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{COREV\_CLUSTER}} = 1:

\sphinxAtStartPar
Core is sleeping because
of a \sphinxstylestrong{cv.elw} instruction.
If \sphinxcode{\sphinxupquote{core\_sleep\_o}} = 1,
then the \sphinxcode{\sphinxupquote{pulp\_clock\_en\_i}} directly
controls the internally instantiated clock gate
and therefore \sphinxcode{\sphinxupquote{pulp\_clock\_en\_i}} can be set
to 0 to internally gate off \sphinxcode{\sphinxupquote{clk\_i}}. If
\sphinxcode{\sphinxupquote{core\_sleep\_o}} = 0, then it is not allowed
to set \sphinxcode{\sphinxupquote{pulp\_clock\_en\_i}} to 0.

\sphinxAtStartPar
See {\hyperref[\detokenize{sleep:pulp-cluster}]{\sphinxcrossref{\DUrole{std,std-ref}{PULP Cluster Extension}}}} for details.
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The semantics of \sphinxcode{\sphinxupquote{pulp\_clock\_en\_i}} and \sphinxcode{\sphinxupquote{core\_sleep\_o}} depend on the \sphinxcode{\sphinxupquote{COREV\_CLUSTER}} parameter.
\end{sphinxadmonition}


\section{Startup behavior}
\label{\detokenize{sleep:startup-behavior}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{clk\_i}} is internally gated off (while signaling \sphinxcode{\sphinxupquote{core\_sleep\_o}} = 0) during CV32E40P startup:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{clk\_i}} is internally gated off during \sphinxcode{\sphinxupquote{rst\_ni}} assertion

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{clk\_i}} is internally gated off from \sphinxcode{\sphinxupquote{rst\_ni}} deassertion until \sphinxcode{\sphinxupquote{fetch\_enable\_i}} = 1

\end{itemize}

\sphinxAtStartPar
After initial assertion of \sphinxcode{\sphinxupquote{fetch\_enable\_i}}, the \sphinxcode{\sphinxupquote{fetch\_enable\_i}} signal is ignored until after a next reset assertion.


\section{WFI}
\label{\detokenize{sleep:wfi}}\label{\detokenize{sleep:id2}}
\sphinxAtStartPar
The \sphinxstylestrong{wfi} instruction can under certain conditions be used to enter sleep mode awaiting a locally enabled
interrupt to become pending. The operation of \sphinxstylestrong{wfi} is unaffected by the global interrupt bits in \sphinxstylestrong{mstatus}.

\sphinxAtStartPar
A \sphinxstylestrong{wfi} will not enter sleep mode but will be executed as a regular \sphinxstylestrong{nop}, if any of the following conditions apply:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{debug\_req\_i}} = 1 or a debug request is pending

\item {} 
\sphinxAtStartPar
The core is in debug mode

\item {} 
\sphinxAtStartPar
The core is performing single stepping (debug)

\item {} 
\sphinxAtStartPar
The core has a trigger match (debug)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{COREV\_CLUSTER}} = 1

\end{itemize}

\sphinxAtStartPar
If a \sphinxstylestrong{wfi} causes sleep mode entry, then \sphinxcode{\sphinxupquote{core\_sleep\_o}} is set to 1 and \sphinxcode{\sphinxupquote{clk\_i}} is gated off internally.
\sphinxcode{\sphinxupquote{clk\_i}} is allowed to be gated off externally as well in this scenario. A wake\sphinxhyphen{}up can be triggered by any of the following:
\begin{itemize}
\item {} 
\sphinxAtStartPar
A locally enabled interrupt is pending

\item {} 
\sphinxAtStartPar
A debug request is pending

\item {} 
\sphinxAtStartPar
Core is in debug mode

\end{itemize}

\sphinxAtStartPar
Upon wake\sphinxhyphen{}up \sphinxcode{\sphinxupquote{core\_sleep\_o}} is set to 0, \sphinxcode{\sphinxupquote{clk\_i}} will no longer be gated internally, must not be gated off externally, and
instruction execution resumes.

\sphinxAtStartPar
If one of the above wake\sphinxhyphen{}up conditions coincides with the \sphinxstylestrong{wfi} instruction, then sleep mode is not entered and \sphinxcode{\sphinxupquote{core\_sleep\_o}}
will not become 1.

\sphinxAtStartPar
\hyperref[\detokenize{sleep:wfi-example}]{Figure \ref{\detokenize{sleep:wfi-example}}} shows an example waveform for sleep mode entry because of a \sphinxstylestrong{wfi} instruction.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{wfi}.svg}
\caption{\sphinxstylestrong{wfi} example}\label{\detokenize{sleep:wfi-example}}\end{figure}


\section{PULP Cluster Extension}
\label{\detokenize{sleep:pulp-cluster-extension}}\label{\detokenize{sleep:pulp-cluster}}
\sphinxAtStartPar
CV32E40P has an optional extension to enable its usage in a PULP Cluster in the PULP (Parallel Ultra Low Power) platform.
This extension is enabled by setting the \sphinxcode{\sphinxupquote{COREV\_CLUSTER}} parameter to 1. The PULP platform is organized as clusters of
multiple (typically 4 or 8) CV32E40P cores that share a tightly\sphinxhyphen{}coupled data memory, aimed at running digital signal processing
applications efficiently.

\sphinxAtStartPar
The mechanism via which CV32E40P cores in a PULP Cluster synchronize with each other is implemented via the custom \sphinxstylestrong{cv.elw} instruction
that performs a read transaction on an external Event Unit (which for example implements barriers and semaphores). This
read transaction to the Event Unit together with the \sphinxcode{\sphinxupquote{core\_sleep\_o}} signal inform the Event Unit that the CV32E40P is not busy and
ready to go to sleep. Only in that case the Event Unit is allowed to set \sphinxcode{\sphinxupquote{pulp\_clock\_en\_i}} to 0, thereby gating off \sphinxcode{\sphinxupquote{clk\_i}}
internal to the core. Once the CV32E40P core is ready to start again (e.g. when the last core meets the barrier), \sphinxcode{\sphinxupquote{pulp\_clock\_en\_i}} is
set to 1 thereby enabling the CV32E40P to run again.

\sphinxAtStartPar
If the PULP Cluster extension is not used (\sphinxcode{\sphinxupquote{COREV\_CLUSTER}} = 0), the \sphinxcode{\sphinxupquote{pulp\_clock\_en\_i}} signal is not used and should be tied to 0.

\sphinxAtStartPar
Execution of a \sphinxstylestrong{cv.elw} instructions causes \sphinxcode{\sphinxupquote{core\_sleep\_o}} = 1 only if all of the following conditions are met:
\begin{itemize}
\item {} 
\sphinxAtStartPar
The \sphinxstylestrong{cv.elw} did not yet complete (which can be achieved by witholding \sphinxcode{\sphinxupquote{data\_gnt\_i}} and/or \sphinxcode{\sphinxupquote{data\_rvalid\_i}})

\item {} 
\sphinxAtStartPar
No debug request is pending

\item {} 
\sphinxAtStartPar
The core is not in debug mode

\item {} 
\sphinxAtStartPar
The core is not single stepping (debug)

\item {} 
\sphinxAtStartPar
The core does not have a trigger match (debug)

\end{itemize}

\sphinxAtStartPar
As \sphinxcode{\sphinxupquote{pulp\_clock\_en\_i}} can directly impact the internal clock gate, certain requirements are imposed on the environment of CV32E40P
in case \sphinxcode{\sphinxupquote{COREV\_CLUSTER}} = 1:
\begin{itemize}
\item {} 
\sphinxAtStartPar
If \sphinxcode{\sphinxupquote{core\_sleep\_o}} = 0, then \sphinxcode{\sphinxupquote{pulp\_clock\_en\_i}} must be 1

\item {} 
\sphinxAtStartPar
If \sphinxcode{\sphinxupquote{pulp\_clock\_en\_i}} = 0, then \sphinxcode{\sphinxupquote{irq\_i{[}*{]}}} must be 0

\item {} 
\sphinxAtStartPar
If \sphinxcode{\sphinxupquote{pulp\_clock\_en\_i}} = 0, then \sphinxcode{\sphinxupquote{debug\_req\_i}} must be 0

\item {} 
\sphinxAtStartPar
If \sphinxcode{\sphinxupquote{pulp\_clock\_en\_i}} = 0, then \sphinxcode{\sphinxupquote{instr\_rvalid\_i}} must be 0

\item {} 
\sphinxAtStartPar
If \sphinxcode{\sphinxupquote{pulp\_clock\_en\_i}} = 0, then \sphinxcode{\sphinxupquote{instr\_gnt\_i}} must be 0

\item {} 
\sphinxAtStartPar
If \sphinxcode{\sphinxupquote{pulp\_clock\_en\_i}} = 0, then \sphinxcode{\sphinxupquote{data\_rvalid\_i}} must be 0

\item {} 
\sphinxAtStartPar
If \sphinxcode{\sphinxupquote{pulp\_clock\_en\_i}} = 0, then \sphinxcode{\sphinxupquote{data\_gnt\_i}} must be 0

\end{itemize}

\sphinxAtStartPar
\hyperref[\detokenize{sleep:load-event-example}]{Figure \ref{\detokenize{sleep:load-event-example}}} shows an example waveform for sleep mode entry because of a \sphinxstylestrong{cv.elw} instruction.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{load_event}.svg}
\caption{\sphinxstylestrong{cv.elw} example}\label{\detokenize{sleep:load-event-example}}\end{figure}

\sphinxstepscope


\chapter{Core Versions and RTL Freeze Rules}
\label{\detokenize{core_versions:core-versions-and-rtl-freeze-rules}}\label{\detokenize{core_versions:core-versions}}\label{\detokenize{core_versions::doc}}
\sphinxAtStartPar
The CV32E40P is defined by the \sphinxcode{\sphinxupquote{marchid}} and \sphinxcode{\sphinxupquote{mimpid}} tuple.
The tuple identify which sets of parameters have been verified
by OpenHW Group, and once RTL Freeze is achieved, no further
non\sphinxhyphen{}logically equivalent changes are allowed on that set of parameters.

\sphinxAtStartPar
The RTL Freeze version of the core is indentified by a GitHub
tag with the format cv32e40p\_vMAJOR.MINOR.PATCH (e.g. cv32e40p\_v1.0.0).
In addition, the release date is reported in the documentation.


\section{What happens after RTL Freeze?}
\label{\detokenize{core_versions:what-happens-after-rtl-freeze}}

\subsection{RTL changes on verified parameters}
\label{\detokenize{core_versions:rtl-changes-on-verified-parameters}}
\sphinxAtStartPar
Minor changes to the RTL on a frozen parameter set (e.g., nicer RTL code, clearer RTL code, etc) are allowed if, and only if, they are logically equivalent to the frozen (tagged) version of the core.
This is guaranteed by a CI flow that checks that pull requests are logically equivalent to a specific tag of the core as
explained \sphinxhref{https://github.com/openhwgroup/cv32e40p/blob/master/.github/workflows/aws\_cv32e40p.md}{here}.
For example, suppose we re\sphinxhyphen{}write “better” a portion of the ALU that affects the frozen set of parameters of the version cv32e40p\_v1.0.0,
for instance, the adder. In that case, the proposed changes are compared with the code based on cv32e40p\_v1.0.0, and if they are logically equivalent, they are accepted. Otherwise, they are rejected. See below for more case scenarios.


\subsection{A bug is found}
\label{\detokenize{core_versions:a-bug-is-found}}
\sphinxAtStartPar
If a bug is found that affect the already frozen parameter set,
the RTL changes required to fix such bug are non\sphinxhyphen{}logically equivalent by definition.
Therefore, the RTL changes are applied only on a different  \sphinxcode{\sphinxupquote{mimpid}}
value and the bug and the fix must be documented.
These changes are visible by software as the \sphinxcode{\sphinxupquote{mimpid}} has a different value.
Every bug or set of bugs found must be followed by another RTL Freeze release and a new GitHub tag.


\subsection{RTL changes on non\sphinxhyphen{}verified yet parameters}
\label{\detokenize{core_versions:rtl-changes-on-non-verified-yet-parameters}}
\sphinxAtStartPar
If changes affecting the core on a non\sphinxhyphen{}frozen parameter set are required,
as for example, to fix bugs found in the communication to the FPU (e.g., affecting the core only if \sphinxcode{\sphinxupquote{FPU=1}}),
or to change the ISA Extensions decoding of PULP instructions (e.g., affecting the core only if \sphinxcode{\sphinxupquote{PULP\_XPULP=1}}),
then such changes must remain logically equivalent for the already frozen set of parameters (except for the required \sphinxcode{\sphinxupquote{mimpid}} update), and they must be applied on a different \sphinxcode{\sphinxupquote{mimpid}} value. They can be non\sphinxhyphen{}logically equivalent to a non\sphinxhyphen{}frozen set of parameters.
These changes are visible by software as the \sphinxcode{\sphinxupquote{mimpid}} has a different value.
Once the new set of parameters is verified and achieved the sign\sphinxhyphen{}off for RTL freeze,
a new GitHub tag and version of the core is released.


\subsection{PPA optimizations and new features}
\label{\detokenize{core_versions:ppa-optimizations-and-new-features}}
\sphinxAtStartPar
Non\sphinxhyphen{}logically equivalent PPA optimizations and new features are not allowed on a given set
of RTL frozen parameters (e.g., a faster divider).
If PPA optimizations are logically\sphinxhyphen{}equivalent instead, they can be applied without
changing the \sphinxcode{\sphinxupquote{mimpid}} value (as such changes are not visible in software).
However, a new GitHub tag should be release and changes documented.

\sphinxAtStartPar
\hyperref[\detokenize{core_versions:rtl-freeze-rules}]{Figure \ref{\detokenize{core_versions:rtl-freeze-rules}}} shows the aforementioned rules.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{rtl_freeze_rules}.png}
\caption{Versions control of CV32E40P}\label{\detokenize{core_versions:rtl-freeze-rules}}\end{figure}


\section{Non\sphinxhyphen{}backward compatibility}
\label{\detokenize{core_versions:non-backward-compatibility}}\label{\detokenize{core_versions:backward-compatibility}}
\sphinxAtStartPar
For cv32e40p\_v2.0.0, some modifications have been done on \sphinxcode{\sphinxupquote{cv32e40p\_top}} and \sphinxcode{\sphinxupquote{cv32e40p\_core}} parameters names.

\sphinxAtStartPar
It is worth mentioning that if the core in its v1 version was/is instantiated without parameters setting, backward compatibility is still correct as all parameters default values are set to v1 values.


\subsection{Parameters}
\label{\detokenize{core_versions:parameters}}
\sphinxAtStartPar
As RTL has been updated to fully support ratified RISC\sphinxhyphen{}V Zfinx, old PULP\_ZFINX parameter has been renamed ZFINX in all design and verification files.

\sphinxAtStartPar
To differentiate v1 to v2 encoding of PULP instructions, old PULP\_XPULP and PULP\_CLUSTER parameters have been renamed COREV\_PULP and COREV\_CLUSTER in all design and verification files.

\sphinxAtStartPar
To easily change FPU instructions latencies, 2 new parameters have been added, FPU\_ADDMUL\_LAT for Addition/Multiplication lane and FPU\_OTHERS\_LAT for the other instructions (move, conversion, comparison…).


\section{Released core versions}
\label{\detokenize{core_versions:released-core-versions}}
\sphinxAtStartPar
The verified parameter sets of the core, their implementation version, GitHub tags, and dates are reported here.


\subsection{cv32e40p\_v1.0.0}
\label{\detokenize{core_versions:cv32e40p-v1-0-0}}

\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TTTTT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Git Tag
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Tagged By
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Date
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Reason for Release
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Comment
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
cv32e40p\_v1.0.0
&
\sphinxAtStartPar
Arjan Bink
&
\sphinxAtStartPar
2020\sphinxhyphen{}12\sphinxhyphen{}10
&
\sphinxAtStartPar
RTL Freeze
&\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
For this release \sphinxcode{\sphinxupquote{mimpid}} value is fixed and is equal to \sphinxcode{\sphinxupquote{0}}.

\sphinxAtStartPar
It refers to the CV32E40P core verified with the following parameters:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Name
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Value
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FPU}}
&
\sphinxAtStartPar
0
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PULP\_ZFINX}}
&
\sphinxAtStartPar
0
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PULP\_XPULP}}
&
\sphinxAtStartPar
0
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PULP\_CLUSTER}}
&
\sphinxAtStartPar
0
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Verification of cv32e40p\_v1.0.0 has been done with only following value for \sphinxcode{\sphinxupquote{NUM\_MHPMCOUNTERS}} parameter: \sphinxcode{\sphinxupquote{NUM\_MHPMCOUNTERS}} == 1.

\sphinxAtStartPar
The list of open (waived) issues at the time of applying the cv32e40p\_v1.0.0 tag can be found at:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxurl{https://github.com/openhwgroup/programs/blob/7a72508c90484a7835590a97038eb9dd53bd8c32/milestones/CV32E40P/RTL\_Freeze\_v1.0.0/Design\_openissues.md}

\item {} 
\sphinxAtStartPar
\sphinxurl{https://github.com/openhwgroup/programs/blob/7a72508c90484a7835590a97038eb9dd53bd8c32/milestones/CV32E40P/RTL\_Freeze\_v1.0.0/Verification\_openissues.md}

\item {} 
\sphinxAtStartPar
\sphinxurl{https://github.com/openhwgroup/programs/blob/7a72508c90484a7835590a97038eb9dd53bd8c32/milestones/CV32E40P/RTL\_Freeze\_v1.0.0/Documentation\_openissues.md}

\end{itemize}


\subsection{cv32e40p\_v2.0.0}
\label{\detokenize{core_versions:cv32e40p-v2-0-0}}

\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TTTTT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Git Tag
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Tagged By
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Date
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Reason for Release
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Comment
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
cv32e40p\_v2.0.0
&&&
\sphinxAtStartPar
RTL Freeze
&\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
For this release \sphinxcode{\sphinxupquote{mimpid}} value is depending of parameters value.


\subsubsection{mimpid = 0}
\label{\detokenize{core_versions:mimpid-0}}
\sphinxAtStartPar
When parameters are set with the exact same values than for cv32e40p\_v1.0.0 release then \sphinxcode{\sphinxupquote{mimpid}} value is equal to \sphinxcode{\sphinxupquote{0}}.


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Name
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Value
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FPU}}
&
\sphinxAtStartPar
0
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ZFINX}}
&
\sphinxAtStartPar
0
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{COREV\_PULP}}
&
\sphinxAtStartPar
0
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{COREV\_CLUSTER}}
&
\sphinxAtStartPar
0
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\subsubsection{mimpid = 1}
\label{\detokenize{core_versions:mimpid-1}}
\sphinxAtStartPar
When one parameter is set with a different value than for cv32e40p\_v1.0.0 release then \sphinxcode{\sphinxupquote{mimpid}} value is equal to \sphinxcode{\sphinxupquote{1}}.

\sphinxAtStartPar
This means either \sphinxcode{\sphinxupquote{FPU}}, \sphinxcode{\sphinxupquote{COREV\_PULP}} or \sphinxcode{\sphinxupquote{COREV\_CLUSTER}} is set to 1.

\sphinxstepscope


\chapter{Glossary}
\label{\detokenize{glossary:glossary}}\label{\detokenize{glossary:id1}}\label{\detokenize{glossary::doc}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{ALU}: Arithmetic/Logic Unit

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{ASIC}: Application\sphinxhyphen{}Specific Integrated Circuit

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Byte}: 8\sphinxhyphen{}bit data item

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{CPU}: Central Processing Unit, processor

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{CSR}: Control and Status Register

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Custom extension}: Non\sphinxhyphen{}Standard extension to the RISC\sphinxhyphen{}V base instruction set (RISC\sphinxhyphen{}V Instruction Set Manual, Volume I: User\sphinxhyphen{}Level ISA)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{EX}: Instruction Execute

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{FPGA}: Field Programmable Gate Array

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{FPU}: Floating Point Unit

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Halfword}: 16\sphinxhyphen{}bit data item

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Halfword aligned address}: An address is halfword aligned if it is divisible by 2

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{ID}: Instruction Decode

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{IF}: Instruction Fetch ({\hyperref[\detokenize{instruction_fetch:instruction-fetch}]{\sphinxcrossref{\DUrole{std,std-ref}{Instruction Fetch}}}})

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{ISA}: Instruction Set Architecture

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{KGE}: kilo gate equivalents (NAND2)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{LSU}: Load Store Unit ({\hyperref[\detokenize{load_store_unit:load-store-unit}]{\sphinxcrossref{\DUrole{std,std-ref}{Load\sphinxhyphen{}Store\sphinxhyphen{}Unit (LSU)}}}})

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{M\sphinxhyphen{}Mode}: Machine Mode (RISC\sphinxhyphen{}V Instruction Set Manual, Volume II: Privileged Architecture)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{OBI}: Open Bus Interface

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{PC}: Program Counter

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{PULP platform}: Parallel Ultra Low Power Platform (\textless{}\sphinxurl{https://pulp-platform.org}\textgreater{})

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{RV32C}: RISC\sphinxhyphen{}V Compressed (C extension)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{RV32F}: RISC\sphinxhyphen{}V Floating Point (F extension)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{SIMD}: Single Instruction/Multiple Data

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Standard extension}: Standard extension to the RISC\sphinxhyphen{}V base instruction set (RISC\sphinxhyphen{}V Instruction Set Manual, Volume I: User\sphinxhyphen{}Level ISA)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{WARL}: Write Any Values, Reads Legal Values

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{WB}: Write Back of instruction results

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{WLRL}: Write/Read Only Legal Values

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Word}: 32\sphinxhyphen{}bit data item

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Word aligned address}: An address is word aligned if it is divisible by 4

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{WPRI}: Reserved Writes Preserve Values, Reads Ignore Values

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}